
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>demo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-kure/kure/cmd/demo/generators_gvk_demo.go (87.9%)</option>
				
				<option value="file1">github.com/go-kure/kure/cmd/demo/main.go (56.5%)</option>
				
				<option value="file2">github.com/go-kure/kure/cmd/kure/main.go (0.0%)</option>
				
				<option value="file3">github.com/go-kure/kure/cmd/kurel/main.go (0.0%)</option>
				
				<option value="file4">github.com/go-kure/kure/cmd/test/main.go (0.0%)</option>
				
				<option value="file5">github.com/go-kure/kure/internal/certmanager/acme.go (100.0%)</option>
				
				<option value="file6">github.com/go-kure/kure/internal/certmanager/certificate.go (100.0%)</option>
				
				<option value="file7">github.com/go-kure/kure/internal/certmanager/clusterissuer.go (100.0%)</option>
				
				<option value="file8">github.com/go-kure/kure/internal/certmanager/issuer.go (91.7%)</option>
				
				<option value="file9">github.com/go-kure/kure/internal/externalsecrets/clustersecretstore.go (100.0%)</option>
				
				<option value="file10">github.com/go-kure/kure/internal/externalsecrets/externalsecret.go (100.0%)</option>
				
				<option value="file11">github.com/go-kure/kure/internal/externalsecrets/secretstore.go (100.0%)</option>
				
				<option value="file12">github.com/go-kure/kure/internal/fluxcd/fluxinstance.go (19.2%)</option>
				
				<option value="file13">github.com/go-kure/kure/internal/fluxcd/fluxreport.go (30.8%)</option>
				
				<option value="file14">github.com/go-kure/kure/internal/fluxcd/helm.go (73.3%)</option>
				
				<option value="file15">github.com/go-kure/kure/internal/fluxcd/image.go (65.1%)</option>
				
				<option value="file16">github.com/go-kure/kure/internal/fluxcd/kustomize.go (59.0%)</option>
				
				<option value="file17">github.com/go-kure/kure/internal/fluxcd/notification.go (100.0%)</option>
				
				<option value="file18">github.com/go-kure/kure/internal/fluxcd/resourceset.go (58.8%)</option>
				
				<option value="file19">github.com/go-kure/kure/internal/fluxcd/resourcesetinputprovider.go (76.9%)</option>
				
				<option value="file20">github.com/go-kure/kure/internal/fluxcd/schedule.go (77.8%)</option>
				
				<option value="file21">github.com/go-kure/kure/internal/fluxcd/source.go (42.3%)</option>
				
				<option value="file22">github.com/go-kure/kure/internal/gvk/conversion.go (0.0%)</option>
				
				<option value="file23">github.com/go-kure/kure/internal/gvk/parsing.go (8.2%)</option>
				
				<option value="file24">github.com/go-kure/kure/internal/gvk/registry.go (100.0%)</option>
				
				<option value="file25">github.com/go-kure/kure/internal/gvk/types.go (100.0%)</option>
				
				<option value="file26">github.com/go-kure/kure/internal/gvk/wrapper.go (0.0%)</option>
				
				<option value="file27">github.com/go-kure/kure/internal/kubernetes/configmap.go (71.7%)</option>
				
				<option value="file28">github.com/go-kure/kure/internal/kubernetes/container.go (80.4%)</option>
				
				<option value="file29">github.com/go-kure/kure/internal/kubernetes/daemonset.go (60.9%)</option>
				
				<option value="file30">github.com/go-kure/kure/internal/kubernetes/deployment.go (71.1%)</option>
				
				<option value="file31">github.com/go-kure/kure/internal/kubernetes/ingress.go (85.7%)</option>
				
				<option value="file32">github.com/go-kure/kure/internal/kubernetes/job.go (64.5%)</option>
				
				<option value="file33">github.com/go-kure/kure/internal/kubernetes/kustomization_yaml.go (88.9%)</option>
				
				<option value="file34">github.com/go-kure/kure/internal/kubernetes/namespace.go (83.3%)</option>
				
				<option value="file35">github.com/go-kure/kure/internal/kubernetes/persistentvolumeclaim.go (100.0%)</option>
				
				<option value="file36">github.com/go-kure/kure/internal/kubernetes/pod.go (70.1%)</option>
				
				<option value="file37">github.com/go-kure/kure/internal/kubernetes/podspec.go (78.1%)</option>
				
				<option value="file38">github.com/go-kure/kure/internal/kubernetes/policies.go (38.9%)</option>
				
				<option value="file39">github.com/go-kure/kure/internal/kubernetes/roles.go (100.0%)</option>
				
				<option value="file40">github.com/go-kure/kure/internal/kubernetes/secret.go (70.5%)</option>
				
				<option value="file41">github.com/go-kure/kure/internal/kubernetes/service.go (84.3%)</option>
				
				<option value="file42">github.com/go-kure/kure/internal/kubernetes/serviceaccount.go (75.0%)</option>
				
				<option value="file43">github.com/go-kure/kure/internal/kubernetes/statefulset.go (64.7%)</option>
				
				<option value="file44">github.com/go-kure/kure/internal/kubernetes/storageclass.go (85.2%)</option>
				
				<option value="file45">github.com/go-kure/kure/internal/metallb/bfdprofile.go (100.0%)</option>
				
				<option value="file46">github.com/go-kure/kure/internal/metallb/bgpadvertisement.go (100.0%)</option>
				
				<option value="file47">github.com/go-kure/kure/internal/metallb/bgppeer.go (100.0%)</option>
				
				<option value="file48">github.com/go-kure/kure/internal/metallb/ipaddresspool.go (100.0%)</option>
				
				<option value="file49">github.com/go-kure/kure/internal/metallb/l2advertisement.go (100.0%)</option>
				
				<option value="file50">github.com/go-kure/kure/internal/validation/validators.go (100.0%)</option>
				
				<option value="file51">github.com/go-kure/kure/pkg/cli/config.go (81.0%)</option>
				
				<option value="file52">github.com/go-kure/kure/pkg/cli/factory.go (100.0%)</option>
				
				<option value="file53">github.com/go-kure/kure/pkg/cli/printer.go (97.0%)</option>
				
				<option value="file54">github.com/go-kure/kure/pkg/cmd/kure/cmd.go (71.4%)</option>
				
				<option value="file55">github.com/go-kure/kure/pkg/cmd/kure/generate/app.go (5.1%)</option>
				
				<option value="file56">github.com/go-kure/kure/pkg/cmd/kure/generate/bootstrap.go (6.7%)</option>
				
				<option value="file57">github.com/go-kure/kure/pkg/cmd/kure/generate/cluster.go (6.6%)</option>
				
				<option value="file58">github.com/go-kure/kure/pkg/cmd/kure/generate/generate.go (100.0%)</option>
				
				<option value="file59">github.com/go-kure/kure/pkg/cmd/kure/patch.go (39.2%)</option>
				
				<option value="file60">github.com/go-kure/kure/pkg/cmd/kurel/cmd.go (17.3%)</option>
				
				<option value="file61">github.com/go-kure/kure/pkg/cmd/shared/completion.go (100.0%)</option>
				
				<option value="file62">github.com/go-kure/kure/pkg/cmd/shared/config.go (100.0%)</option>
				
				<option value="file63">github.com/go-kure/kure/pkg/cmd/shared/options/global.go (100.0%)</option>
				
				<option value="file64">github.com/go-kure/kure/pkg/cmd/shared/version.go (100.0%)</option>
				
				<option value="file65">github.com/go-kure/kure/pkg/errors/errors.go (92.3%)</option>
				
				<option value="file66">github.com/go-kure/kure/pkg/errors/parse.go (0.0%)</option>
				
				<option value="file67">github.com/go-kure/kure/pkg/io/printer.go (81.3%)</option>
				
				<option value="file68">github.com/go-kure/kure/pkg/io/runtime.go (78.3%)</option>
				
				<option value="file69">github.com/go-kure/kure/pkg/io/table.go (37.2%)</option>
				
				<option value="file70">github.com/go-kure/kure/pkg/io/yaml.go (84.9%)</option>
				
				<option value="file71">github.com/go-kure/kure/pkg/kubernetes/fluxcd/create.go (100.0%)</option>
				
				<option value="file72">github.com/go-kure/kure/pkg/kubernetes/fluxcd/update.go (78.2%)</option>
				
				<option value="file73">github.com/go-kure/kure/pkg/kubernetes/scheme.go (35.5%)</option>
				
				<option value="file74">github.com/go-kure/kure/pkg/kubernetes/utilities.go (90.0%)</option>
				
				<option value="file75">github.com/go-kure/kure/pkg/launcher/builder.go (77.2%)</option>
				
				<option value="file76">github.com/go-kure/kure/pkg/launcher/cli.go (83.8%)</option>
				
				<option value="file77">github.com/go-kure/kure/pkg/launcher/deepcopy.go (0.0%)</option>
				
				<option value="file78">github.com/go-kure/kure/pkg/launcher/errors.go (26.3%)</option>
				
				<option value="file79">github.com/go-kure/kure/pkg/launcher/extensions.go (80.3%)</option>
				
				<option value="file80">github.com/go-kure/kure/pkg/launcher/loader.go (81.6%)</option>
				
				<option value="file81">github.com/go-kure/kure/pkg/launcher/options.go (42.3%)</option>
				
				<option value="file82">github.com/go-kure/kure/pkg/launcher/patch_processor.go (72.1%)</option>
				
				<option value="file83">github.com/go-kure/kure/pkg/launcher/resolver.go (89.0%)</option>
				
				<option value="file84">github.com/go-kure/kure/pkg/launcher/schema.go (86.0%)</option>
				
				<option value="file85">github.com/go-kure/kure/pkg/launcher/types.go (100.0%)</option>
				
				<option value="file86">github.com/go-kure/kure/pkg/launcher/validator.go (78.0%)</option>
				
				<option value="file87">github.com/go-kure/kure/pkg/logger/logger.go (100.0%)</option>
				
				<option value="file88">github.com/go-kure/kure/pkg/patch/apply.go (75.0%)</option>
				
				<option value="file89">github.com/go-kure/kure/pkg/patch/loader.go (68.7%)</option>
				
				<option value="file90">github.com/go-kure/kure/pkg/patch/op.go (47.8%)</option>
				
				<option value="file91">github.com/go-kure/kure/pkg/patch/set.go (24.7%)</option>
				
				<option value="file92">github.com/go-kure/kure/pkg/patch/toml_parser.go (58.9%)</option>
				
				<option value="file93">github.com/go-kure/kure/pkg/patch/yaml_preserve.go (50.9%)</option>
				
				<option value="file94">github.com/go-kure/kure/pkg/stack/application.go (100.0%)</option>
				
				<option value="file95">github.com/go-kure/kure/pkg/stack/application_wrapper.go (88.2%)</option>
				
				<option value="file96">github.com/go-kure/kure/pkg/stack/argocd/argo.go (92.5%)</option>
				
				<option value="file97">github.com/go-kure/kure/pkg/stack/builders.go (90.2%)</option>
				
				<option value="file98">github.com/go-kure/kure/pkg/stack/bundle.go (24.3%)</option>
				
				<option value="file99">github.com/go-kure/kure/pkg/stack/cluster.go (45.0%)</option>
				
				<option value="file100">github.com/go-kure/kure/pkg/stack/fluxcd/bootstrap_generator.go (1.7%)</option>
				
				<option value="file101">github.com/go-kure/kure/pkg/stack/fluxcd/fluxcd.go (71.4%)</option>
				
				<option value="file102">github.com/go-kure/kure/pkg/stack/fluxcd/layout_integrator.go (2.3%)</option>
				
				<option value="file103">github.com/go-kure/kure/pkg/stack/fluxcd/resource_generator.go (57.1%)</option>
				
				<option value="file104">github.com/go-kure/kure/pkg/stack/fluxcd/workflow_engine.go (22.2%)</option>
				
				<option value="file105">github.com/go-kure/kure/pkg/stack/generators/appworkload/internal/appworkload.go (39.5%)</option>
				
				<option value="file106">github.com/go-kure/kure/pkg/stack/generators/appworkload/v1alpha1.go (100.0%)</option>
				
				<option value="file107">github.com/go-kure/kure/pkg/stack/generators/fluxhelm/internal/fluxhelm.go (0.0%)</option>
				
				<option value="file108">github.com/go-kure/kure/pkg/stack/generators/fluxhelm/v1alpha1.go (100.0%)</option>
				
				<option value="file109">github.com/go-kure/kure/pkg/stack/generators/kurelpackage/v1alpha1.go (27.5%)</option>
				
				<option value="file110">github.com/go-kure/kure/pkg/stack/generators/registry.go (66.7%)</option>
				
				<option value="file111">github.com/go-kure/kure/pkg/stack/layout/config.go (16.7%)</option>
				
				<option value="file112">github.com/go-kure/kure/pkg/stack/layout/manifest.go (81.0%)</option>
				
				<option value="file113">github.com/go-kure/kure/pkg/stack/layout/profile.go (0.0%)</option>
				
				<option value="file114">github.com/go-kure/kure/pkg/stack/layout/types.go (5.6%)</option>
				
				<option value="file115">github.com/go-kure/kure/pkg/stack/layout/walker.go (75.3%)</option>
				
				<option value="file116">github.com/go-kure/kure/pkg/stack/layout/write.go (69.9%)</option>
				
				<option value="file117">github.com/go-kure/kure/pkg/stack/v1alpha1/bundle.go (88.5%)</option>
				
				<option value="file118">github.com/go-kure/kure/pkg/stack/v1alpha1/cluster.go (100.0%)</option>
				
				<option value="file119">github.com/go-kure/kure/pkg/stack/v1alpha1/converters.go (96.2%)</option>
				
				<option value="file120">github.com/go-kure/kure/pkg/stack/v1alpha1/node.go (87.2%)</option>
				
				<option value="file121">github.com/go-kure/kure/pkg/stack/v1alpha1/registry.go (93.5%)</option>
				
				<option value="file122">github.com/go-kure/kure/pkg/stack/workflow.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"
        "strings"

        "gopkg.in/yaml.v3"

        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/generators"
        _ "github.com/go-kure/kure/pkg/stack/generators/appworkload" // Register AppWorkload
        _ "github.com/go-kure/kure/pkg/stack/generators/fluxhelm"    // Register FluxHelm
)

// Example YAML configurations using GVK format
const appWorkloadYAML = `
apiVersion: generators.gokure.dev/v1alpha1
kind: AppWorkload
metadata:
  name: nginx-app
  namespace: web
spec:
  workload: Deployment
  replicas: 3
  containers:
    - name: nginx
      image: nginx:1.21
      ports:
        - containerPort: 80
          name: http
      resources:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "256Mi"
          cpu: "500m"
  services:
    - name: nginx-service
      type: LoadBalancer
      ports:
        - port: 80
          targetPort: 80
          protocol: TCP
`

const fluxHelmYAML = `
apiVersion: generators.gokure.dev/v1alpha1
kind: FluxHelm
metadata:
  name: postgresql
  namespace: database
spec:
  chart:
    name: postgresql
    version: 12.0.0
  source:
    type: HelmRepository
    url: https://charts.bitnami.com/bitnami
    interval: 10m
  values:
    auth:
      database: myapp
      username: myuser
    persistence:
      enabled: true
      size: 10Gi
  release:
    createNamespace: true
    cleanupOnFail: true
  interval: 30m
  timeout: 5m
`

const fluxHelmOCIYAML = `
apiVersion: generators.gokure.dev/v1alpha1
kind: FluxHelm
metadata:
  name: podinfo
  namespace: apps
spec:
  chart:
    name: podinfo
    version: "6.*"
  source:
    type: OCIRepository
    ociUrl: oci://ghcr.io/stefanprodan/charts/podinfo
    interval: 10m
  values:
    replicaCount: 2
    service:
      type: ClusterIP
  interval: 10m
`

// DemoGVKGenerators demonstrates the new GVK-based generator system
func DemoGVKGenerators() <span class="cov5" title="2">{
        fmt.Println("\n=== GVK-Based Generators Demo ===")

        // Demo 1: Parse and generate AppWorkload
        fmt.Println("1. AppWorkload Generator:")
        fmt.Println(strings.Repeat("-", 40))

        var appWrapper stack.ApplicationWrapper
        if err := yaml.Unmarshal([]byte(appWorkloadYAML), &amp;appWrapper); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to unmarshal AppWorkload: %v", err)
        }</span>

        <span class="cov5" title="2">fmt.Printf("Parsed: %s %s\n", appWrapper.APIVersion, appWrapper.Kind)
        fmt.Printf("Name: %s, Namespace: %s\n", appWrapper.Metadata.Name, appWrapper.Metadata.Namespace)

        app := appWrapper.ToApplication()
        objects, err := app.Config.Generate(app)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to generate AppWorkload resources: %v", err)
        }</span>

        <span class="cov5" title="2">fmt.Printf("Generated %d resources:\n", len(objects))
        for _, obj := range objects </span><span class="cov10" title="4">{
                o := *obj
                fmt.Printf("  - %s: %s/%s\n", o.GetObjectKind().GroupVersionKind().Kind,
                        o.GetNamespace(), o.GetName())
        }</span>

        // Demo 2: Parse and generate FluxHelm with HelmRepository
        <span class="cov5" title="2">fmt.Println("\n2. FluxHelm Generator (HelmRepository):")
        fmt.Println(strings.Repeat("-", 40))

        var helmWrapper stack.ApplicationWrapper
        if err := yaml.Unmarshal([]byte(fluxHelmYAML), &amp;helmWrapper); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to unmarshal FluxHelm: %v", err)
        }</span>

        <span class="cov5" title="2">fmt.Printf("Parsed: %s %s\n", helmWrapper.APIVersion, helmWrapper.Kind)
        fmt.Printf("Name: %s, Namespace: %s\n", helmWrapper.Metadata.Name, helmWrapper.Metadata.Namespace)

        helmApp := helmWrapper.ToApplication()
        helmObjects, err := helmApp.Config.Generate(helmApp)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to generate FluxHelm resources: %v", err)
        }</span>

        <span class="cov5" title="2">fmt.Printf("Generated %d resources:\n", len(helmObjects))
        for _, obj := range helmObjects </span><span class="cov10" title="4">{
                o := *obj
                fmt.Printf("  - %s: %s/%s\n", o.GetObjectKind().GroupVersionKind().Kind,
                        o.GetNamespace(), o.GetName())
        }</span>

        // Output first resource as YAML
        <span class="cov5" title="2">if len(helmObjects) &gt; 0 </span><span class="cov5" title="2">{
                fmt.Println("\nSample HelmRepository YAML:")
                fmt.Println(strings.Repeat("-", 40))
                yamlBytes, _ := yaml.Marshal(*helmObjects[0])
                fmt.Println(string(yamlBytes))
        }</span>

        // Demo 3: Parse and generate FluxHelm with OCIRepository
        <span class="cov5" title="2">fmt.Println("\n3. FluxHelm Generator (OCIRepository):")
        fmt.Println(strings.Repeat("-", 40))

        var ociWrapper stack.ApplicationWrapper
        if err := yaml.Unmarshal([]byte(fluxHelmOCIYAML), &amp;ociWrapper); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to unmarshal FluxHelm OCI: %v", err)
        }</span>

        <span class="cov5" title="2">fmt.Printf("Parsed: %s %s\n", ociWrapper.APIVersion, ociWrapper.Kind)
        fmt.Printf("Name: %s, Namespace: %s\n", ociWrapper.Metadata.Name, ociWrapper.Metadata.Namespace)

        ociApp := ociWrapper.ToApplication()
        ociObjects, err := ociApp.Config.Generate(ociApp)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to generate FluxHelm OCI resources: %v", err)
        }</span>

        <span class="cov5" title="2">fmt.Printf("Generated %d resources:\n", len(ociObjects))
        for _, obj := range ociObjects </span><span class="cov10" title="4">{
                o := *obj
                fmt.Printf("  - %s: %s/%s\n", o.GetObjectKind().GroupVersionKind().Kind,
                        o.GetNamespace(), o.GetName())
        }</span>

        // Demo 4: Show multiple applications in a bundle
        <span class="cov5" title="2">fmt.Println("\n4. Bundle with Multiple Generator Types:")
        fmt.Println(strings.Repeat("-", 40))

        bundle, err := stack.NewBundle("mixed-apps", []*stack.Application{
                appWrapper.ToApplication(),
                helmWrapper.ToApplication(),
                ociWrapper.ToApplication(),
        }, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create bundle: %v", err)
        }</span>

        <span class="cov5" title="2">bundleObjects, err := bundle.Generate()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to generate bundle resources: %v", err)
        }</span>

        <span class="cov5" title="2">fmt.Printf("Bundle generated %d total resources from %d applications\n",
                len(bundleObjects), len(bundle.Applications))

        // Demo 5: List all registered generator types
        fmt.Println("\n5. Registered Generator Types:")
        fmt.Println(strings.Repeat("-", 40))

        registeredTypes := generators.ListKinds()
        for _, gvk := range registeredTypes </span><span class="cov10" title="4">{
                fmt.Printf("  - %s\n", gvk)
        }</span>
}

// RunGVKDemo can be called from main.go to run this demo
func RunGVKDemo() <span class="cov1" title="1">{
        DemoGVKGenerators()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"

        apiv1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/cli-runtime/pkg/printers"

        "github.com/go-kure/kure/internal/kubernetes"
        kio "github.com/go-kure/kure/pkg/io"
        "github.com/go-kure/kure/pkg/patch"
        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/layout"

        // Import implementations to register workflow factories
        _ "github.com/go-kure/kure/pkg/stack/argocd"
        _ "github.com/go-kure/kure/pkg/stack/fluxcd"

        // Import generators to register them
        _ "github.com/go-kure/kure/pkg/stack/generators/appworkload"
        _ "github.com/go-kure/kure/pkg/stack/generators/fluxhelm"
)

func ptr[T any](v T) *T <span class="cov1" title="1">{ return &amp;v }</span>

func logError(msg string, err error) <span class="cov10" title="14">{
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("%s: %v", msg, err)
        }</span>
}

func main() <span class="cov1" title="1">{
        fmt.Println("=== Kure Demo Suite ===")
        fmt.Println("Running all demos from examples/ configurations")
        fmt.Println()

        // Run all demos
        demos := []struct {
                name string
                fn   func() error
        }{
                {"Internal API Examples", runInternals},
                {"App Workloads", runAppWorkloads},
                {"Clusters", runClusters},
                {"Multi-OCI Packages", runMultiOCIDemo},
                {"Bootstrap Configurations", runBootstrapDemo},
                {"Patch System", runPatchDemo},
        }

        for _, demo := range demos </span><span class="cov7" title="6">{
                fmt.Printf("=== %s ===\n", demo.name)
                if err := demo.fn(); err != nil </span><span class="cov6" title="5">{
                        log.Printf("Demo '%s' failed: %v", demo.name, err)
                }</span>
                <span class="cov7" title="6">fmt.Println()</span>
        }

        <span class="cov1" title="1">fmt.Println("=== All Demos Complete ===")</span>
}

// runInternals demonstrates internal API usage (no external config needed)
func runInternals() error <span class="cov3" title="2">{
        fmt.Println("Demonstrating internal Kubernetes API builders...")

        y := printers.YAMLPrinter{}

        // Create a few example resources to demonstrate the internal APIs
        ns := kubernetes.CreateNamespace("demo")
        kubernetes.AddNamespaceLabel(ns, "env", "demo")

        sa := kubernetes.CreateServiceAccount("demo-sa", "demo")
        logError("add serviceaccount secret", kubernetes.AddServiceAccountSecret(sa, apiv1.ObjectReference{Name: "sa-secret"}))

        secret := kubernetes.CreateSecret("demo-secret", "demo")
        logError("add secret data", kubernetes.AddSecretData(secret, "cert", []byte("data")))

        cm := kubernetes.CreateConfigMap("demo-config", "demo")
        logError("add configmap data", kubernetes.AddConfigMapData(cm, "foo", "bar"))

        // Print a few examples
        objects := []runtime.Object{ns, sa, secret, cm}
        for _, obj := range objects </span><span class="cov8" title="8">{
                logError("failed to print YAML", y.PrintObj(obj, os.Stdout))
        }</span>

        <span class="cov3" title="2">fmt.Printf("Generated %d internal API examples\n", len(objects))
        return nil</span>
}

// runAppWorkloads processes all app-workload configs from examples/app-workloads/
func runAppWorkloads() error <span class="cov4" title="3">{
        exampleDir := "examples/app-workloads"
        outputDir := "out/app-workloads"

        if err := os.RemoveAll(outputDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">return filepath.Walk(exampleDir, func(path string, info os.FileInfo, err error) error </span><span class="cov5" title="4">{
                if err != nil || info.IsDir() || !strings.HasSuffix(path, ".yaml") </span><span class="cov4" title="3">{
                        return err
                }</span>

                <span class="cov1" title="1">fmt.Printf("Processing app workload: %s\n", path)

                file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">defer file.Close()

                dec := yaml.NewDecoder(file)
                var apps []*stack.Application

                for </span><span class="cov3" title="2">{
                        var wrapper stack.ApplicationWrapper
                        if err := dec.Decode(&amp;wrapper); err != nil </span><span class="cov1" title="1">{
                                if err == io.EOF </span><span class="cov1" title="1">{
                                        break</span>
                                }
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov1" title="1">app := wrapper.ToApplication()
                        apps = append(apps, app)</span>
                }

                <span class="cov1" title="1">if len(apps) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov1" title="1">bundle, err := stack.NewBundle("example", apps, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">resources, err := bundle.Generate()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Create output file
                <span class="cov1" title="1">relPath, _ := filepath.Rel(exampleDir, path)
                outputPath := filepath.Join(outputDir, strings.TrimSuffix(relPath, ".yaml")+"-generated.yaml")

                if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">outFile, err := os.Create(outputPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">defer outFile.Close()

                out, err := kio.EncodeObjectsToYAML(resources)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if _, err = outFile.Write(out); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">fmt.Printf("Generated app workload manifests: %s\n", outputPath)
                return nil</span>
        })
}

// runClusters processes all cluster configs from examples/clusters/
func runClusters() error <span class="cov3" title="2">{
        clustersDir := "examples/clusters"

        return filepath.Walk(clustersDir, func(path string, info os.FileInfo, err error) error </span><span class="cov3" title="2">{
                if err != nil || info.IsDir() || !strings.HasSuffix(path, "cluster.yaml") </span><span class="cov3" title="2">{
                        return err
                }</span>

                <span class="cov0" title="0">fmt.Printf("Processing cluster: %s\n", path)
                return runClusterExample(path)</span>
        })
}

// runClusterExample processes a single cluster configuration
func runClusterExample(clusterFile string) error <span class="cov3" title="2">{
        file, err := os.Open(clusterFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">defer file.Close()

        dec := yaml.NewDecoder(file)
        var cl stack.Cluster
        if err := dec.Decode(&amp;cl); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">if cl.Node == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Create bundles and load app configs
        <span class="cov0" title="0">rootBundle, err := stack.NewBundle(cl.Node.Name, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cl.Node.Bundle = rootBundle

        // Determine base directory for loading app configs
        baseDir := filepath.Dir(clusterFile)
        for _, child := range cl.Node.Children </span><span class="cov0" title="0">{
                child.SetParent(cl.Node)
                childBundle, err := stack.NewBundle(child.Name, nil, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">child.Bundle = childBundle
                childBundle.SetParent(rootBundle)

                // Load app configs from child directory
                if err := loadNodeApps(child, baseDir); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Configure output
        <span class="cov0" title="0">repoDir := filepath.Join("out", cl.Name+"-repo")
        if err := os.RemoveAll(repoDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate layout
        <span class="cov0" title="0">cfg := layout.Config{ManifestsDir: "clusters"}
        rules := layout.DefaultLayoutRules()
        rules.ClusterName = cl.Name
        rules.FluxPlacement = layout.FluxIntegrated

        wf, err := stack.NewWorkflow("flux")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result, err := wf.CreateLayoutWithResources(&amp;cl, rules)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ml, ok := result.(*layout.ManifestLayout)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected result type from CreateLayoutWithResources")
        }</span>

        // Write manifests
        <span class="cov0" title="0">if err := layout.WriteManifest(repoDir, cfg, ml); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("Generated cluster manifests: %s\n", repoDir)

        // Show bootstrap info if configured
        if cl.GitOps != nil &amp;&amp; cl.GitOps.Bootstrap != nil &amp;&amp; cl.GitOps.Bootstrap.Enabled </span><span class="cov0" title="0">{
                fmt.Printf("Bootstrap enabled: %s mode\n", cl.GitOps.Bootstrap.FluxMode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// loadNodeApps loads application configs for a node from the filesystem
func loadNodeApps(node *stack.Node, baseDir string) error <span class="cov3" title="2">{
        dir := filepath.Join(baseDir, node.Name)
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">for _, entry := range entries </span><span class="cov1" title="1">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">ext := filepath.Ext(entry.Name())
                if ext != ".yaml" &amp;&amp; ext != ".yml" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">fp := filepath.Join(dir, entry.Name())
                f, err := os.Open(fp)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">dec := yaml.NewDecoder(f)
                for </span><span class="cov3" title="2">{
                        var wrapper stack.ApplicationWrapper
                        if err := dec.Decode(&amp;wrapper); err != nil </span><span class="cov1" title="1">{
                                if err == io.EOF </span><span class="cov1" title="1">{
                                        break</span>
                                }
                                <span class="cov0" title="0">f.Close()
                                return err</span>
                        }

                        <span class="cov1" title="1">app := wrapper.ToApplication()
                        bundle, err := stack.NewBundle(wrapper.Metadata.Name, []*stack.Application{app}, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                f.Close()
                                return err
                        }</span>
                        <span class="cov1" title="1">bundle.SetParent(node.Bundle)
                        childNode := &amp;stack.Node{Name: wrapper.Metadata.Name, Bundle: bundle}
                        childNode.SetParent(node)
                        node.Children = append(node.Children, childNode)</span>
                }
                <span class="cov1" title="1">f.Close()</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// runMultiOCIDemo processes multi-OCI configurations from examples/multi-oci/
func runMultiOCIDemo() error <span class="cov3" title="2">{
        fmt.Println("Processing multi-OCI package configurations...")

        clusterFile := "examples/multi-oci/cluster.yaml"
        file, err := os.Open(clusterFile)
        if err != nil </span><span class="cov3" title="2">{
                return fmt.Errorf("open multi-oci cluster config: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        dec := yaml.NewDecoder(file)
        var cl stack.Cluster
        if err := dec.Decode(&amp;cl); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load node applications from multi-oci subdirectories
        <span class="cov0" title="0">baseDir := "examples/multi-oci"
        rootBundle, err := stack.NewBundle(cl.Node.Name, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cl.Node.Bundle = rootBundle

        for _, child := range cl.Node.Children </span><span class="cov0" title="0">{
                child.SetParent(cl.Node)

                // Parse packageRef from cluster.yaml
                if child.PackageRef == nil &amp;&amp; len(cl.Node.Children) &gt; 0 </span>{<span class="cov0" title="0">
                        // This would be set from the YAML parsing, but let me check the structure
                }</span>

                <span class="cov0" title="0">if err := loadNodeApps(child, baseDir); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: could not load apps for node %s: %v", child.Name, err)
                }</span>
        }

        // Generate standard layout (by node instead of by package type)
        <span class="cov0" title="0">rules := layout.DefaultLayoutRules()
        ml, err := layout.WalkCluster(&amp;cl, rules)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">baseOutputDir := "out/multi-oci-demo"
        if err := os.RemoveAll(baseOutputDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write manifests using standard layout
        <span class="cov0" title="0">cfg := layout.Config{ManifestsDir: ""}
        if err := layout.WriteManifest(baseOutputDir, cfg, ml); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("Generated multi-OCI packages: %s\n", baseOutputDir)
        fmt.Printf("Found %d nodes\n", len(cl.Node.Children))

        return nil</span>
}

// runBootstrapDemo processes bootstrap configurations from examples/bootstrap/
func runBootstrapDemo() error <span class="cov4" title="3">{
        bootstrapDir := "examples/bootstrap"

        return filepath.Walk(bootstrapDir, func(path string, info os.FileInfo, err error) error </span><span class="cov5" title="4">{
                if err != nil || info.IsDir() || !strings.HasSuffix(path, ".yaml") </span><span class="cov4" title="3">{
                        return err
                }</span>

                <span class="cov1" title="1">fmt.Printf("Processing bootstrap config: %s\n", path)

                file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">defer file.Close()

                dec := yaml.NewDecoder(file)
                var cl stack.Cluster
                if err := dec.Decode(&amp;cl); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Ensure basic structure
                <span class="cov1" title="1">if cl.Node == nil </span><span class="cov0" title="0">{
                        cl.Node = &amp;stack.Node{Name: "flux-system"}
                }</span>
                <span class="cov1" title="1">if cl.Node.Bundle == nil </span><span class="cov1" title="1">{
                        cl.Node.Bundle = &amp;stack.Bundle{Name: "infrastructure"}
                }</span>

                // Generate bootstrap manifests using correct workflow
                <span class="cov1" title="1">rules := layout.DefaultLayoutRules()
                rules.FluxPlacement = layout.FluxSeparate

                var ml *layout.ManifestLayout

                // Determine GitOps provider
                provider := "flux" // default
                if cl.GitOps != nil &amp;&amp; cl.GitOps.Type != "" </span><span class="cov0" title="0">{
                        provider = cl.GitOps.Type
                }</span>

                // Create workflow using interface
                <span class="cov1" title="1">wf, err := stack.NewWorkflow(provider)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if cl.GitOps != nil &amp;&amp; cl.GitOps.Type == "argocd" </span><span class="cov0" title="0">{
                        // For ArgoCD, generate bootstrap resources directly
                        bootstrapObjs, err := wf.GenerateBootstrap(cl.GitOps.Bootstrap, cl.Node)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Create a basic manifest layout for ArgoCD
                        <span class="cov0" title="0">ml = &amp;layout.ManifestLayout{
                                Name:      cl.Node.Name,
                                Namespace: cl.Name,
                                Resources: bootstrapObjs,
                        }</span>
                } else<span class="cov1" title="1"> {
                        // Default to Flux workflow
                        result, err := wf.CreateLayoutWithResources(&amp;cl, rules)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov1" title="1">var ok bool
                        ml, ok = result.(*layout.ManifestLayout)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected result type from CreateLayoutWithResources")
                        }</span>
                }
                <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Output to separate directory per config
                <span class="cov1" title="1">baseName := strings.TrimSuffix(filepath.Base(path), ".yaml")
                outputDir := filepath.Join("out", "bootstrap", baseName)
                if err := os.RemoveAll(outputDir); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">cfg := layout.Config{ManifestsDir: ""}
                if err := layout.WriteManifest(outputDir, cfg, ml); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">fmt.Printf("Generated bootstrap manifests: %s\n", outputDir)
                return nil</span>
        })
}

// runPatchDemo processes patch configurations from examples/patches/
func runPatchDemo() error <span class="cov3" title="2">{
        fmt.Println("Processing patch system examples...")

        examplesDir := "examples/patches"
        baseYAML := filepath.Join(examplesDir, "cert-manager-simple.yaml")
        patchFiles := []string{
                filepath.Join(examplesDir, "resources.kpatch"),
                filepath.Join(examplesDir, "ingress.kpatch"),
                filepath.Join(examplesDir, "security.kpatch"),
                filepath.Join(examplesDir, "advanced.kpatch"),
        }

        // Check if files exist
        if _, err := os.Stat(baseYAML); os.IsNotExist(err) </span><span class="cov3" title="2">{
                return fmt.Errorf("base YAML file not found: %s", baseYAML)
        }</span>

        // Load base resources
        <span class="cov0" title="0">baseFile, err := os.Open(baseYAML)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open base YAML: %w", err)
        }</span>
        <span class="cov0" title="0">defer baseFile.Close()

        documentSet, err := patch.LoadResourcesWithStructure(baseFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load resources with structure: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Loaded %d base resources with preserved structure\n", len(documentSet.Documents))

        // Create patchable set
        patchableSet := &amp;patch.PatchableAppSet{
                Resources:   documentSet.GetResources(),
                DocumentSet: documentSet,
                Patches: make([]struct {
                        Target string
                        Patch  patch.PatchOp
                }, 0),
        }

        outputDir := "out/patches"
        if err := patchableSet.WritePatchedFiles(baseYAML, patchFiles, outputDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write patched files: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Generated patched files: %s\n", outputDir)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "github.com/go-kure/kure/pkg/cmd/kure"
)

func main() <span class="cov0" title="0">{
        kure.Execute()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "github.com/go-kure/kure/pkg/cmd/kurel"
)

func main() <span class="cov0" title="0">{
        kurel.Execute()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"

        "github.com/go-kure/kure/pkg/kubernetes"
)

func main() <span class="cov0" title="0">{
        for _, obj := range kubernetes.Scheme.AllKnownTypes() </span><span class="cov0" title="0">{
                fmt.Println(obj)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package certmanager

import (
        corev1 "k8s.io/api/core/v1"

        cmacme "github.com/cert-manager/cert-manager/pkg/apis/acme/v1"
        cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
)

// CreateACMEIssuer returns an ACMEIssuer with the mandatory fields set.
func CreateACMEIssuer(server, email string, key cmmeta.SecretKeySelector) *cmacme.ACMEIssuer <span class="cov1" title="1">{
        return &amp;cmacme.ACMEIssuer{
                Email:                       email,
                Server:                      server,
                PrivateKey:                  key,
                Solvers:                     []cmacme.ACMEChallengeSolver{},
                SkipTLSVerify:               false,
                DisableAccountKeyGeneration: false,
        }
}</span>

// AddACMEIssuerSolver appends a challenge solver to the issuer.
func AddACMEIssuerSolver(issuer *cmacme.ACMEIssuer, solver cmacme.ACMEChallengeSolver) <span class="cov10" title="3">{
        issuer.Solvers = append(issuer.Solvers, solver)
}</span>

// CreateACMEHTTP01Solver creates a solver using HTTP01 via ingress class.
func CreateACMEHTTP01Solver(serviceType corev1.ServiceType, class string) cmacme.ACMEChallengeSolver <span class="cov1" title="1">{
        solver := cmacme.ACMEChallengeSolver{
                HTTP01: &amp;cmacme.ACMEChallengeSolverHTTP01{
                        Ingress: &amp;cmacme.ACMEChallengeSolverHTTP01Ingress{
                                ServiceType: serviceType,
                        },
                },
        }
        if class != "" </span><span class="cov1" title="1">{
                solver.HTTP01.Ingress.IngressClassName = &amp;class
        }</span>
        <span class="cov1" title="1">return solver</span>
}

// CreateACMEDNS01SolverCloudflare creates a DNS01 solver for Cloudflare.
func CreateACMEDNS01SolverCloudflare(email string, token cmmeta.SecretKeySelector) cmacme.ACMEChallengeSolver <span class="cov1" title="1">{
        provider := &amp;cmacme.ACMEChallengeSolverDNS01{
                Cloudflare: &amp;cmacme.ACMEIssuerDNS01ProviderCloudflare{
                        Email:    email,
                        APIToken: &amp;token,
                },
        }
        return cmacme.ACMEChallengeSolver{DNS01: provider}
}</span>

// CreateACMEDNS01SolverRoute53 creates a DNS01 solver for AWS Route53.
func CreateACMEDNS01SolverRoute53(region string, key cmmeta.SecretKeySelector) cmacme.ACMEChallengeSolver <span class="cov1" title="1">{
        provider := &amp;cmacme.ACMEChallengeSolverDNS01{
                Route53: &amp;cmacme.ACMEIssuerDNS01ProviderRoute53{
                        Region:          region,
                        SecretAccessKey: key,
                },
        }
        return cmacme.ACMEChallengeSolver{DNS01: provider}
}</span>

// CreateACMEDNS01SolverGoogle creates a DNS01 solver for Google CloudDNS.
func CreateACMEDNS01SolverGoogle(project string, sa *cmmeta.SecretKeySelector) cmacme.ACMEChallengeSolver <span class="cov1" title="1">{
        provider := &amp;cmacme.ACMEChallengeSolverDNS01{
                CloudDNS: &amp;cmacme.ACMEIssuerDNS01ProviderCloudDNS{
                        Project:        project,
                        ServiceAccount: sa,
                },
        }
        return cmacme.ACMEChallengeSolver{DNS01: provider}
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package certmanager

import (
        certv1 "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
        cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateCertificate returns a new Certificate object with the provided name, namespace and spec.
func CreateCertificate(name, namespace string, spec certv1.CertificateSpec) *certv1.Certificate <span class="cov8" title="1">{
        obj := &amp;certv1.Certificate{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Certificate",
                        APIVersion: certv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddCertificateLabel adds or updates a label on the Certificate metadata.
func AddCertificateLabel(obj *certv1.Certificate, key, value string) <span class="cov8" title="1">{
        if obj.Labels == nil </span><span class="cov8" title="1">{
                obj.Labels = make(map[string]string)
        }</span>
        <span class="cov8" title="1">obj.Labels[key] = value</span>
}

// AddCertificateAnnotation adds or updates an annotation on the Certificate metadata.
func AddCertificateAnnotation(obj *certv1.Certificate, key, value string) <span class="cov8" title="1">{
        if obj.Annotations == nil </span><span class="cov8" title="1">{
                obj.Annotations = make(map[string]string)
        }</span>
        <span class="cov8" title="1">obj.Annotations[key] = value</span>
}

// AddCertificateDNSName appends a DNS name to the Certificate spec.
func AddCertificateDNSName(obj *certv1.Certificate, dns string) <span class="cov8" title="1">{
        obj.Spec.DNSNames = append(obj.Spec.DNSNames, dns)
}</span>

// SetCertificateIssuerRef sets the issuer reference for the certificate.
func SetCertificateIssuerRef(obj *certv1.Certificate, ref cmmeta.ObjectReference) <span class="cov8" title="1">{
        obj.Spec.IssuerRef = ref
}</span>

// SetCertificateDuration sets the desired certificate duration.
func SetCertificateDuration(obj *certv1.Certificate, dur *metav1.Duration) <span class="cov8" title="1">{
        obj.Spec.Duration = dur
}</span>

// SetCertificateRenewBefore sets the renewBefore field of the certificate spec.
func SetCertificateRenewBefore(obj *certv1.Certificate, dur *metav1.Duration) <span class="cov8" title="1">{
        obj.Spec.RenewBefore = dur
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package certmanager

import (
        cmacme "github.com/cert-manager/cert-manager/pkg/apis/acme/v1"
        certv1 "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateClusterIssuer returns a new ClusterIssuer with the provided name and spec.
func CreateClusterIssuer(name string, spec certv1.IssuerSpec) *certv1.ClusterIssuer <span class="cov8" title="1">{
        obj := &amp;certv1.ClusterIssuer{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ClusterIssuer",
                        APIVersion: certv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddClusterIssuerLabel adds or updates a label on the ClusterIssuer metadata.
func AddClusterIssuerLabel(obj *certv1.ClusterIssuer, key, value string) <span class="cov8" title="1">{
        if obj.Labels == nil </span><span class="cov8" title="1">{
                obj.Labels = make(map[string]string)
        }</span>
        <span class="cov8" title="1">obj.Labels[key] = value</span>
}

// AddClusterIssuerAnnotation adds or updates an annotation on the ClusterIssuer metadata.
func AddClusterIssuerAnnotation(obj *certv1.ClusterIssuer, key, value string) <span class="cov8" title="1">{
        if obj.Annotations == nil </span><span class="cov8" title="1">{
                obj.Annotations = make(map[string]string)
        }</span>
        <span class="cov8" title="1">obj.Annotations[key] = value</span>
}

// SetClusterIssuerACME sets the ACME config on the ClusterIssuer.
func SetClusterIssuerACME(obj *certv1.ClusterIssuer, acme *cmacme.ACMEIssuer) <span class="cov8" title="1">{
        obj.Spec.IssuerConfig.ACME = acme
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package certmanager

import (
        cmacme "github.com/cert-manager/cert-manager/pkg/apis/acme/v1"
        certv1 "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateIssuer returns a new Issuer object with the provided name, namespace and spec.
func CreateIssuer(name, namespace string, spec certv1.IssuerSpec) *certv1.Issuer <span class="cov8" title="1">{
        obj := &amp;certv1.Issuer{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Issuer",
                        APIVersion: certv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddIssuerLabel adds or updates a label on the Issuer metadata.
func AddIssuerLabel(obj *certv1.Issuer, key, value string) <span class="cov8" title="1">{
        if obj.Labels == nil </span><span class="cov8" title="1">{
                obj.Labels = make(map[string]string)
        }</span>
        <span class="cov8" title="1">obj.Labels[key] = value</span>
}

// AddIssuerAnnotation adds or updates an annotation on the Issuer metadata.
func AddIssuerAnnotation(obj *certv1.Issuer, key, value string) <span class="cov8" title="1">{
        if obj.Annotations == nil </span><span class="cov8" title="1">{
                obj.Annotations = make(map[string]string)
        }</span>
        <span class="cov8" title="1">obj.Annotations[key] = value</span>
}

// SetIssuerACME sets the ACME configuration on the issuer spec.
func SetIssuerACME(obj *certv1.Issuer, acme *cmacme.ACMEIssuer) <span class="cov8" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">obj.Spec.IssuerConfig.ACME = acme</span>
}

// SetIssuerCA sets the CA configuration on the issuer spec.
func SetIssuerCA(obj *certv1.Issuer, ca *certv1.CAIssuer) <span class="cov8" title="1">{
        obj.Spec.IssuerConfig.CA = ca
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package externalsecrets

import (
        esv1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateClusterSecretStore returns a ClusterSecretStore object with the given name and spec.
func CreateClusterSecretStore(name string, spec esv1.SecretStoreSpec) *esv1.ClusterSecretStore <span class="cov10" title="2">{
        obj := &amp;esv1.ClusterSecretStore{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ClusterSecretStore",
                        APIVersion: esv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddClusterSecretStoreLabel adds or updates a label on the ClusterSecretStore.
func AddClusterSecretStoreLabel(obj *esv1.ClusterSecretStore, key, value string) <span class="cov1" title="1">{
        if obj.Labels == nil </span><span class="cov1" title="1">{
                obj.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">obj.Labels[key] = value</span>
}

// AddClusterSecretStoreAnnotation adds or updates an annotation on the ClusterSecretStore.
func AddClusterSecretStoreAnnotation(obj *esv1.ClusterSecretStore, key, value string) <span class="cov1" title="1">{
        if obj.Annotations == nil </span><span class="cov1" title="1">{
                obj.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">obj.Annotations[key] = value</span>
}

// SetClusterSecretStoreProvider sets the provider field on the ClusterSecretStore spec.
func SetClusterSecretStoreProvider(obj *esv1.ClusterSecretStore, provider *esv1.SecretStoreProvider) <span class="cov1" title="1">{
        obj.Spec.Provider = provider
}</span>

// SetClusterSecretStoreController sets the controller name on the ClusterSecretStore spec.
func SetClusterSecretStoreController(obj *esv1.ClusterSecretStore, controller string) <span class="cov1" title="1">{
        obj.Spec.Controller = controller
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package externalsecrets

import (
        esv1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateExternalSecret returns a new ExternalSecret object with the provided name, namespace and spec.
func CreateExternalSecret(name, namespace string, spec esv1.ExternalSecretSpec) *esv1.ExternalSecret <span class="cov10" title="2">{
        obj := &amp;esv1.ExternalSecret{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ExternalSecret",
                        APIVersion: esv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddExternalSecretLabel adds or updates a label on the ExternalSecret.
func AddExternalSecretLabel(obj *esv1.ExternalSecret, key, value string) <span class="cov1" title="1">{
        if obj.Labels == nil </span><span class="cov1" title="1">{
                obj.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">obj.Labels[key] = value</span>
}

// AddExternalSecretAnnotation adds or updates an annotation on the ExternalSecret.
func AddExternalSecretAnnotation(obj *esv1.ExternalSecret, key, value string) <span class="cov1" title="1">{
        if obj.Annotations == nil </span><span class="cov1" title="1">{
                obj.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">obj.Annotations[key] = value</span>
}

// AddExternalSecretData appends a data entry to the ExternalSecret spec.
func AddExternalSecretData(obj *esv1.ExternalSecret, data esv1.ExternalSecretData) <span class="cov1" title="1">{
        obj.Spec.Data = append(obj.Spec.Data, data)
}</span>

// SetExternalSecretSecretStoreRef sets the secret store reference on the ExternalSecret spec.
func SetExternalSecretSecretStoreRef(obj *esv1.ExternalSecret, ref esv1.SecretStoreRef) <span class="cov1" title="1">{
        obj.Spec.SecretStoreRef = ref
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package externalsecrets

import (
        esv1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateSecretStore returns a SecretStore object with the given name, namespace and spec.
func CreateSecretStore(name, namespace string, spec esv1.SecretStoreSpec) *esv1.SecretStore <span class="cov10" title="2">{
        obj := &amp;esv1.SecretStore{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "SecretStore",
                        APIVersion: esv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddSecretStoreLabel adds or updates a label on the SecretStore.
func AddSecretStoreLabel(obj *esv1.SecretStore, key, value string) <span class="cov1" title="1">{
        if obj.Labels == nil </span><span class="cov1" title="1">{
                obj.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">obj.Labels[key] = value</span>
}

// AddSecretStoreAnnotation adds or updates an annotation on the SecretStore.
func AddSecretStoreAnnotation(obj *esv1.SecretStore, key, value string) <span class="cov1" title="1">{
        if obj.Annotations == nil </span><span class="cov1" title="1">{
                obj.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">obj.Annotations[key] = value</span>
}

// SetSecretStoreProvider sets the provider field on the SecretStore spec.
func SetSecretStoreProvider(obj *esv1.SecretStore, provider *esv1.SecretStoreProvider) <span class="cov1" title="1">{
        obj.Spec.Provider = provider
}</span>

// SetSecretStoreController sets the controller name on the SecretStore spec.
func SetSecretStoreController(obj *esv1.SecretStore, controller string) <span class="cov1" title="1">{
        obj.Spec.Controller = controller
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package fluxcd

import (
        "github.com/go-kure/kure/internal/validation"

        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateFluxInstance returns a new FluxInstance object.
func CreateFluxInstance(name, namespace string, spec fluxv1.FluxInstanceSpec) *fluxv1.FluxInstance <span class="cov10" title="2">{
        obj := &amp;fluxv1.FluxInstance{
                TypeMeta: metav1.TypeMeta{
                        Kind:       fluxv1.FluxInstanceKind,
                        APIVersion: fluxv1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddFluxInstanceComponent appends a component to the FluxInstance spec.
func AddFluxInstanceComponent(obj *fluxv1.FluxInstance, c fluxv1.Component) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">obj.Spec.Components = append(obj.Spec.Components, c)
        return nil</span>
}

// SetFluxInstanceDistribution sets the distribution of the FluxInstance.
func SetFluxInstanceDistribution(obj *fluxv1.FluxInstance, dist fluxv1.Distribution) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">obj.Spec.Distribution = dist
        return nil</span>
}

// SetFluxInstanceCommonMetadata sets the common metadata.
func SetFluxInstanceCommonMetadata(obj *fluxv1.FluxInstance, cm *fluxv1.CommonMetadata) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">obj.Spec.CommonMetadata = cm
        return nil</span>
}

// SetFluxInstanceCluster sets the cluster information.
func SetFluxInstanceCluster(obj *fluxv1.FluxInstance, cluster *fluxv1.Cluster) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">obj.Spec.Cluster = cluster
        return nil</span>
}

// SetFluxInstanceSharding sets the sharding specification.
func SetFluxInstanceSharding(obj *fluxv1.FluxInstance, shard *fluxv1.Sharding) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">obj.Spec.Sharding = shard
        return nil</span>
}

// SetFluxInstanceStorage sets the storage specification.
func SetFluxInstanceStorage(obj *fluxv1.FluxInstance, st *fluxv1.Storage) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">obj.Spec.Storage = st
        return nil</span>
}

// SetFluxInstanceKustomize sets the kustomize specification.
func SetFluxInstanceKustomize(obj *fluxv1.FluxInstance, k *fluxv1.Kustomize) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">obj.Spec.Kustomize = k
        return nil</span>
}

// SetFluxInstanceWait sets the wait flag.
func SetFluxInstanceWait(obj *fluxv1.FluxInstance, wait bool) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">obj.Spec.Wait = &amp;wait
        return nil</span>
}

// SetFluxInstanceMigrateResources sets the migrateResources flag.
func SetFluxInstanceMigrateResources(obj *fluxv1.FluxInstance, m bool) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">obj.Spec.MigrateResources = &amp;m
        return nil</span>
}

// SetFluxInstanceSync sets the sync configuration.
func SetFluxInstanceSync(obj *fluxv1.FluxInstance, sync *fluxv1.Sync) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateFluxInstance(obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">obj.Spec.Sync = sync
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package fluxcd

import (
        "errors"

        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateFluxReport returns a new FluxReport object.
func CreateFluxReport(name, namespace string, spec fluxv1.FluxReportSpec) *fluxv1.FluxReport <span class="cov10" title="2">{
        obj := &amp;fluxv1.FluxReport{
                TypeMeta: metav1.TypeMeta{
                        Kind:       fluxv1.FluxReportKind,
                        APIVersion: fluxv1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// SetFluxReportDistribution sets the distribution status.
func SetFluxReportDistribution(fr *fluxv1.FluxReport, dist fluxv1.FluxDistributionStatus) error <span class="cov0" title="0">{
        if fr == nil </span><span class="cov0" title="0">{
                return errors.New("nil FluxReport")
        }</span>
        <span class="cov0" title="0">fr.Spec.Distribution = dist
        return nil</span>
}

// SetFluxReportCluster sets the cluster info.
func SetFluxReportCluster(fr *fluxv1.FluxReport, c *fluxv1.ClusterInfo) error <span class="cov0" title="0">{
        if fr == nil </span><span class="cov0" title="0">{
                return errors.New("nil FluxReport")
        }</span>
        <span class="cov0" title="0">fr.Spec.Cluster = c
        return nil</span>
}

// SetFluxReportOperator sets the operator info.
func SetFluxReportOperator(fr *fluxv1.FluxReport, op *fluxv1.OperatorInfo) error <span class="cov0" title="0">{
        if fr == nil </span><span class="cov0" title="0">{
                return errors.New("nil FluxReport")
        }</span>
        <span class="cov0" title="0">fr.Spec.Operator = op
        return nil</span>
}

// AddFluxReportComponentStatus appends a component status.
func AddFluxReportComponentStatus(fr *fluxv1.FluxReport, cs fluxv1.FluxComponentStatus) error <span class="cov1" title="1">{
        if fr == nil </span><span class="cov0" title="0">{
                return errors.New("nil FluxReport")
        }</span>
        <span class="cov1" title="1">fr.Spec.ComponentsStatus = append(fr.Spec.ComponentsStatus, cs)
        return nil</span>
}

// AddFluxReportReconcilerStatus appends a reconciler status.
func AddFluxReportReconcilerStatus(fr *fluxv1.FluxReport, rs fluxv1.FluxReconcilerStatus) error <span class="cov1" title="1">{
        if fr == nil </span><span class="cov0" title="0">{
                return errors.New("nil FluxReport")
        }</span>
        <span class="cov1" title="1">fr.Spec.ReconcilersStatus = append(fr.Spec.ReconcilersStatus, rs)
        return nil</span>
}

// SetFluxReportSyncStatus sets the sync status.
func SetFluxReportSyncStatus(fr *fluxv1.FluxReport, s *fluxv1.FluxSyncStatus) error <span class="cov0" title="0">{
        if fr == nil </span><span class="cov0" title="0">{
                return errors.New("nil FluxReport")
        }</span>
        <span class="cov0" title="0">fr.Spec.SyncStatus = s
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package fluxcd

import (
        helmv2 "github.com/fluxcd/helm-controller/api/v2"
        "github.com/fluxcd/pkg/apis/meta"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func CreateHelmRelease(name string, namespace string, spec helmv2.HelmReleaseSpec) *helmv2.HelmRelease <span class="cov10" title="3">{
        obj := &amp;helmv2.HelmRelease{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "HelmRelease",
                        APIVersion: helmv2.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddHelmReleaseLabel adds a label to the HelmRelease metadata.
func AddHelmReleaseLabel(obj *helmv2.HelmRelease, key, value string) <span class="cov1" title="1">{
        if obj.Labels == nil </span><span class="cov1" title="1">{
                obj.Labels = map[string]string{}
        }</span>
        <span class="cov1" title="1">obj.Labels[key] = value</span>
}

// AddHelmReleaseAnnotation adds an annotation to the HelmRelease metadata.
func AddHelmReleaseAnnotation(obj *helmv2.HelmRelease, key, value string) <span class="cov1" title="1">{
        if obj.Annotations == nil </span><span class="cov1" title="1">{
                obj.Annotations = map[string]string{}
        }</span>
        <span class="cov1" title="1">obj.Annotations[key] = value</span>
}

// SetHelmReleaseChart sets the inline HelmChartTemplate.
func SetHelmReleaseChart(obj *helmv2.HelmRelease, chart *helmv2.HelmChartTemplate) <span class="cov0" title="0">{
        obj.Spec.Chart = chart
}</span>

// SetHelmReleaseChartRef sets the cross namespace chart reference.
func SetHelmReleaseChartRef(obj *helmv2.HelmRelease, ref *helmv2.CrossNamespaceSourceReference) <span class="cov0" title="0">{
        obj.Spec.ChartRef = ref
}</span>

// SetHelmReleaseInterval sets the reconcile interval.
func SetHelmReleaseInterval(obj *helmv2.HelmRelease, interval metav1.Duration) <span class="cov1" title="1">{
        obj.Spec.Interval = interval
}</span>

// SetHelmReleaseKubeConfig sets the KubeConfig reference.
func SetHelmReleaseKubeConfig(obj *helmv2.HelmRelease, cfg *meta.KubeConfigReference) <span class="cov1" title="1">{
        obj.Spec.KubeConfig = cfg
}</span>

// SetHelmReleaseSuspend configures the suspend flag.
func SetHelmReleaseSuspend(obj *helmv2.HelmRelease, suspend bool) <span class="cov1" title="1">{
        obj.Spec.Suspend = suspend
}</span>

// SetHelmReleaseReleaseName sets the Helm release name.
func SetHelmReleaseReleaseName(obj *helmv2.HelmRelease, name string) <span class="cov1" title="1">{
        obj.Spec.ReleaseName = name
}</span>

// SetHelmReleaseTargetNamespace sets the target namespace of the release.
func SetHelmReleaseTargetNamespace(obj *helmv2.HelmRelease, ns string) <span class="cov1" title="1">{
        obj.Spec.TargetNamespace = ns
}</span>

// SetHelmReleaseStorageNamespace sets the storage namespace of the release.
func SetHelmReleaseStorageNamespace(obj *helmv2.HelmRelease, ns string) <span class="cov1" title="1">{
        obj.Spec.StorageNamespace = ns
}</span>

// AddHelmReleaseDependsOn appends a dependency to the HelmRelease.
func AddHelmReleaseDependsOn(obj *helmv2.HelmRelease, ref meta.NamespacedObjectReference) <span class="cov1" title="1">{
        obj.Spec.DependsOn = append(obj.Spec.DependsOn, ref)
}</span>

// SetHelmReleaseTimeout sets the timeout for the Helm actions.
func SetHelmReleaseTimeout(obj *helmv2.HelmRelease, timeout metav1.Duration) <span class="cov1" title="1">{
        obj.Spec.Timeout = &amp;timeout
}</span>

// SetHelmReleaseMaxHistory sets the maximum history to retain.
func SetHelmReleaseMaxHistory(obj *helmv2.HelmRelease, h int) <span class="cov1" title="1">{
        obj.Spec.MaxHistory = &amp;h
}</span>

// SetHelmReleaseServiceAccountName sets the service account name.
func SetHelmReleaseServiceAccountName(obj *helmv2.HelmRelease, name string) <span class="cov1" title="1">{
        obj.Spec.ServiceAccountName = name
}</span>

// SetHelmReleasePersistentClient sets the persistent client flag.
func SetHelmReleasePersistentClient(obj *helmv2.HelmRelease, b bool) <span class="cov1" title="1">{
        obj.Spec.PersistentClient = &amp;b
}</span>

// SetHelmReleaseDriftDetection sets the drift detection configuration.
func SetHelmReleaseDriftDetection(obj *helmv2.HelmRelease, dd *helmv2.DriftDetection) <span class="cov0" title="0">{
        obj.Spec.DriftDetection = dd
}</span>

// SetHelmReleaseInstall sets the install configuration.
func SetHelmReleaseInstall(obj *helmv2.HelmRelease, install *helmv2.Install) <span class="cov0" title="0">{
        obj.Spec.Install = install
}</span>

// SetHelmReleaseUpgrade sets the upgrade configuration.
func SetHelmReleaseUpgrade(obj *helmv2.HelmRelease, upgrade *helmv2.Upgrade) <span class="cov0" title="0">{
        obj.Spec.Upgrade = upgrade
}</span>

// SetHelmReleaseRollback sets the rollback configuration.
func SetHelmReleaseRollback(obj *helmv2.HelmRelease, rollback *helmv2.Rollback) <span class="cov0" title="0">{
        obj.Spec.Rollback = rollback
}</span>

// SetHelmReleaseUninstall sets the uninstall configuration.
func SetHelmReleaseUninstall(obj *helmv2.HelmRelease, uninstall *helmv2.Uninstall) <span class="cov0" title="0">{
        obj.Spec.Uninstall = uninstall
}</span>

// SetHelmReleaseTest sets the test configuration.
func SetHelmReleaseTest(obj *helmv2.HelmRelease, test *helmv2.Test) <span class="cov0" title="0">{
        obj.Spec.Test = test
}</span>

// AddHelmReleaseValuesFrom appends a valuesFrom reference.
func AddHelmReleaseValuesFrom(obj *helmv2.HelmRelease, ref helmv2.ValuesReference) <span class="cov1" title="1">{
        obj.Spec.ValuesFrom = append(obj.Spec.ValuesFrom, ref)
}</span>

// SetHelmReleaseValues sets the values for the release.
func SetHelmReleaseValues(obj *helmv2.HelmRelease, values *apiextensionsv1.JSON) <span class="cov1" title="1">{
        obj.Spec.Values = values
}</span>

// AddHelmReleasePostRenderer appends a post renderer.
func AddHelmReleasePostRenderer(obj *helmv2.HelmRelease, pr helmv2.PostRenderer) <span class="cov1" title="1">{
        obj.Spec.PostRenderers = append(obj.Spec.PostRenderers, pr)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package fluxcd

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        imagev1 "github.com/fluxcd/image-automation-controller/api/v1beta2"
        "github.com/fluxcd/pkg/apis/meta"
        sourcev1 "github.com/fluxcd/source-controller/api/v1"
)

// CreateImageUpdateAutomation returns a new ImageUpdateAutomation object.
func CreateImageUpdateAutomation(name, namespace string, spec imagev1.ImageUpdateAutomationSpec) *imagev1.ImageUpdateAutomation <span class="cov10" title="2">{
        obj := &amp;imagev1.ImageUpdateAutomation{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ImageUpdateAutomation",
                        APIVersion: imagev1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// SetImageUpdateAutomationSourceRef sets the source reference for the automation.
func SetImageUpdateAutomationSourceRef(auto *imagev1.ImageUpdateAutomation, ref imagev1.CrossNamespaceSourceReference) <span class="cov1" title="1">{
        auto.Spec.SourceRef = ref
}</span>

// SetImageUpdateAutomationGitSpec sets the git specification for the automation.
func SetImageUpdateAutomationGitSpec(auto *imagev1.ImageUpdateAutomation, spec *imagev1.GitSpec) <span class="cov0" title="0">{
        auto.Spec.GitSpec = spec
}</span>

// SetImageUpdateAutomationInterval sets the reconcile interval.
func SetImageUpdateAutomationInterval(auto *imagev1.ImageUpdateAutomation, interval metav1.Duration) <span class="cov1" title="1">{
        auto.Spec.Interval = interval
}</span>

// SetImageUpdateAutomationPolicySelector sets the policy selector.
func SetImageUpdateAutomationPolicySelector(auto *imagev1.ImageUpdateAutomation, selector *metav1.LabelSelector) <span class="cov1" title="1">{
        auto.Spec.PolicySelector = selector
}</span>

// SetImageUpdateAutomationUpdateStrategy sets the update strategy.
func SetImageUpdateAutomationUpdateStrategy(auto *imagev1.ImageUpdateAutomation, strategy *imagev1.UpdateStrategy) <span class="cov1" title="1">{
        auto.Spec.Update = strategy
}</span>

// SetImageUpdateAutomationSuspend sets the suspend flag.
func SetImageUpdateAutomationSuspend(auto *imagev1.ImageUpdateAutomation, suspend bool) <span class="cov1" title="1">{
        auto.Spec.Suspend = suspend
}</span>

// CreateCrossNamespaceSourceReference creates a new cross namespace source reference.
func CreateCrossNamespaceSourceReference(apiVersion, kind, name, namespace string) imagev1.CrossNamespaceSourceReference <span class="cov10" title="2">{
        return imagev1.CrossNamespaceSourceReference{
                APIVersion: apiVersion,
                Kind:       kind,
                Name:       name,
                Namespace:  namespace,
        }
}</span>

// CreateGitCheckoutSpec creates a new GitCheckoutSpec.
func CreateGitCheckoutSpec(ref sourcev1.GitRepositoryRef) *imagev1.GitCheckoutSpec <span class="cov1" title="1">{
        return &amp;imagev1.GitCheckoutSpec{Reference: ref}
}</span>

// SetGitCheckoutReference sets the reference of the checkout spec.
func SetGitCheckoutReference(spec *imagev1.GitCheckoutSpec, ref sourcev1.GitRepositoryRef) <span class="cov0" title="0">{
        spec.Reference = ref
}</span>

// CreateCommitUser returns a CommitUser struct.
func CreateCommitUser(name, email string) imagev1.CommitUser <span class="cov1" title="1">{
        return imagev1.CommitUser{Name: name, Email: email}
}</span>

// CreateSigningKey returns a SigningKey with the secret reference populated.
func CreateSigningKey(secretName string) *imagev1.SigningKey <span class="cov1" title="1">{
        return &amp;imagev1.SigningKey{SecretRef: meta.LocalObjectReference{Name: secretName}}
}</span>

// CreateCommitSpec creates a CommitSpec with the given author.
func CreateCommitSpec(author imagev1.CommitUser) imagev1.CommitSpec <span class="cov1" title="1">{
        return imagev1.CommitSpec{Author: author}
}</span>

// SetCommitSigningKey sets the signing key for a CommitSpec.
func SetCommitSigningKey(spec *imagev1.CommitSpec, key *imagev1.SigningKey) <span class="cov1" title="1">{
        spec.SigningKey = key
}</span>

// SetCommitMessageTemplate sets the message template for a CommitSpec.
func SetCommitMessageTemplate(spec *imagev1.CommitSpec, tpl string) <span class="cov0" title="0">{
        spec.MessageTemplate = tpl
}</span>

// SetCommitMessageTemplateValues replaces the message template values map.
func SetCommitMessageTemplateValues(spec *imagev1.CommitSpec, values map[string]string) <span class="cov0" title="0">{
        spec.MessageTemplateValues = values
}</span>

// AddCommitMessageTemplateValue adds a single key/value pair to the template values map.
func AddCommitMessageTemplateValue(spec *imagev1.CommitSpec, key, value string) <span class="cov1" title="1">{
        if spec.MessageTemplateValues == nil </span><span class="cov1" title="1">{
                spec.MessageTemplateValues = make(map[string]string)
        }</span>
        <span class="cov1" title="1">spec.MessageTemplateValues[key] = value</span>
}

// SetCommitAuthor sets the author of the commit spec.
func SetCommitAuthor(spec *imagev1.CommitSpec, author imagev1.CommitUser) <span class="cov0" title="0">{
        spec.Author = author
}</span>

// CreatePushSpec returns a PushSpec.
func CreatePushSpec(branch, refspec string, options map[string]string) *imagev1.PushSpec <span class="cov1" title="1">{
        return &amp;imagev1.PushSpec{Branch: branch, Refspec: refspec, Options: options}
}</span>

// SetPushBranch sets the branch for the push spec.
func SetPushBranch(spec *imagev1.PushSpec, branch string) <span class="cov0" title="0">{ spec.Branch = branch }</span>

// SetPushRefspec sets the refspec for the push spec.
func SetPushRefspec(spec *imagev1.PushSpec, refspec string) <span class="cov0" title="0">{ spec.Refspec = refspec }</span>

// SetPushOptions replaces the options map for the push spec.
func SetPushOptions(spec *imagev1.PushSpec, opts map[string]string) <span class="cov0" title="0">{ spec.Options = opts }</span>

// AddPushOption adds a single option to the push spec.
func AddPushOption(spec *imagev1.PushSpec, key, value string) <span class="cov1" title="1">{
        if spec.Options == nil </span><span class="cov1" title="1">{
                spec.Options = make(map[string]string)
        }</span>
        <span class="cov1" title="1">spec.Options[key] = value</span>
}

// CreateGitSpec creates a GitSpec struct.
func CreateGitSpec(commit imagev1.CommitSpec, checkout *imagev1.GitCheckoutSpec, push *imagev1.PushSpec) *imagev1.GitSpec <span class="cov1" title="1">{
        return &amp;imagev1.GitSpec{Checkout: checkout, Commit: commit, Push: push}
}</span>

// SetGitSpecCheckout sets the checkout spec.
func SetGitSpecCheckout(spec *imagev1.GitSpec, checkout *imagev1.GitCheckoutSpec) <span class="cov0" title="0">{
        spec.Checkout = checkout
}</span>

// SetGitSpecCommit sets the commit spec.
func SetGitSpecCommit(spec *imagev1.GitSpec, commit imagev1.CommitSpec) <span class="cov0" title="0">{ spec.Commit = commit }</span>

// SetGitSpecPush sets the push spec.
func SetGitSpecPush(spec *imagev1.GitSpec, push *imagev1.PushSpec) <span class="cov0" title="0">{ spec.Push = push }</span>

// CreateUpdateStrategy creates an UpdateStrategy struct.
func CreateUpdateStrategy(strategy imagev1.UpdateStrategyName, path string) *imagev1.UpdateStrategy <span class="cov10" title="2">{
        return &amp;imagev1.UpdateStrategy{Strategy: strategy, Path: path}
}</span>

// SetUpdateStrategyName sets the strategy name.
func SetUpdateStrategyName(spec *imagev1.UpdateStrategy, name imagev1.UpdateStrategyName) <span class="cov1" title="1">{
        spec.Strategy = name
}</span>

// SetUpdateStrategyPath sets the update path.
func SetUpdateStrategyPath(spec *imagev1.UpdateStrategy, path string) <span class="cov1" title="1">{ spec.Path = path }</span>

// CreateImageRef constructs an ImageRef.
func CreateImageRef(name, tag, digest string) imagev1.ImageRef <span class="cov1" title="1">{
        return imagev1.ImageRef{Name: name, Tag: tag, Digest: digest}
}</span>

// SetImageRefDigest sets the digest on an ImageRef.
func SetImageRefDigest(ref *imagev1.ImageRef, digest string) <span class="cov0" title="0">{ ref.Digest = digest }</span>

// SetImageRefTag sets the tag on an ImageRef.
func SetImageRefTag(ref *imagev1.ImageRef, tag string) <span class="cov0" title="0">{ ref.Tag = tag }</span>

// SetImageRefName sets the name on an ImageRef.
func SetImageRefName(ref *imagev1.ImageRef, name string) <span class="cov0" title="0">{ ref.Name = name }</span>

// AddObservedPolicy records an observed policy in the automation status.
func AddObservedPolicy(auto *imagev1.ImageUpdateAutomation, name string, ref imagev1.ImageRef) <span class="cov1" title="1">{
        if auto.Status.ObservedPolicies == nil </span><span class="cov1" title="1">{
                auto.Status.ObservedPolicies = make(imagev1.ObservedPolicies)
        }</span>
        <span class="cov1" title="1">auto.Status.ObservedPolicies[name] = ref</span>
}

// SetObservedPolicies sets the observed policies map.
func SetObservedPolicies(auto *imagev1.ImageUpdateAutomation, policies imagev1.ObservedPolicies) <span class="cov0" title="0">{
        auto.Status.ObservedPolicies = policies
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package fluxcd

import (
        kustv1 "github.com/fluxcd/kustomize-controller/api/v1"
        "github.com/fluxcd/pkg/apis/kustomize"
        metaapi "github.com/fluxcd/pkg/apis/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func CreateKustomization(name string, namespace string, spec kustv1.KustomizationSpec) *kustv1.Kustomization <span class="cov10" title="5">{
        obj := &amp;kustv1.Kustomization{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Kustomization",
                        APIVersion: kustv1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// SetKustomizationInterval updates the reconciliation interval.
func SetKustomizationInterval(k *kustv1.Kustomization, interval metav1.Duration) <span class="cov1" title="1">{
        k.Spec.Interval = interval
}</span>

// SetKustomizationRetryInterval sets the retry interval.
func SetKustomizationRetryInterval(k *kustv1.Kustomization, interval metav1.Duration) <span class="cov1" title="1">{
        k.Spec.RetryInterval = &amp;interval
}</span>

// SetKustomizationPath sets the path field.
func SetKustomizationPath(k *kustv1.Kustomization, path string) <span class="cov1" title="1">{
        k.Spec.Path = path
}</span>

// SetKustomizationKubeConfig specifies a kubeconfig reference.
func SetKustomizationKubeConfig(k *kustv1.Kustomization, ref *metaapi.KubeConfigReference) <span class="cov0" title="0">{
        k.Spec.KubeConfig = ref
}</span>

// SetKustomizationSourceRef sets the source reference.
func SetKustomizationSourceRef(k *kustv1.Kustomization, ref kustv1.CrossNamespaceSourceReference) <span class="cov0" title="0">{
        k.Spec.SourceRef = ref
}</span>

// SetKustomizationPrune sets the prune option.
func SetKustomizationPrune(k *kustv1.Kustomization, prune bool) <span class="cov1" title="1">{
        k.Spec.Prune = prune
}</span>

// SetKustomizationDeletionPolicy sets the deletion policy.
func SetKustomizationDeletionPolicy(k *kustv1.Kustomization, policy string) <span class="cov1" title="1">{
        k.Spec.DeletionPolicy = policy
}</span>

// AddKustomizationHealthCheck appends a health check reference.
func AddKustomizationHealthCheck(k *kustv1.Kustomization, ref metaapi.NamespacedObjectKindReference) <span class="cov1" title="1">{
        k.Spec.HealthChecks = append(k.Spec.HealthChecks, ref)
}</span>

// AddKustomizationComponent adds a component path.
func AddKustomizationComponent(k *kustv1.Kustomization, component string) <span class="cov1" title="1">{
        k.Spec.Components = append(k.Spec.Components, component)
}</span>

// AddKustomizationDependsOn appends a dependency reference.
func AddKustomizationDependsOn(k *kustv1.Kustomization, ref metaapi.NamespacedObjectReference) <span class="cov1" title="1">{
        k.Spec.DependsOn = append(k.Spec.DependsOn, ref)
}</span>

// SetKustomizationServiceAccountName sets the service account name.
func SetKustomizationServiceAccountName(k *kustv1.Kustomization, name string) <span class="cov0" title="0">{
        k.Spec.ServiceAccountName = name
}</span>

// SetKustomizationSuspend sets the suspend flag.
func SetKustomizationSuspend(k *kustv1.Kustomization, suspend bool) <span class="cov0" title="0">{
        k.Spec.Suspend = suspend
}</span>

// SetKustomizationTargetNamespace overrides the target namespace.
func SetKustomizationTargetNamespace(k *kustv1.Kustomization, namespace string) <span class="cov0" title="0">{
        k.Spec.TargetNamespace = namespace
}</span>

// SetKustomizationTimeout sets the timeout duration.
func SetKustomizationTimeout(k *kustv1.Kustomization, timeout metav1.Duration) <span class="cov0" title="0">{
        k.Spec.Timeout = &amp;timeout
}</span>

// SetKustomizationForce sets the force flag.
func SetKustomizationForce(k *kustv1.Kustomization, force bool) <span class="cov0" title="0">{
        k.Spec.Force = force
}</span>

// SetKustomizationWait sets the wait flag.
func SetKustomizationWait(k *kustv1.Kustomization, wait bool) <span class="cov0" title="0">{
        k.Spec.Wait = wait
}</span>

// AddKustomizationImage appends an image transformation.
func AddKustomizationImage(k *kustv1.Kustomization, img kustomize.Image) <span class="cov1" title="1">{
        k.Spec.Images = append(k.Spec.Images, img)
}</span>

// AddKustomizationPatch appends a strategic merge or JSON patch.
func AddKustomizationPatch(k *kustv1.Kustomization, patch kustomize.Patch) <span class="cov1" title="1">{
        k.Spec.Patches = append(k.Spec.Patches, patch)
}</span>

// SetKustomizationNamePrefix sets the name prefix.
func SetKustomizationNamePrefix(k *kustv1.Kustomization, prefix string) <span class="cov0" title="0">{
        k.Spec.NamePrefix = prefix
}</span>

// SetKustomizationNameSuffix sets the name suffix.
func SetKustomizationNameSuffix(k *kustv1.Kustomization, suffix string) <span class="cov0" title="0">{
        k.Spec.NameSuffix = suffix
}</span>

// SetKustomizationCommonMetadata sets common labels and annotations.
func SetKustomizationCommonMetadata(k *kustv1.Kustomization, cm *kustv1.CommonMetadata) <span class="cov0" title="0">{
        k.Spec.CommonMetadata = cm
}</span>

// SetKustomizationDecryption sets the decryption configuration.
func SetKustomizationDecryption(k *kustv1.Kustomization, d *kustv1.Decryption) <span class="cov0" title="0">{
        k.Spec.Decryption = d
}</span>

// SetKustomizationPostBuild sets the post build configuration.
func SetKustomizationPostBuild(k *kustv1.Kustomization, pb *kustv1.PostBuild) <span class="cov0" title="0">{
        k.Spec.PostBuild = pb
}</span>

// CreatePostBuild returns a PostBuild with initialized fields.
func CreatePostBuild() *kustv1.PostBuild <span class="cov1" title="1">{
        return &amp;kustv1.PostBuild{Substitute: map[string]string{}, SubstituteFrom: []kustv1.SubstituteReference{}}
}</span>

// AddPostBuildSubstitute adds a substitute variable.
func AddPostBuildSubstitute(pb *kustv1.PostBuild, key, value string) <span class="cov1" title="1">{
        if pb.Substitute == nil </span><span class="cov0" title="0">{
                pb.Substitute = make(map[string]string)
        }</span>
        <span class="cov1" title="1">pb.Substitute[key] = value</span>
}

// AddPostBuildSubstituteFrom adds a substitution source reference.
func AddPostBuildSubstituteFrom(pb *kustv1.PostBuild, ref kustv1.SubstituteReference) <span class="cov1" title="1">{
        pb.SubstituteFrom = append(pb.SubstituteFrom, ref)
}</span>

// CreateSubstituteReference constructs a SubstituteReference.
func CreateSubstituteReference(kind, name string, optional bool) kustv1.SubstituteReference <span class="cov1" title="1">{
        return kustv1.SubstituteReference{Kind: kind, Name: name, Optional: optional}
}</span>

// CreateDecryption constructs a Decryption specification.
func CreateDecryption(provider string, secret *metaapi.LocalObjectReference) *kustv1.Decryption <span class="cov1" title="1">{
        return &amp;kustv1.Decryption{Provider: provider, SecretRef: secret}
}</span>

// CreateCommonMetadata constructs CommonMetadata with initialized maps.
func CreateCommonMetadata() *kustv1.CommonMetadata <span class="cov1" title="1">{
        return &amp;kustv1.CommonMetadata{Annotations: map[string]string{}, Labels: map[string]string{}}
}</span>

// AddCommonMetadataLabel adds a label to CommonMetadata.
func AddCommonMetadataLabel(cm *kustv1.CommonMetadata, key, value string) <span class="cov1" title="1">{
        if cm.Labels == nil </span><span class="cov0" title="0">{
                cm.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">cm.Labels[key] = value</span>
}

// AddCommonMetadataAnnotation adds an annotation to CommonMetadata.
func AddCommonMetadataAnnotation(cm *kustv1.CommonMetadata, key, value string) <span class="cov1" title="1">{
        if cm.Annotations == nil </span><span class="cov0" title="0">{
                cm.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">cm.Annotations[key] = value</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package fluxcd

import (
        "github.com/fluxcd/notification-controller/api/v1"
        notificationv1beta2 "github.com/fluxcd/notification-controller/api/v1beta2"
        "github.com/fluxcd/pkg/apis/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateProvider returns a new Provider object with the given name, namespace
// and specification.
func CreateProvider(name, namespace string, spec notificationv1beta2.ProviderSpec) *notificationv1beta2.Provider <span class="cov10" title="2">{
        obj := &amp;notificationv1beta2.Provider{
                TypeMeta: metav1.TypeMeta{
                        Kind:       notificationv1beta2.ProviderKind,
                        APIVersion: notificationv1beta2.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// SetProviderType sets the notification provider type.
func SetProviderType(provider *notificationv1beta2.Provider, t string) <span class="cov1" title="1">{
        provider.Spec.Type = t
}</span>

// SetProviderInterval configures the interval at which events are sent.
func SetProviderInterval(provider *notificationv1beta2.Provider, d metav1.Duration) <span class="cov1" title="1">{
        provider.Spec.Interval = &amp;d
}</span>

// SetProviderChannel specifies the target channel for notifications.
func SetProviderChannel(provider *notificationv1beta2.Provider, channel string) <span class="cov1" title="1">{
        provider.Spec.Channel = channel
}</span>

// SetProviderUsername configures the username on the provider spec.
func SetProviderUsername(provider *notificationv1beta2.Provider, username string) <span class="cov1" title="1">{
        provider.Spec.Username = username
}</span>

// SetProviderAddress sets the provider address.
func SetProviderAddress(provider *notificationv1beta2.Provider, address string) <span class="cov1" title="1">{
        provider.Spec.Address = address
}</span>

// SetProviderTimeout sets the timeout for sending notifications.
func SetProviderTimeout(provider *notificationv1beta2.Provider, d metav1.Duration) <span class="cov1" title="1">{
        provider.Spec.Timeout = &amp;d
}</span>

// SetProviderProxy sets the HTTP proxy used when sending events.
func SetProviderProxy(provider *notificationv1beta2.Provider, proxy string) <span class="cov1" title="1">{
        provider.Spec.Proxy = proxy
}</span>

// SetProviderSecretRef attaches a Secret reference to the provider.
func SetProviderSecretRef(provider *notificationv1beta2.Provider, ref *meta.LocalObjectReference) <span class="cov1" title="1">{
        provider.Spec.SecretRef = ref
}</span>

// SetProviderCertSecretRef attaches a certificate Secret reference to the provider.
func SetProviderCertSecretRef(provider *notificationv1beta2.Provider, ref *meta.LocalObjectReference) <span class="cov1" title="1">{
        provider.Spec.CertSecretRef = ref
}</span>

// SetProviderSuspend sets the suspend flag on the provider.
func SetProviderSuspend(provider *notificationv1beta2.Provider, suspend bool) <span class="cov1" title="1">{
        provider.Spec.Suspend = suspend
}</span>

// Alert helpers

// CreateAlert returns a new Alert object configured with the given name,
// namespace and specification.
func CreateAlert(name, namespace string, spec notificationv1beta2.AlertSpec) *notificationv1beta2.Alert <span class="cov10" title="2">{
        obj := &amp;notificationv1beta2.Alert{
                TypeMeta: metav1.TypeMeta{
                        Kind:       notificationv1beta2.AlertKind,
                        APIVersion: notificationv1beta2.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// SetAlertProviderRef sets the provider reference for an alert.
func SetAlertProviderRef(alert *notificationv1beta2.Alert, ref meta.LocalObjectReference) <span class="cov1" title="1">{
        alert.Spec.ProviderRef = ref
}</span>

// AddAlertEventSource appends an event source to the alert specification.
func AddAlertEventSource(alert *notificationv1beta2.Alert, ref v1.CrossNamespaceObjectReference) <span class="cov1" title="1">{
        alert.Spec.EventSources = append(alert.Spec.EventSources, ref)
}</span>

// AddAlertInclusion adds a regex pattern to the inclusion list.
func AddAlertInclusion(alert *notificationv1beta2.Alert, regex string) <span class="cov1" title="1">{
        alert.Spec.InclusionList = append(alert.Spec.InclusionList, regex)
}</span>

// AddAlertExclusion adds a regex pattern to the exclusion list.
func AddAlertExclusion(alert *notificationv1beta2.Alert, regex string) <span class="cov1" title="1">{
        alert.Spec.ExclusionList = append(alert.Spec.ExclusionList, regex)
}</span>

// AddAlertEventMetadata sets a metadata key/value on the alert.
func AddAlertEventMetadata(alert *notificationv1beta2.Alert, key, value string) <span class="cov1" title="1">{
        if alert.Spec.EventMetadata == nil </span><span class="cov1" title="1">{
                alert.Spec.EventMetadata = make(map[string]string)
        }</span>
        <span class="cov1" title="1">alert.Spec.EventMetadata[key] = value</span>
}

// SetAlertEventSeverity sets the severity level for events.
func SetAlertEventSeverity(alert *notificationv1beta2.Alert, sev string) <span class="cov1" title="1">{
        alert.Spec.EventSeverity = sev
}</span>

// SetAlertSummary sets the alert summary message.
func SetAlertSummary(alert *notificationv1beta2.Alert, summary string) <span class="cov1" title="1">{
        alert.Spec.Summary = summary
}</span>

// SetAlertSuspend toggles the suspend flag for the alert.
func SetAlertSuspend(alert *notificationv1beta2.Alert, suspend bool) <span class="cov1" title="1">{
        alert.Spec.Suspend = suspend
}</span>

// Receiver helpers

// CreateReceiver returns a new Receiver object configured with the given name,
// namespace and specification.
func CreateReceiver(name, namespace string, spec notificationv1beta2.ReceiverSpec) *notificationv1beta2.Receiver <span class="cov10" title="2">{
        obj := &amp;notificationv1beta2.Receiver{
                TypeMeta: metav1.TypeMeta{
                        Kind:       notificationv1beta2.ReceiverKind,
                        APIVersion: notificationv1beta2.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// SetReceiverType sets the receiver type.
func SetReceiverType(receiver *notificationv1beta2.Receiver, t string) <span class="cov1" title="1">{
        receiver.Spec.Type = t
}</span>

// SetReceiverInterval configures how often resources are scanned.
func SetReceiverInterval(receiver *notificationv1beta2.Receiver, d metav1.Duration) <span class="cov1" title="1">{
        receiver.Spec.Interval = &amp;d
}</span>

// AddReceiverEvent appends an event to the receiver specification.
func AddReceiverEvent(receiver *notificationv1beta2.Receiver, event string) <span class="cov1" title="1">{
        receiver.Spec.Events = append(receiver.Spec.Events, event)
}</span>

// AddReceiverResource registers a resource reference on the receiver.
func AddReceiverResource(receiver *notificationv1beta2.Receiver, ref v1.CrossNamespaceObjectReference) <span class="cov1" title="1">{
        receiver.Spec.Resources = append(receiver.Spec.Resources, ref)
}</span>

// SetReceiverSecretRef adds a Secret reference to the receiver.
func SetReceiverSecretRef(receiver *notificationv1beta2.Receiver, ref meta.LocalObjectReference) <span class="cov1" title="1">{
        receiver.Spec.SecretRef = ref
}</span>

// SetReceiverSuspend toggles the suspend flag for the receiver.
func SetReceiverSuspend(receiver *notificationv1beta2.Receiver, suspend bool) <span class="cov1" title="1">{
        receiver.Spec.Suspend = suspend
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package fluxcd

import (
        "errors"

        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateResourceSet returns a new ResourceSet object.
func CreateResourceSet(name, namespace string, spec fluxv1.ResourceSetSpec) *fluxv1.ResourceSet <span class="cov10" title="2">{
        obj := &amp;fluxv1.ResourceSet{
                TypeMeta: metav1.TypeMeta{
                        Kind:       fluxv1.ResourceSetKind,
                        APIVersion: fluxv1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddResourceSetInput appends an input to the ResourceSet.
func AddResourceSetInput(rs *fluxv1.ResourceSet, in fluxv1.ResourceSetInput) error <span class="cov1" title="1">{
        if rs == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSet")
        }</span>
        <span class="cov1" title="1">rs.Spec.Inputs = append(rs.Spec.Inputs, in)
        return nil</span>
}

// AddResourceSetInputFrom appends an input provider reference.
func AddResourceSetInputFrom(rs *fluxv1.ResourceSet, ref fluxv1.InputProviderReference) error <span class="cov1" title="1">{
        if rs == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSet")
        }</span>
        <span class="cov1" title="1">rs.Spec.InputsFrom = append(rs.Spec.InputsFrom, ref)
        return nil</span>
}

// AddResourceSetResource appends a resource to reconcile.
func AddResourceSetResource(rs *fluxv1.ResourceSet, r *apiextensionsv1.JSON) error <span class="cov1" title="1">{
        if rs == nil || r == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSet or resource")
        }</span>
        <span class="cov1" title="1">rs.Spec.Resources = append(rs.Spec.Resources, r)
        return nil</span>
}

// SetResourceSetResourcesTemplate sets the resources template.
func SetResourceSetResourcesTemplate(rs *fluxv1.ResourceSet, tpl string) error <span class="cov0" title="0">{
        if rs == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSet")
        }</span>
        <span class="cov0" title="0">rs.Spec.ResourcesTemplate = tpl
        return nil</span>
}

// AddResourceSetDependency appends a dependency.
func AddResourceSetDependency(rs *fluxv1.ResourceSet, dep fluxv1.Dependency) error <span class="cov1" title="1">{
        if rs == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSet")
        }</span>
        <span class="cov1" title="1">rs.Spec.DependsOn = append(rs.Spec.DependsOn, dep)
        return nil</span>
}

// SetResourceSetServiceAccountName sets the service account name.
func SetResourceSetServiceAccountName(rs *fluxv1.ResourceSet, name string) error <span class="cov1" title="1">{
        if rs == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSet")
        }</span>
        <span class="cov1" title="1">rs.Spec.ServiceAccountName = name
        return nil</span>
}

// SetResourceSetWait sets the wait flag.
func SetResourceSetWait(rs *fluxv1.ResourceSet, wait bool) error <span class="cov1" title="1">{
        if rs == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSet")
        }</span>
        <span class="cov1" title="1">rs.Spec.Wait = wait
        return nil</span>
}

// SetResourceSetCommonMetadata sets the common metadata.
func SetResourceSetCommonMetadata(rs *fluxv1.ResourceSet, cm *fluxv1.CommonMetadata) error <span class="cov0" title="0">{
        if rs == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSet")
        }</span>
        <span class="cov0" title="0">rs.Spec.CommonMetadata = cm
        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package fluxcd

import (
        "errors"

        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        "github.com/fluxcd/pkg/apis/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateResourceSetInputProvider returns a new ResourceSetInputProvider object.
func CreateResourceSetInputProvider(name, namespace string, spec fluxv1.ResourceSetInputProviderSpec) *fluxv1.ResourceSetInputProvider <span class="cov10" title="2">{
        obj := &amp;fluxv1.ResourceSetInputProvider{
                TypeMeta: metav1.TypeMeta{
                        Kind:       fluxv1.ResourceSetInputProviderKind,
                        APIVersion: fluxv1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// SetResourceSetInputProviderType sets the provider type.
func SetResourceSetInputProviderType(obj *fluxv1.ResourceSetInputProvider, typ string) error <span class="cov1" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSetInputProvider")
        }</span>
        <span class="cov1" title="1">obj.Spec.Type = typ
        return nil</span>
}

// SetResourceSetInputProviderURL sets the provider URL.
func SetResourceSetInputProviderURL(obj *fluxv1.ResourceSetInputProvider, url string) error <span class="cov1" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSetInputProvider")
        }</span>
        <span class="cov1" title="1">obj.Spec.URL = url
        return nil</span>
}

// SetResourceSetInputProviderServiceAccountName sets the service account name.
func SetResourceSetInputProviderServiceAccountName(obj *fluxv1.ResourceSetInputProvider, name string) error <span class="cov1" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSetInputProvider")
        }</span>
        <span class="cov1" title="1">obj.Spec.ServiceAccountName = name
        return nil</span>
}

// SetResourceSetInputProviderSecretRef sets the secret reference.
func SetResourceSetInputProviderSecretRef(obj *fluxv1.ResourceSetInputProvider, ref *meta.LocalObjectReference) error <span class="cov1" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSetInputProvider")
        }</span>
        <span class="cov1" title="1">obj.Spec.SecretRef = ref
        return nil</span>
}

// SetResourceSetInputProviderCertSecretRef sets the certificate secret reference.
func SetResourceSetInputProviderCertSecretRef(obj *fluxv1.ResourceSetInputProvider, ref *meta.LocalObjectReference) error <span class="cov1" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSetInputProvider")
        }</span>
        <span class="cov1" title="1">obj.Spec.CertSecretRef = ref
        return nil</span>
}

// AddResourceSetInputProviderSchedule appends a schedule to the provider.
func AddResourceSetInputProviderSchedule(obj *fluxv1.ResourceSetInputProvider, s fluxv1.Schedule) error <span class="cov1" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return errors.New("nil ResourceSetInputProvider")
        }</span>
        <span class="cov1" title="1">obj.Spec.Schedule = append(obj.Spec.Schedule, s)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package fluxcd

import (
        "errors"

        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateSchedule returns a Schedule with the given cron expression.
func CreateSchedule(cron string) fluxv1.Schedule <span class="cov10" title="2">{
        return fluxv1.Schedule{Cron: cron}
}</span>

// SetScheduleTimeZone sets the time zone on the schedule.
func SetScheduleTimeZone(s *fluxv1.Schedule, tz string) error <span class="cov1" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return errors.New("nil Schedule")
        }</span>
        <span class="cov1" title="1">s.TimeZone = tz
        return nil</span>
}

// SetScheduleWindow sets the execution window.
func SetScheduleWindow(s *fluxv1.Schedule, d metav1.Duration) error <span class="cov1" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return errors.New("nil Schedule")
        }</span>
        <span class="cov1" title="1">s.Window = d
        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package fluxcd

import (
        "github.com/fluxcd/pkg/apis/acl"
        "github.com/fluxcd/pkg/apis/meta"
        sourcev1 "github.com/fluxcd/source-controller/api/v1"
        sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateGitRepository returns a new GitRepository resource with the provided
// name, namespace and spec.
func CreateGitRepository(name string, namespace string, spec sourcev1.GitRepositorySpec) *sourcev1.GitRepository <span class="cov10" title="5">{
        obj := &amp;sourcev1.GitRepository{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "GitRepository",
                        APIVersion: sourcev1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj

}</span>

// CreateHelmRepository returns a new HelmRepository resource using the given
// specification.
func CreateHelmRepository(name string, namespace string, spec sourcev1.HelmRepositorySpec) *sourcev1.HelmRepository <span class="cov10" title="5">{
        obj := &amp;sourcev1.HelmRepository{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "HelmRepository",
                        APIVersion: sourcev1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// CreateOCIRepository returns a new OCIRepository resource.
func CreateOCIRepository(name string, namespace string, spec sourcev1beta2.OCIRepositorySpec) *sourcev1beta2.OCIRepository <span class="cov10" title="5">{
        obj := &amp;sourcev1beta2.OCIRepository{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "OCIRepository",
                        APIVersion: sourcev1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// CreateBucket returns a new Bucket resource.
func CreateBucket(name, namespace string, spec sourcev1.BucketSpec) *sourcev1.Bucket <span class="cov1" title="1">{
        obj := &amp;sourcev1.Bucket{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Bucket",
                        APIVersion: sourcev1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// CreateHelmChart returns a new HelmChart resource to pull and template a chart.
func CreateHelmChart(name, namespace string, spec sourcev1.HelmChartSpec) *sourcev1.HelmChart <span class="cov1" title="1">{
        obj := &amp;sourcev1.HelmChart{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "HelmChart",
                        APIVersion: sourcev1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// GitRepository helpers

// SetGitRepositoryURL sets the repository clone URL.
func SetGitRepositoryURL(gr *sourcev1.GitRepository, url string) <span class="cov1" title="1">{
        gr.Spec.URL = url
}</span>

// SetGitRepositorySecretRef attaches a Secret reference for authentication.
func SetGitRepositorySecretRef(gr *sourcev1.GitRepository, ref *meta.LocalObjectReference) <span class="cov1" title="1">{
        gr.Spec.SecretRef = ref
}</span>

// SetGitRepositoryProvider specifies the hosting provider of the repository.
func SetGitRepositoryProvider(gr *sourcev1.GitRepository, provider string) <span class="cov0" title="0">{
        gr.Spec.Provider = provider
}</span>

// SetGitRepositoryInterval sets the interval at which the repository is polled.
func SetGitRepositoryInterval(gr *sourcev1.GitRepository, interval metav1.Duration) <span class="cov1" title="1">{
        gr.Spec.Interval = interval
}</span>

// SetGitRepositoryTimeout configures the timeout for Git operations.
func SetGitRepositoryTimeout(gr *sourcev1.GitRepository, timeout *metav1.Duration) <span class="cov0" title="0">{
        gr.Spec.Timeout = timeout
}</span>

// SetGitRepositoryReference sets the revision reference for the repository.
func SetGitRepositoryReference(gr *sourcev1.GitRepository, ref *sourcev1.GitRepositoryRef) <span class="cov0" title="0">{
        gr.Spec.Reference = ref
}</span>

// SetGitRepositoryVerification configures commit signature verification.
func SetGitRepositoryVerification(gr *sourcev1.GitRepository, ver *sourcev1.GitRepositoryVerification) <span class="cov0" title="0">{
        gr.Spec.Verification = ver
}</span>

// SetGitRepositoryProxySecretRef attaches a proxy Secret reference.
func SetGitRepositoryProxySecretRef(gr *sourcev1.GitRepository, ref *meta.LocalObjectReference) <span class="cov0" title="0">{
        gr.Spec.ProxySecretRef = ref
}</span>

// SetGitRepositoryIgnore sets the ignore pattern file contents.
func SetGitRepositoryIgnore(gr *sourcev1.GitRepository, ignore string) <span class="cov0" title="0">{
        gr.Spec.Ignore = &amp;ignore
}</span>

// SetGitRepositorySuspend toggles reconciliation for the repository.
func SetGitRepositorySuspend(gr *sourcev1.GitRepository, suspend bool) <span class="cov0" title="0">{
        gr.Spec.Suspend = suspend
}</span>

// SetGitRepositoryRecurseSubmodules enables or disables submodule recursion.
func SetGitRepositoryRecurseSubmodules(gr *sourcev1.GitRepository, recurse bool) <span class="cov0" title="0">{
        gr.Spec.RecurseSubmodules = recurse
}</span>

// AddGitRepositoryInclude appends an include rule to the repository spec.
func AddGitRepositoryInclude(gr *sourcev1.GitRepository, include sourcev1.GitRepositoryInclude) <span class="cov1" title="1">{
        gr.Spec.Include = append(gr.Spec.Include, include)
}</span>

// HelmRepository helpers

// SetHelmRepositoryURL sets the repository URL.
func SetHelmRepositoryURL(hr *sourcev1.HelmRepository, url string) <span class="cov1" title="1">{
        hr.Spec.URL = url
}</span>

// SetHelmRepositorySecretRef attaches a Secret for authentication to the repository.
func SetHelmRepositorySecretRef(hr *sourcev1.HelmRepository, ref *meta.LocalObjectReference) <span class="cov1" title="1">{
        hr.Spec.SecretRef = ref
}</span>

// SetHelmRepositoryCertSecretRef configures the certificate Secret reference.
func SetHelmRepositoryCertSecretRef(hr *sourcev1.HelmRepository, ref *meta.LocalObjectReference) <span class="cov0" title="0">{
        hr.Spec.CertSecretRef = ref
}</span>

// SetHelmRepositoryPassCredentials toggles passing credentials to subdomains.
func SetHelmRepositoryPassCredentials(hr *sourcev1.HelmRepository, v bool) <span class="cov0" title="0">{
        hr.Spec.PassCredentials = v
}</span>

// SetHelmRepositoryInterval sets how often the repository is polled.
func SetHelmRepositoryInterval(hr *sourcev1.HelmRepository, interval metav1.Duration) <span class="cov1" title="1">{
        hr.Spec.Interval = interval
}</span>

// SetHelmRepositoryInsecure toggles skipping TLS verification.
func SetHelmRepositoryInsecure(hr *sourcev1.HelmRepository, insecure bool) <span class="cov0" title="0">{
        hr.Spec.Insecure = insecure
}</span>

// SetHelmRepositoryTimeout configures the network timeout for repository requests.
func SetHelmRepositoryTimeout(hr *sourcev1.HelmRepository, timeout *metav1.Duration) <span class="cov0" title="0">{
        hr.Spec.Timeout = timeout
}</span>

// SetHelmRepositorySuspend toggles reconciliation for the repository.
func SetHelmRepositorySuspend(hr *sourcev1.HelmRepository, suspend bool) <span class="cov0" title="0">{
        hr.Spec.Suspend = suspend
}</span>

// SetHelmRepositoryAccessFrom sets access control for the repository.
func SetHelmRepositoryAccessFrom(hr *sourcev1.HelmRepository, access *acl.AccessFrom) <span class="cov0" title="0">{
        hr.Spec.AccessFrom = access
}</span>

// SetHelmRepositoryType sets the repository type.
func SetHelmRepositoryType(hr *sourcev1.HelmRepository, typ string) <span class="cov0" title="0">{
        hr.Spec.Type = typ
}</span>

// SetHelmRepositoryProvider specifies the provider name for the repository.
func SetHelmRepositoryProvider(hr *sourcev1.HelmRepository, provider string) <span class="cov1" title="1">{
        hr.Spec.Provider = provider
}</span>

// Bucket helpers

// SetBucketProvider sets the cloud provider for the bucket.
func SetBucketProvider(b *sourcev1.Bucket, provider string) <span class="cov0" title="0">{
        b.Spec.Provider = provider
}</span>

// SetBucketName sets the bucket name.
func SetBucketName(b *sourcev1.Bucket, name string) <span class="cov1" title="1">{
        b.Spec.BucketName = name
}</span>

// SetBucketEndpoint configures the bucket API endpoint.
func SetBucketEndpoint(b *sourcev1.Bucket, endpoint string) <span class="cov1" title="1">{
        b.Spec.Endpoint = endpoint
}</span>

// SetBucketSTS sets the STS configuration for the bucket.
func SetBucketSTS(b *sourcev1.Bucket, sts *sourcev1.BucketSTSSpec) <span class="cov0" title="0">{
        b.Spec.STS = sts
}</span>

// SetBucketInsecure toggles insecure TLS for bucket requests.
func SetBucketInsecure(b *sourcev1.Bucket, insecure bool) <span class="cov0" title="0">{
        b.Spec.Insecure = insecure
}</span>

// SetBucketRegion sets the bucket region.
func SetBucketRegion(b *sourcev1.Bucket, region string) <span class="cov0" title="0">{
        b.Spec.Region = region
}</span>

// SetBucketPrefix sets the bucket prefix path.
func SetBucketPrefix(b *sourcev1.Bucket, prefix string) <span class="cov0" title="0">{
        b.Spec.Prefix = prefix
}</span>

// SetBucketSecretRef attaches credentials secret reference.
func SetBucketSecretRef(b *sourcev1.Bucket, ref *meta.LocalObjectReference) <span class="cov1" title="1">{
        b.Spec.SecretRef = ref
}</span>

// SetBucketCertSecretRef sets the certificate secret for the bucket.
func SetBucketCertSecretRef(b *sourcev1.Bucket, ref *meta.LocalObjectReference) <span class="cov0" title="0">{
        b.Spec.CertSecretRef = ref
}</span>

// SetBucketProxySecretRef attaches a proxy secret reference to the bucket.
func SetBucketProxySecretRef(b *sourcev1.Bucket, ref *meta.LocalObjectReference) <span class="cov0" title="0">{
        b.Spec.ProxySecretRef = ref
}</span>

// SetBucketInterval sets how often the bucket is checked for updates.
func SetBucketInterval(b *sourcev1.Bucket, interval metav1.Duration) <span class="cov1" title="1">{
        b.Spec.Interval = interval
}</span>

// SetBucketTimeout configures the timeout for bucket operations.
func SetBucketTimeout(b *sourcev1.Bucket, timeout *metav1.Duration) <span class="cov0" title="0">{
        b.Spec.Timeout = timeout
}</span>

// SetBucketIgnore configures patterns to ignore from the bucket.
func SetBucketIgnore(b *sourcev1.Bucket, ignore string) <span class="cov0" title="0">{
        b.Spec.Ignore = &amp;ignore
}</span>

// SetBucketSuspend toggles reconciliation of the bucket source.
func SetBucketSuspend(b *sourcev1.Bucket, suspend bool) <span class="cov0" title="0">{
        b.Spec.Suspend = suspend
}</span>

// HelmChart helpers

// SetHelmChartChart sets the chart name on the HelmChart.
func SetHelmChartChart(hc *sourcev1.HelmChart, chart string) <span class="cov1" title="1">{
        hc.Spec.Chart = chart
}</span>

// SetHelmChartVersion sets the chart version to fetch.
func SetHelmChartVersion(hc *sourcev1.HelmChart, version string) <span class="cov1" title="1">{
        hc.Spec.Version = version
}</span>

// SetHelmChartSourceRef sets the source reference for the chart.
func SetHelmChartSourceRef(hc *sourcev1.HelmChart, ref sourcev1.LocalHelmChartSourceReference) <span class="cov0" title="0">{
        hc.Spec.SourceRef = ref
}</span>

// SetHelmChartInterval configures how often the chart is reconciled.
func SetHelmChartInterval(hc *sourcev1.HelmChart, interval metav1.Duration) <span class="cov1" title="1">{
        hc.Spec.Interval = interval
}</span>

// SetHelmChartReconcileStrategy sets the reconcile strategy for templating.
func SetHelmChartReconcileStrategy(hc *sourcev1.HelmChart, strategy string) <span class="cov0" title="0">{
        hc.Spec.ReconcileStrategy = strategy
}</span>

// AddHelmChartValuesFile appends a values file to the chart specification.
func AddHelmChartValuesFile(hc *sourcev1.HelmChart, file string) <span class="cov1" title="1">{
        hc.Spec.ValuesFiles = append(hc.Spec.ValuesFiles, file)
}</span>

// SetHelmChartValuesFiles replaces the values files list.
func SetHelmChartValuesFiles(hc *sourcev1.HelmChart, files []string) <span class="cov0" title="0">{
        hc.Spec.ValuesFiles = files
}</span>

// SetHelmChartIgnoreMissingValuesFiles toggles ignoring missing values files.
func SetHelmChartIgnoreMissingValuesFiles(hc *sourcev1.HelmChart, ignore bool) <span class="cov0" title="0">{
        hc.Spec.IgnoreMissingValuesFiles = ignore
}</span>

// SetHelmChartSuspend toggles reconciliation of the chart.
func SetHelmChartSuspend(hc *sourcev1.HelmChart, suspend bool) <span class="cov0" title="0">{
        hc.Spec.Suspend = suspend
}</span>

// SetHelmChartVerify configures OCI signature verification for the chart.
func SetHelmChartVerify(hc *sourcev1.HelmChart, verify *sourcev1.OCIRepositoryVerification) <span class="cov0" title="0">{
        hc.Spec.Verify = verify
}</span>

// OCIRepository helpers

// SetOCIRepositoryURL sets the container registry URL.
func SetOCIRepositoryURL(or *sourcev1beta2.OCIRepository, url string) <span class="cov1" title="1">{
        or.Spec.URL = url
}</span>

// SetOCIRepositoryReference sets the tag or digest reference.
func SetOCIRepositoryReference(or *sourcev1beta2.OCIRepository, ref *sourcev1beta2.OCIRepositoryRef) <span class="cov0" title="0">{
        or.Spec.Reference = ref
}</span>

// SetOCIRepositoryLayerSelector configures the layer selector used to pull images.
func SetOCIRepositoryLayerSelector(or *sourcev1beta2.OCIRepository, sel *sourcev1beta2.OCILayerSelector) <span class="cov0" title="0">{
        or.Spec.LayerSelector = sel
}</span>

// SetOCIRepositoryProvider sets the provider name.
func SetOCIRepositoryProvider(or *sourcev1beta2.OCIRepository, provider string) <span class="cov1" title="1">{
        or.Spec.Provider = provider
}</span>

// SetOCIRepositorySecretRef attaches credentials secret reference.
func SetOCIRepositorySecretRef(or *sourcev1beta2.OCIRepository, ref *meta.LocalObjectReference) <span class="cov1" title="1">{
        or.Spec.SecretRef = ref
}</span>

// SetOCIRepositoryVerify configures OCI signature verification for the repository.
func SetOCIRepositoryVerify(or *sourcev1beta2.OCIRepository, verify *sourcev1.OCIRepositoryVerification) <span class="cov0" title="0">{
        or.Spec.Verify = verify
}</span>

// SetOCIRepositoryServiceAccountName sets the service account used for pulls.
func SetOCIRepositoryServiceAccountName(or *sourcev1beta2.OCIRepository, name string) <span class="cov0" title="0">{
        or.Spec.ServiceAccountName = name
}</span>

// SetOCIRepositoryCertSecretRef configures the certificate secret reference.
func SetOCIRepositoryCertSecretRef(or *sourcev1beta2.OCIRepository, ref *meta.LocalObjectReference) <span class="cov0" title="0">{
        or.Spec.CertSecretRef = ref
}</span>

// SetOCIRepositoryProxySecretRef attaches a proxy secret reference.
func SetOCIRepositoryProxySecretRef(or *sourcev1beta2.OCIRepository, ref *meta.LocalObjectReference) <span class="cov0" title="0">{
        or.Spec.ProxySecretRef = ref
}</span>

// SetOCIRepositoryInterval sets how often the repository is pulled.
func SetOCIRepositoryInterval(or *sourcev1beta2.OCIRepository, interval metav1.Duration) <span class="cov1" title="1">{
        or.Spec.Interval = interval
}</span>

// SetOCIRepositoryTimeout configures the timeout for registry operations.
func SetOCIRepositoryTimeout(or *sourcev1beta2.OCIRepository, timeout *metav1.Duration) <span class="cov0" title="0">{
        or.Spec.Timeout = timeout
}</span>

// SetOCIRepositoryIgnore configures ignore rules for the repository.
func SetOCIRepositoryIgnore(or *sourcev1beta2.OCIRepository, ignore string) <span class="cov0" title="0">{
        or.Spec.Ignore = &amp;ignore
}</span>

// SetOCIRepositoryInsecure toggles insecure pulls from the repository.
func SetOCIRepositoryInsecure(or *sourcev1beta2.OCIRepository, insecure bool) <span class="cov0" title="0">{
        or.Spec.Insecure = insecure
}</span>

// SetOCIRepositorySuspend toggles reconciliation for the OCIRepository.
func SetOCIRepositorySuspend(or *sourcev1beta2.OCIRepository, suspend bool) <span class="cov0" title="0">{
        or.Spec.Suspend = suspend
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package gvk

import (
        "fmt"
        "sort"
        "strconv"
        "strings"
)

// ConversionPath represents a path from one version to another
type ConversionPath struct {
        From      GVK
        To        GVK
        Converter Converter
}

// Converter defines the interface for converting between versions
type Converter interface {
        Convert(from interface{}) (interface{}, error)
}

// ConversionFunc is a function-based converter
type ConversionFunc func(from interface{}) (interface{}, error)

// Convert implements the Converter interface
func (f ConversionFunc) Convert(from interface{}) (interface{}, error) <span class="cov0" title="0">{
        return f(from)
}</span>

// ConversionRegistry manages version conversion paths
type ConversionRegistry struct {
        conversions map[string]map[string]Converter // [fromGVK][toGVK] -&gt; Converter
}

// NewConversionRegistry creates a new conversion registry
func NewConversionRegistry() *ConversionRegistry <span class="cov0" title="0">{
        return &amp;ConversionRegistry{
                conversions: make(map[string]map[string]Converter),
        }
}</span>

// Register registers a conversion path
func (r *ConversionRegistry) Register(from, to GVK, converter Converter) <span class="cov0" title="0">{
        fromKey := from.String()
        toKey := to.String()

        if r.conversions[fromKey] == nil </span><span class="cov0" title="0">{
                r.conversions[fromKey] = make(map[string]Converter)
        }</span>
        <span class="cov0" title="0">r.conversions[fromKey][toKey] = converter</span>
}

// RegisterFunc registers a conversion function
func (r *ConversionRegistry) RegisterFunc(from, to GVK, converter ConversionFunc) <span class="cov0" title="0">{
        r.Register(from, to, converter)
}</span>

// Convert converts from one GVK to another
func (r *ConversionRegistry) Convert(from, to GVK, obj interface{}) (interface{}, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return obj, nil // No conversion needed
        }</span>

        <span class="cov0" title="0">fromKey := from.String()
        toKey := to.String()

        if fromConverters, exists := r.conversions[fromKey]; exists </span><span class="cov0" title="0">{
                if converter, exists := fromConverters[toKey]; exists </span><span class="cov0" title="0">{
                        return converter.Convert(obj)
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no conversion path from %s to %s", from, to)</span>
}

// HasConversion checks if a conversion path exists
func (r *ConversionRegistry) HasConversion(from, to GVK) bool <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">fromKey := from.String()
        toKey := to.String()

        if fromConverters, exists := r.conversions[fromKey]; exists </span><span class="cov0" title="0">{
                _, exists := fromConverters[toKey]
                return exists
        }</span>

        <span class="cov0" title="0">return false</span>
}

// ListConversions returns all available conversion paths for a given GVK
func (r *ConversionRegistry) ListConversions(from GVK) []GVK <span class="cov0" title="0">{
        fromKey := from.String()
        var targets []GVK

        if fromConverters, exists := r.conversions[fromKey]; exists </span><span class="cov0" title="0">{
                for toKey := range fromConverters </span><span class="cov0" title="0">{
                        // Parse the target GVK from the key
                        // This is a simplified parser - in practice you'd store GVKs directly
                        parts := strings.Split(toKey, ", Kind=")
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                apiVersion := parts[0]
                                kind := parts[1]
                                targets = append(targets, ParseAPIVersion(apiVersion, kind))
                        }</span>
                }
        }

        <span class="cov0" title="0">return targets</span>
}

// VersionComparator compares version strings using semantic versioning
type VersionComparator struct{}

// Compare compares two version strings
// Returns: -1 if v1 &lt; v2, 0 if v1 == v2, 1 if v1 &gt; v2
func (vc *VersionComparator) Compare(v1, v2 string) int <span class="cov0" title="0">{
        // Handle special version formats
        v1Normalized := vc.normalizeVersion(v1)
        v2Normalized := vc.normalizeVersion(v2)

        v1Parts := vc.parseVersion(v1Normalized)
        v2Parts := vc.parseVersion(v2Normalized)

        // Compare major, minor, patch
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                if v1Parts[i] &lt; v2Parts[i] </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if v1Parts[i] &gt; v2Parts[i] </span><span class="cov0" title="0">{
                        return 1
                }</span>
        }

        // Compare pre-release
        <span class="cov0" title="0">return vc.comparePrerelease(v1Parts[3], v2Parts[3])</span>
}

// normalizeVersion normalizes version strings to standard format
func (vc *VersionComparator) normalizeVersion(v string) string <span class="cov0" title="0">{
        // Handle Kubernetes-style versions
        if strings.HasPrefix(v, "v") &amp;&amp; len(v) &gt; 1 </span><span class="cov0" title="0">{
                v = v[1:] // Remove 'v' prefix
        }</span>

        // Handle alpha/beta versions
        <span class="cov0" title="0">v = strings.ReplaceAll(v, "alpha", "alpha.")
        v = strings.ReplaceAll(v, "beta", "beta.")

        return v</span>
}

// parseVersion parses a version string into [major, minor, patch, prerelease]
func (vc *VersionComparator) parseVersion(v string) [4]int <span class="cov0" title="0">{
        parts := [4]int{0, 0, 0, 0} // major, minor, patch, prerelease

        // Split by pre-release
        mainAndPre := strings.SplitN(v, "alpha", 2)
        if len(mainAndPre) == 1 </span><span class="cov0" title="0">{
                mainAndPre = strings.SplitN(v, "beta", 2)
                if len(mainAndPre) == 2 </span><span class="cov0" title="0">{
                        parts[3] = 2000 // beta is higher than alpha
                }</span>
        } else<span class="cov0" title="0"> {
                parts[3] = 1000 // alpha
        }</span>

        // Parse pre-release number
        <span class="cov0" title="0">if len(mainAndPre) == 2 &amp;&amp; mainAndPre[1] != "" </span><span class="cov0" title="0">{
                if preNum, err := strconv.Atoi(strings.TrimPrefix(mainAndPre[1], ".")); err == nil </span><span class="cov0" title="0">{
                        parts[3] += preNum
                }</span>
        } else<span class="cov0" title="0"> if len(mainAndPre) == 1 </span><span class="cov0" title="0">{
                parts[3] = 9999 // stable version
        }</span>

        // Parse main version
        <span class="cov0" title="0">mainParts := strings.Split(mainAndPre[0], ".")
        for i, part := range mainParts </span><span class="cov0" title="0">{
                if i &gt;= 3 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if num, err := strconv.Atoi(part); err == nil </span><span class="cov0" title="0">{
                        parts[i] = num
                }</span>
        }

        <span class="cov0" title="0">return parts</span>
}

// comparePrerelease compares pre-release values
func (vc *VersionComparator) comparePrerelease(p1, p2 int) int <span class="cov0" title="0">{
        if p1 &lt; p2 </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if p1 &gt; p2 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// GetLatestVersion returns the latest version from a list of GVKs with the same group/kind
func (vc *VersionComparator) GetLatestVersion(gvks []GVK) (GVK, error) <span class="cov0" title="0">{
        if len(gvks) == 0 </span><span class="cov0" title="0">{
                return GVK{}, fmt.Errorf("no GVKs provided")
        }</span>

        // Verify all have same group/kind
        <span class="cov0" title="0">first := gvks[0]
        for _, gvk := range gvks[1:] </span><span class="cov0" title="0">{
                if gvk.Group != first.Group || gvk.Kind != first.Kind </span><span class="cov0" title="0">{
                        return GVK{}, fmt.Errorf("all GVKs must have same group and kind")
                }</span>
        }

        // Sort by version
        <span class="cov0" title="0">sort.Slice(gvks, func(i, j int) bool </span><span class="cov0" title="0">{
                return vc.Compare(gvks[i].Version, gvks[j].Version) &gt; 0
        }</span>)

        <span class="cov0" title="0">return gvks[0], nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package gvk

import (
        "fmt"
        "io"

        "gopkg.in/yaml.v3"
)

// ParseOptions configures how GVK parsing behaves
type ParseOptions struct {
        // StrictGVK requires apiVersion and kind to be present
        StrictGVK bool
        // AllowUnknownTypes allows parsing of unregistered types
        AllowUnknownTypes bool
}

// DefaultParseOptions provides sensible defaults for parsing
var DefaultParseOptions = ParseOptions{
        StrictGVK:         true,
        AllowUnknownTypes: false,
}

// ParseSingle parses a single GVK-enabled type from YAML data
func ParseSingle[T any](data []byte, registry *Registry[T], options *ParseOptions) (*TypedWrapper[T], error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = &amp;DefaultParseOptions
        }</span>

        <span class="cov0" title="0">wrapper := NewTypedWrapper(registry)
        if err := yaml.Unmarshal(data, wrapper); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal: %w", err)
        }</span>

        <span class="cov0" title="0">return wrapper, nil</span>
}

// ParseMultiple parses multiple GVK-enabled types from YAML data (separated by ---)
func ParseMultiple[T any](data []byte, registry *Registry[T], options *ParseOptions) ([]*TypedWrapper[T], error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = &amp;DefaultParseOptions
        }</span>

        <span class="cov0" title="0">var wrappers []*TypedWrapper[T]

        // Split by YAML documents
        documents := splitYAMLDocuments(data)

        for i, doc := range documents </span><span class="cov0" title="0">{
                if len(doc) == 0 </span><span class="cov0" title="0">{
                        continue</span> // Skip empty documents
                }

                <span class="cov0" title="0">wrapper := NewTypedWrapper(registry)
                if err := yaml.Unmarshal(doc, wrapper); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal document %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">wrappers = append(wrappers, wrapper)</span>
        }

        <span class="cov0" title="0">return wrappers, nil</span>
}

// ParseStream parses a stream of YAML documents
func ParseStream[T any](reader io.Reader, registry *Registry[T], options *ParseOptions) ([]*TypedWrapper[T], error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = &amp;DefaultParseOptions
        }</span>

        <span class="cov0" title="0">var wrappers []*TypedWrapper[T]
        decoder := yaml.NewDecoder(reader)

        for </span><span class="cov0" title="0">{
                var node yaml.Node
                if err := decoder.Decode(&amp;node); err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to decode YAML document: %w", err)</span>
                }

                <span class="cov0" title="0">wrapper := NewTypedWrapper(registry)
                if err := node.Decode(wrapper); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal wrapper: %w", err)
                }</span>

                <span class="cov0" title="0">wrappers = append(wrappers, wrapper)</span>
        }

        <span class="cov0" title="0">return wrappers, nil</span>
}

// ValidateGVK validates that a GVK is properly formed
func ValidateGVK(gvk GVK) error <span class="cov10" title="4">{
        if gvk.Kind == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("kind is required")
        }</span>
        <span class="cov8" title="3">if gvk.Version == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("version is required")
        }</span>
        // Group can be empty for core types
        <span class="cov5" title="2">return nil</span>
}

// splitYAMLDocuments splits YAML data by document separators
func splitYAMLDocuments(data []byte) [][]byte <span class="cov0" title="0">{
        // This is a simple implementation - a more robust version would
        // properly handle YAML document separators considering indentation
        // and quoted strings

        documents := [][]byte{}
        current := []byte{}

        lines := splitLines(data)
        for _, line := range lines </span><span class="cov0" title="0">{
                if string(line) == "---" || string(line) == "---\n" </span><span class="cov0" title="0">{
                        if len(current) &gt; 0 </span><span class="cov0" title="0">{
                                documents = append(documents, current)
                                current = []byte{}
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">current = append(current, line...)
                current = append(current, '\n')</span>
        }

        <span class="cov0" title="0">if len(current) &gt; 0 </span><span class="cov0" title="0">{
                documents = append(documents, current)
        }</span>

        <span class="cov0" title="0">return documents</span>
}

// splitLines splits data into lines
func splitLines(data []byte) [][]byte <span class="cov0" title="0">{
        var lines [][]byte
        start := 0

        for i, b := range data </span><span class="cov0" title="0">{
                if b == '\n' </span><span class="cov0" title="0">{
                        lines = append(lines, data[start:i])
                        start = i + 1
                }</span>
        }

        <span class="cov0" title="0">if start &lt; len(data) </span><span class="cov0" title="0">{
                lines = append(lines, data[start:])
        }</span>

        <span class="cov0" title="0">return lines</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package gvk

import (
        "fmt"
        "sync"
)

// Factory is a function that creates a new instance of type T
type Factory[T any] func() T

// Registry manages type factories for GVK-based types
type Registry[T any] struct {
        factories map[GVK]Factory[T]
        mu        sync.RWMutex
}

// NewRegistry creates a new registry for type T
func NewRegistry[T any]() *Registry[T] <span class="cov10" title="6">{
        return &amp;Registry[T]{
                factories: make(map[GVK]Factory[T]),
        }
}</span>

// Register adds a new type factory to the registry
func (r *Registry[T]) Register(gvk GVK, factory Factory[T]) <span class="cov9" title="5">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.factories[gvk] = factory
}</span>

// Create creates a new instance for the given GVK
func (r *Registry[T]) Create(gvk GVK) (T, error) <span class="cov6" title="3">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        factory, exists := r.factories[gvk]
        if !exists </span><span class="cov1" title="1">{
                var zero T
                return zero, fmt.Errorf("unknown type: %s", gvk)
        }</span>
        <span class="cov4" title="2">return factory(), nil</span>
}

// CreateFromAPIVersion creates a new instance for the given apiVersion and kind
func (r *Registry[T]) CreateFromAPIVersion(apiVersion, kind string) (T, error) <span class="cov1" title="1">{
        gvk := ParseAPIVersion(apiVersion, kind)
        return r.Create(gvk)
}</span>

// ListGVKs returns all registered GVKs
func (r *Registry[T]) ListGVKs() []GVK <span class="cov1" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        gvks := make([]GVK, 0, len(r.factories))
        for gvk := range r.factories </span><span class="cov4" title="2">{
                gvks = append(gvks, gvk)
        }</span>
        <span class="cov1" title="1">return gvks</span>
}

// HasGVK checks if a GVK is registered
func (r *Registry[T]) HasGVK(gvk GVK) bool <span class="cov6" title="3">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        _, exists := r.factories[gvk]
        return exists
}</span>

// HasAPIVersion checks if an apiVersion and kind combination is registered
func (r *Registry[T]) HasAPIVersion(apiVersion, kind string) bool <span class="cov4" title="2">{
        gvk := ParseAPIVersion(apiVersion, kind)
        return r.HasGVK(gvk)
}</span>

// Count returns the number of registered types
func (r *Registry[T]) Count() int <span class="cov4" title="2">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.factories)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package gvk

import (
        "fmt"
        "strings"
)

// GVK represents a Group, Version, Kind tuple for identifying types
type GVK struct {
        Group   string
        Version string
        Kind    string
}

// String returns the string representation of GVK
func (g GVK) String() string <span class="cov4" title="2">{
        return fmt.Sprintf("%s/%s, Kind=%s", g.Group, g.Version, g.Kind)
}</span>

// APIVersion returns the apiVersion string (group/version)
func (g GVK) APIVersion() string <span class="cov4" title="2">{
        if g.Group == "" </span><span class="cov1" title="1">{
                return g.Version
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s/%s", g.Group, g.Version)</span>
}

// ParseAPIVersion parses an apiVersion and kind into a GVK
func ParseAPIVersion(apiVersion, kind string) GVK <span class="cov10" title="5">{
        parts := strings.Split(apiVersion, "/")
        if len(parts) == 2 </span><span class="cov8" title="4">{
                return GVK{
                        Group:   parts[0],
                        Version: parts[1],
                        Kind:    kind,
                }
        }</span>
        // Handle core/v1 style or bare version
        <span class="cov1" title="1">return GVK{
                Group:   "",
                Version: parts[0],
                Kind:    kind,
        }</span>
}

// VersionedType is a type that supports GVK identification
type VersionedType interface {
        GetAPIVersion() string // Returns "group/version"
        GetKind() string
}

// NamedType is a type that has a name
type NamedType interface {
        GetName() string
        SetName(string)
}

// NamespacedType is a type that has a namespace
type NamespacedType interface {
        GetNamespace() string
        SetNamespace(string)
}

// MetadataType combines name and namespace interfaces
type MetadataType interface {
        NamedType
        NamespacedType
}

// Convertible allows for version migration between different versions of the same kind
type Convertible interface {
        ConvertTo(version string) (interface{}, error)
        ConvertFrom(from interface{}) error
}

// BaseMetadata provides common metadata fields for GVK types
type BaseMetadata struct {
        Name      string `yaml:"name" json:"name"`
        Namespace string `yaml:"namespace,omitempty" json:"namespace,omitempty"`
}

// GetName returns the name
func (m *BaseMetadata) GetName() string <span class="cov1" title="1">{
        return m.Name
}</span>

// SetName sets the name
func (m *BaseMetadata) SetName(name string) <span class="cov1" title="1">{
        m.Name = name
}</span>

// GetNamespace returns the namespace
func (m *BaseMetadata) GetNamespace() string <span class="cov1" title="1">{
        return m.Namespace
}</span>

// SetNamespace sets the namespace
func (m *BaseMetadata) SetNamespace(namespace string) <span class="cov1" title="1">{
        m.Namespace = namespace
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package gvk

import (
        "fmt"

        "gopkg.in/yaml.v3"
)

// TypedWrapper provides type detection and unmarshaling for GVK-based types
type TypedWrapper[T any] struct {
        APIVersion string         `yaml:"apiVersion" json:"apiVersion"`
        Kind       string         `yaml:"kind" json:"kind"`
        Metadata   map[string]any `yaml:"metadata" json:"metadata"`
        Spec       T              `yaml:"-" json:"-"`
        registry   *Registry[T]
}

// NewTypedWrapper creates a new typed wrapper with the given registry
func NewTypedWrapper[T any](registry *Registry[T]) *TypedWrapper[T] <span class="cov0" title="0">{
        return &amp;TypedWrapper[T]{
                registry: registry,
                Metadata: make(map[string]any),
        }
}</span>

// UnmarshalYAML implements custom YAML unmarshaling with type detection
func (w *TypedWrapper[T]) UnmarshalYAML(node *yaml.Node) error <span class="cov0" title="0">{
        if w.registry == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("registry not set - use NewTypedWrapper to create instances")
        }</span>

        // First pass: extract GVK
        <span class="cov0" title="0">var gvkDetect struct {
                APIVersion string `yaml:"apiVersion"`
                Kind       string `yaml:"kind"`
        }
        if err := node.Decode(&amp;gvkDetect); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detect GVK: %w", err)
        }</span>

        <span class="cov0" title="0">if gvkDetect.APIVersion == "" || gvkDetect.Kind == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("apiVersion and kind are required fields")
        }</span>

        // Create appropriate instance
        <span class="cov0" title="0">instance, err := w.registry.CreateFromAPIVersion(gvkDetect.APIVersion, gvkDetect.Kind)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create instance for %s/%s: %w",
                        gvkDetect.APIVersion, gvkDetect.Kind, err)
        }</span>

        // Decode full content
        <span class="cov0" title="0">var raw struct {
                APIVersion string         `yaml:"apiVersion"`
                Kind       string         `yaml:"kind"`
                Metadata   map[string]any `yaml:"metadata"`
                Spec       yaml.Node      `yaml:"spec"`
        }

        if err := node.Decode(&amp;raw); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode wrapper: %w", err)
        }</span>

        // Decode spec into the specific type
        <span class="cov0" title="0">if err := raw.Spec.Decode(&amp;instance); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode spec for %s/%s: %w",
                        raw.APIVersion, raw.Kind, err)
        }</span>

        <span class="cov0" title="0">w.APIVersion = raw.APIVersion
        w.Kind = raw.Kind
        w.Metadata = raw.Metadata
        w.Spec = instance

        // Apply metadata to the instance if it supports it
        if w.Metadata != nil </span><span class="cov0" title="0">{
                if name, ok := w.Metadata["name"].(string); ok </span><span class="cov0" title="0">{
                        if named, ok := any(&amp;instance).(NamedType); ok </span><span class="cov0" title="0">{
                                named.SetName(name)
                        }</span>
                }
                <span class="cov0" title="0">if namespace, ok := w.Metadata["namespace"].(string); ok </span><span class="cov0" title="0">{
                        if namespaced, ok := any(&amp;instance).(NamespacedType); ok </span><span class="cov0" title="0">{
                                namespaced.SetNamespace(namespace)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// MarshalYAML implements custom YAML marshaling
func (w *TypedWrapper[T]) MarshalYAML() (interface{}, error) <span class="cov0" title="0">{
        // Create a map representation for clean YAML output
        result := map[string]interface{}{
                "apiVersion": w.APIVersion,
                "kind":       w.Kind,
        }

        if len(w.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                result["metadata"] = w.Metadata
        }</span>

        <span class="cov0" title="0">if !isZero(w.Spec) </span><span class="cov0" title="0">{
                result["spec"] = w.Spec
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetGVK returns the GVK for this wrapper
func (w *TypedWrapper[T]) GetGVK() GVK <span class="cov0" title="0">{
        return ParseAPIVersion(w.APIVersion, w.Kind)
}</span>

// GetName returns the name from metadata if available
func (w *TypedWrapper[T]) GetName() string <span class="cov0" title="0">{
        if name, ok := w.Metadata["name"].(string); ok </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetNamespace returns the namespace from metadata if available
func (w *TypedWrapper[T]) GetNamespace() string <span class="cov0" title="0">{
        if namespace, ok := w.Metadata["namespace"].(string); ok </span><span class="cov0" title="0">{
                return namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// SetName sets the name in metadata
func (w *TypedWrapper[T]) SetName(name string) <span class="cov0" title="0">{
        if w.Metadata == nil </span><span class="cov0" title="0">{
                w.Metadata = make(map[string]any)
        }</span>
        <span class="cov0" title="0">w.Metadata["name"] = name</span>
}

// SetNamespace sets the namespace in metadata
func (w *TypedWrapper[T]) SetNamespace(namespace string) <span class="cov0" title="0">{
        if w.Metadata == nil </span><span class="cov0" title="0">{
                w.Metadata = make(map[string]any)
        }</span>
        <span class="cov0" title="0">w.Metadata["namespace"] = namespace</span>
}

// isZero checks if a value is the zero value for its type
func isZero[T any](v T) bool <span class="cov0" title="0">{
        var zero T
        return fmt.Sprintf("%v", v) == fmt.Sprintf("%v", zero)
}</span>

// TypedWrappers is a slice of TypedWrapper for unmarshaling multiple configs
type TypedWrappers[T any] []TypedWrapper[T]

// UnmarshalYAML implements custom YAML unmarshaling for slices
func (ws *TypedWrappers[T]) UnmarshalYAML(node *yaml.Node) error <span class="cov0" title="0">{
        // This requires the registry to be set somehow -
        // typically this would be handled by a containing type
        // that knows about the registry
        return fmt.Errorf("TypedWrappers requires registry context - use a container type")
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/pkg/errors"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateConfigMap returns a basic ConfigMap object with common metadata preset.
func CreateConfigMap(name, namespace string) *corev1.ConfigMap <span class="cov10" title="5">{
        obj := &amp;corev1.ConfigMap{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ConfigMap",
                        APIVersion: corev1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Data:       map[string]string{},
                BinaryData: map[string][]byte{},
        }
        return obj
}</span>

// AddConfigMapData inserts a single key/value pair into the ConfigMap's Data field.
func AddConfigMapData(cm *corev1.ConfigMap, key, value string) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">if cm.Data == nil </span><span class="cov0" title="0">{
                cm.Data = make(map[string]string)
        }</span>
        <span class="cov1" title="1">cm.Data[key] = value
        return nil</span>
}

// AddConfigMapDataMap merges all entries from the provided map into the ConfigMap's Data field.
func AddConfigMapDataMap(cm *corev1.ConfigMap, data map[string]string) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">if cm.Data == nil </span><span class="cov0" title="0">{
                cm.Data = make(map[string]string)
        }</span>
        <span class="cov1" title="1">for k, v := range data </span><span class="cov4" title="2">{
                cm.Data[k] = v
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// AddConfigMapBinaryData inserts a single binary entry into the ConfigMap.
func AddConfigMapBinaryData(cm *corev1.ConfigMap, key string, value []byte) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">if cm.BinaryData == nil </span><span class="cov0" title="0">{
                cm.BinaryData = make(map[string][]byte)
        }</span>
        <span class="cov1" title="1">cm.BinaryData[key] = value
        return nil</span>
}

// AddConfigMapBinaryDataMap merges all binary entries into the ConfigMap's BinaryData field.
func AddConfigMapBinaryDataMap(cm *corev1.ConfigMap, data map[string][]byte) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">if cm.BinaryData == nil </span><span class="cov0" title="0">{
                cm.BinaryData = make(map[string][]byte)
        }</span>
        <span class="cov1" title="1">for k, v := range data </span><span class="cov4" title="2">{
                cm.BinaryData[k] = v
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// SetConfigMapData replaces the ConfigMap's Data map entirely.
func SetConfigMapData(cm *corev1.ConfigMap, data map[string]string) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">cm.Data = data
        return nil</span>
}

// SetConfigMapBinaryData replaces the ConfigMap's BinaryData map entirely.
func SetConfigMapBinaryData(cm *corev1.ConfigMap, data map[string][]byte) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">cm.BinaryData = data
        return nil</span>
}

// SetConfigMapImmutable sets the immutable field for the ConfigMap.
func SetConfigMapImmutable(cm *corev1.ConfigMap, immutable bool) error <span class="cov4" title="2">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov4" title="2">cm.Immutable = &amp;immutable
        return nil</span>
}

// AddConfigMapLabel adds a label to the ConfigMap.
func AddConfigMapLabel(cm *corev1.ConfigMap, key, value string) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">if cm.Labels == nil </span><span class="cov0" title="0">{
                cm.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">cm.Labels[key] = value
        return nil</span>
}

// AddConfigMapAnnotation adds an annotation to the ConfigMap.
func AddConfigMapAnnotation(cm *corev1.ConfigMap, key, value string) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">if cm.Annotations == nil </span><span class="cov0" title="0">{
                cm.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">cm.Annotations[key] = value
        return nil</span>
}

// SetConfigMapLabels replaces all labels on the ConfigMap.
func SetConfigMapLabels(cm *corev1.ConfigMap, labels map[string]string) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">cm.Labels = labels
        return nil</span>
}

// SetConfigMapAnnotations replaces all annotations on the ConfigMap.
func SetConfigMapAnnotations(cm *corev1.ConfigMap, anns map[string]string) error <span class="cov1" title="1">{
        if cm == nil </span><span class="cov0" title="0">{
                return errors.ErrNilConfigMap
        }</span>
        <span class="cov1" title="1">cm.Annotations = anns
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package kubernetes

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"

        "github.com/go-kure/kure/pkg/errors"
)

// CreateContainer returns a Container populated with the provided name, image,
// command and arguments. All collection fields are initialized and basic
// resource requests and limits are set.
func CreateContainer(name string, image string, command []string, args []string) *corev1.Container <span class="cov8" title="3">{
        obj := corev1.Container{
                Name:    name,
                Image:   image,
                Command: command,
                Args:    args,
                Ports:   []corev1.ContainerPort{},
                EnvFrom: []corev1.EnvFromSource{},
                Env:     []corev1.EnvVar{},
                Resources: corev1.ResourceRequirements{
                        Limits: corev1.ResourceList{
                                "memory": resource.MustParse("256Mi"),
                        },
                        Requests: corev1.ResourceList{
                                "cpu":    resource.MustParse("100m"),
                                "memory": resource.MustParse("256Mi"),
                        },
                },
                VolumeMounts:    []corev1.VolumeMount{},
                VolumeDevices:   []corev1.VolumeDevice{},
                ImagePullPolicy: corev1.PullIfNotPresent,
        }
        return &amp;obj
}</span>

// AddContainerPort appends a container port to the Ports slice.
func AddContainerPort(container *corev1.Container, port corev1.ContainerPort) error <span class="cov10" title="4">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov10" title="4">container.Ports = append(container.Ports, port)
        return nil</span>
}

// AddContainerEnv appends an environment variable to the container.
func AddContainerEnv(container *corev1.Container, env corev1.EnvVar) error <span class="cov5" title="2">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov5" title="2">container.Env = append(container.Env, env)
        return nil</span>
}

// AddContainerEnvFrom appends an EnvFromSource entry to the container.
func AddContainerEnvFrom(container *corev1.Container, envFrom corev1.EnvFromSource) error <span class="cov8" title="3">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov8" title="3">container.EnvFrom = append(container.EnvFrom, envFrom)
        return nil</span>
}

// AddContainerVolumeMount appends a volume mount to the container.
func AddContainerVolumeMount(container *corev1.Container, volumeMount corev1.VolumeMount) error <span class="cov1" title="1">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov1" title="1">container.VolumeMounts = append(container.VolumeMounts, volumeMount)
        return nil</span>
}

// AddContainerVolumeDevice appends a volume device to the container.
func AddContainerVolumeDevice(container *corev1.Container, volumeDevice corev1.VolumeDevice) error <span class="cov1" title="1">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov1" title="1">container.VolumeDevices = append(container.VolumeDevices, volumeDevice)
        return nil</span>
}

// SetContainerLivenessProbe sets the container's liveness probe.
func SetContainerLivenessProbe(container *corev1.Container, livenessProbe corev1.Probe) error <span class="cov1" title="1">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov1" title="1">container.LivenessProbe = &amp;livenessProbe
        return nil</span>
}

// SetContainerReadinessProbe sets the container's readiness probe.
func SetContainerReadinessProbe(container *corev1.Container, readinessProbe corev1.Probe) error <span class="cov1" title="1">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov1" title="1">container.ReadinessProbe = &amp;readinessProbe
        return nil</span>
}

// SetContainerStartupProbe sets the container's startup probe.
func SetContainerStartupProbe(container *corev1.Container, startupProbe corev1.Probe) error <span class="cov1" title="1">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov1" title="1">container.StartupProbe = &amp;startupProbe
        return nil</span>
}

// SetContainerResources sets resource requirements on the container.
func SetContainerResources(container *corev1.Container, resources corev1.ResourceRequirements) error <span class="cov1" title="1">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov1" title="1">container.Resources = resources
        return nil</span>
}

// SetContainerImagePullPolicy sets the image pull policy.
func SetContainerImagePullPolicy(container *corev1.Container, imagePullPolicy corev1.PullPolicy) error <span class="cov1" title="1">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov1" title="1">container.ImagePullPolicy = imagePullPolicy
        return nil</span>
}

// SetContainerSecurityContext sets the security context on the container.
func SetContainerSecurityContext(container *corev1.Container, securityContext corev1.SecurityContext) error <span class="cov1" title="1">{
        if container == nil </span><span class="cov0" title="0">{
                return errors.ErrNilContainer
        }</span>
        <span class="cov1" title="1">container.SecurityContext = &amp;securityContext
        return nil</span>
}

func SetContainerWorkingDir(container *corev1.Container, dir string) <span class="cov1" title="1">{
        container.WorkingDir = dir
}</span>

func SetContainerLifecycle(container *corev1.Container, lifecycle *corev1.Lifecycle) <span class="cov1" title="1">{
        container.Lifecycle = lifecycle
}</span>

func SetContainerTerminationMessagePath(container *corev1.Container, path string) <span class="cov1" title="1">{
        container.TerminationMessagePath = path
}</span>

func SetContainerTerminationMessagePolicy(container *corev1.Container, policy corev1.TerminationMessagePolicy) <span class="cov1" title="1">{
        container.TerminationMessagePolicy = policy
}</span>

func SetContainerStdin(container *corev1.Container, stdin bool) <span class="cov1" title="1">{
        container.Stdin = stdin
}</span>

func SetContainerStdinOnce(container *corev1.Container, once bool) <span class="cov1" title="1">{
        container.StdinOnce = once
}</span>

func SetContainerTTY(container *corev1.Container, tty bool) <span class="cov1" title="1">{
        container.TTY = tty
}</span>

// SetContainerImage sets the image on the container.
func SetContainerImage(container *corev1.Container, image string) <span class="cov1" title="1">{
        container.Image = image
}</span>

// SetContainerCommand replaces the command slice on the container.
func SetContainerCommand(container *corev1.Container, command []string) <span class="cov1" title="1">{
        container.Command = command
}</span>

// SetContainerArgs replaces the args slice on the container.
func SetContainerArgs(container *corev1.Container, args []string) <span class="cov1" title="1">{
        container.Args = args
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/pkg/errors"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateDaemonSet returns a DaemonSet with sane defaults.
func CreateDaemonSet(name, namespace string) *appsv1.DaemonSet <span class="cov8" title="4">{
        obj := &amp;appsv1.DaemonSet{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "DaemonSet",
                        APIVersion: appsv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: appsv1.DaemonSetSpec{
                        Selector: &amp;metav1.LabelSelector{MatchLabels: map[string]string{"app": name}},
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"app": name}},
                                Spec:       corev1.PodSpec{},
                        },
                        UpdateStrategy: appsv1.DaemonSetUpdateStrategy{},
                },
        }
        return obj
}</span>

// SetDaemonSetPodSpec assigns a PodSpec to the DaemonSet template.
func SetDaemonSetPodSpec(ds *appsv1.DaemonSet, spec *corev1.PodSpec) error <span class="cov0" title="0">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov0" title="0">if spec == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSpec
        }</span>
        <span class="cov0" title="0">ds.Spec.Template.Spec = *spec
        return nil</span>
}

// AddDaemonSetContainer appends a container to the DaemonSet pod template.
func AddDaemonSetContainer(ds *appsv1.DaemonSet, c *corev1.Container) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecContainer(&amp;ds.Spec.Template.Spec, c)</span>
}

// AddDaemonSetInitContainer appends an init container to the pod template.
func AddDaemonSetInitContainer(ds *appsv1.DaemonSet, c *corev1.Container) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecInitContainer(&amp;ds.Spec.Template.Spec, c)</span>
}

// AddDaemonSetVolume appends a volume to the pod template.
func AddDaemonSetVolume(ds *appsv1.DaemonSet, v *corev1.Volume) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecVolume(&amp;ds.Spec.Template.Spec, v)</span>
}

// AddDaemonSetImagePullSecret appends an image pull secret to the pod template.
func AddDaemonSetImagePullSecret(ds *appsv1.DaemonSet, s *corev1.LocalObjectReference) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecImagePullSecret(&amp;ds.Spec.Template.Spec, s)</span>
}

// AddDaemonSetToleration appends a toleration to the pod template.
func AddDaemonSetToleration(ds *appsv1.DaemonSet, t *corev1.Toleration) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecToleration(&amp;ds.Spec.Template.Spec, t)</span>
}

// AddDaemonSetTopologySpreadConstraints appends a topology spread constraint if not nil.
func AddDaemonSetTopologySpreadConstraints(ds *appsv1.DaemonSet, c *corev1.TopologySpreadConstraint) error <span class="cov10" title="5">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov10" title="5">return AddPodSpecTopologySpreadConstraints(&amp;ds.Spec.Template.Spec, c)</span>
}

// SetDaemonSetServiceAccountName sets the service account name.
func SetDaemonSetServiceAccountName(ds *appsv1.DaemonSet, name string) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">return SetPodSpecServiceAccountName(&amp;ds.Spec.Template.Spec, name)</span>
}

// SetDaemonSetSecurityContext sets the pod security context.
func SetDaemonSetSecurityContext(ds *appsv1.DaemonSet, sc *corev1.PodSecurityContext) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">return SetPodSpecSecurityContext(&amp;ds.Spec.Template.Spec, sc)</span>
}

// SetDaemonSetAffinity sets the pod affinity rules.
func SetDaemonSetAffinity(ds *appsv1.DaemonSet, aff *corev1.Affinity) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">return SetPodSpecAffinity(&amp;ds.Spec.Template.Spec, aff)</span>
}

// SetDaemonSetNodeSelector sets the node selector.
func SetDaemonSetNodeSelector(ds *appsv1.DaemonSet, ns map[string]string) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">return SetPodSpecNodeSelector(&amp;ds.Spec.Template.Spec, ns)</span>
}

// SetDaemonSetUpdateStrategy sets the update strategy.
func SetDaemonSetUpdateStrategy(ds *appsv1.DaemonSet, strat appsv1.DaemonSetUpdateStrategy) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">ds.Spec.UpdateStrategy = strat
        return nil</span>
}

// SetDaemonSetRevisionHistoryLimit sets the revision history limit.
func SetDaemonSetRevisionHistoryLimit(ds *appsv1.DaemonSet, limit *int32) error <span class="cov1" title="1">{
        if ds == nil </span><span class="cov0" title="0">{
                return errors.ErrNilDaemonSet
        }</span>
        <span class="cov1" title="1">ds.Spec.RevisionHistoryLimit = limit
        return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package kubernetes

import (
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "github.com/go-kure/kure/internal/validation"
)

func CreateDeployment(name string, namespace string) *appsv1.Deployment <span class="cov8" title="4">{

        obj := &amp;appsv1.Deployment{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Deployment",
                        APIVersion: appsv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: appsv1.DeploymentSpec{
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: map[string]string{
                                        "app": name,
                                },
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "app": name,
                                        },
                                },
                                Spec: corev1.PodSpec{},
                        },
                },
        }
        return obj
}</span>

// SetDeploymentPodSpec assigns a PodSpec to the Deployment template.
func SetDeploymentPodSpec(dep *appsv1.Deployment, spec *corev1.PodSpec) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(dep); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dep.Spec.Template.Spec = *spec
        return nil</span>
}

func AddDeploymentContainer(deployment *appsv1.Deployment, container *corev1.Container) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecContainer(&amp;deployment.Spec.Template.Spec, container)</span>
}

func AddDeploymentInitContainer(deployment *appsv1.Deployment, container *corev1.Container) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecInitContainer(&amp;deployment.Spec.Template.Spec, container)</span>
}

func AddDeploymentVolume(deployment *appsv1.Deployment, volume *corev1.Volume) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecVolume(&amp;deployment.Spec.Template.Spec, volume)</span>
}

func AddDeploymentImagePullSecret(deployment *appsv1.Deployment, imagePullSecret *corev1.LocalObjectReference) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecImagePullSecret(&amp;deployment.Spec.Template.Spec, imagePullSecret)</span>
}

func AddDeploymentToleration(deployment *appsv1.Deployment, toleration *corev1.Toleration) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecToleration(&amp;deployment.Spec.Template.Spec, toleration)</span>
}

func AddDeploymentTopologySpreadConstraints(deployment *appsv1.Deployment, topologySpreadConstraint *corev1.TopologySpreadConstraint) error <span class="cov10" title="5">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="5">return AddPodSpecTopologySpreadConstraints(&amp;deployment.Spec.Template.Spec, topologySpreadConstraint)</span>
}

func SetDeploymentServiceAccountName(deployment *appsv1.Deployment, serviceAccountName string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecServiceAccountName(&amp;deployment.Spec.Template.Spec, serviceAccountName)</span>
}

func SetDeploymentSecurityContext(deployment *appsv1.Deployment, securityContext *corev1.PodSecurityContext) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecSecurityContext(&amp;deployment.Spec.Template.Spec, securityContext)</span>
}

func SetDeploymentAffinity(deployment *appsv1.Deployment, affinity *corev1.Affinity) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecAffinity(&amp;deployment.Spec.Template.Spec, affinity)</span>
}

func SetDeploymentNodeSelector(deployment *appsv1.Deployment, nodeSelector map[string]string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecNodeSelector(&amp;deployment.Spec.Template.Spec, nodeSelector)</span>
}

// SetDeploymentReplicas sets the desired replica count.
func SetDeploymentReplicas(deployment *appsv1.Deployment, replicas int32) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if deployment.Spec.Replicas == nil </span><span class="cov1" title="1">{
                deployment.Spec.Replicas = new(int32)
        }</span>
        <span class="cov1" title="1">*deployment.Spec.Replicas = replicas
        return nil</span>
}

// SetDeploymentStrategy sets the deployment strategy.
func SetDeploymentStrategy(deployment *appsv1.Deployment, strategy appsv1.DeploymentStrategy) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">deployment.Spec.Strategy = strategy
        return nil</span>
}

// SetDeploymentRevisionHistoryLimit sets the revision history limit.
func SetDeploymentRevisionHistoryLimit(deployment *appsv1.Deployment, limit int32) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">deployment.Spec.RevisionHistoryLimit = &amp;limit
        return nil</span>
}

// SetDeploymentMinReadySeconds sets the minimum ready seconds.
func SetDeploymentMinReadySeconds(deployment *appsv1.Deployment, secs int32) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">deployment.Spec.MinReadySeconds = secs
        return nil</span>
}

// SetDeploymentProgressDeadlineSeconds sets the progress deadline seconds.
func SetDeploymentProgressDeadlineSeconds(deployment *appsv1.Deployment, secs int32) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateDeployment(deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">deployment.Spec.ProgressDeadlineSeconds = &amp;secs
        return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/pkg/errors"

        netv1 "k8s.io/api/networking/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func CreateIngress(name string, namespace string, classname string) *netv1.Ingress <span class="cov8" title="1">{
        obj := &amp;netv1.Ingress{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Ingress",
                        APIVersion: netv1.SchemeGroupVersion.String(),
                },
                Spec: netv1.IngressSpec{
                        IngressClassName: &amp;classname,
                        Rules:            []netv1.IngressRule{},
                        TLS:              []netv1.IngressTLS{},
                },
        }
        return obj
}</span>

func CreateIngressRule(host string) *netv1.IngressRule <span class="cov8" title="1">{
        return &amp;netv1.IngressRule{
                Host: host,
                IngressRuleValue: netv1.IngressRuleValue{
                        HTTP: &amp;netv1.HTTPIngressRuleValue{
                                Paths: []netv1.HTTPIngressPath{},
                        },
                },
        }
}</span>
func CreateIngressPath(path string, pathType *netv1.PathType, servicename string, serviceportname string) netv1.HTTPIngressPath <span class="cov8" title="1">{
        return netv1.HTTPIngressPath{
                Path:     path,
                PathType: pathType,
                Backend: netv1.IngressBackend{
                        Service: &amp;netv1.IngressServiceBackend{
                                Name: servicename,
                                Port: netv1.ServiceBackendPort{
                                        Name: serviceportname,
                                },
                        },
                },
        }
}</span>
func AddIngressRule(ingress *netv1.Ingress, rule *netv1.IngressRule) <span class="cov8" title="1">{
        ingress.Spec.Rules = append(ingress.Spec.Rules, *rule)
}</span>
func AddIngressRulePath(rule *netv1.IngressRule, path netv1.HTTPIngressPath) <span class="cov8" title="1">{
        if rule.IngressRuleValue.HTTP == nil </span><span class="cov0" title="0">{
                rule.IngressRuleValue.HTTP = &amp;netv1.HTTPIngressRuleValue{}
        }</span>
        <span class="cov8" title="1">rule.IngressRuleValue.HTTP.Paths = append(rule.IngressRuleValue.HTTP.Paths, path)</span>
}

func AddIngressTLS(ingress *netv1.Ingress, tls netv1.IngressTLS) <span class="cov8" title="1">{
        ingress.Spec.TLS = append(ingress.Spec.TLS, tls)
}</span>

func SetIngressDefaultBackend(ingress *netv1.Ingress, backend netv1.IngressBackend) <span class="cov8" title="1">{
        ingress.Spec.DefaultBackend = &amp;backend
}</span>

func SetIngressClassName(ingress *netv1.Ingress, class string) error <span class="cov8" title="1">{
        if ingress == nil </span><span class="cov0" title="0">{
                return errors.ErrNilIngress
        }</span>
        <span class="cov8" title="1">ingress.Spec.IngressClassName = &amp;class
        return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/pkg/errors"

        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func CreateJob(name, namespace string) *batchv1.Job <span class="cov10" title="2">{
        obj := &amp;batchv1.Job{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Job",
                        APIVersion: batchv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: batchv1.JobSpec{
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "app": name,
                                        },
                                },
                                Spec: corev1.PodSpec{},
                        },
                },
        }
        return obj
}</span>

// SetJobPodSpec assigns a PodSpec to the Job template.
func SetJobPodSpec(job *batchv1.Job, spec *corev1.PodSpec) error <span class="cov0" title="0">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov0" title="0">if spec == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSpec
        }</span>
        <span class="cov0" title="0">job.Spec.Template.Spec = *spec
        return nil</span>
}

func AddJobContainer(job *batchv1.Job, container *corev1.Container) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecContainer(&amp;job.Spec.Template.Spec, container)</span>
}

func AddJobInitContainer(job *batchv1.Job, container *corev1.Container) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecInitContainer(&amp;job.Spec.Template.Spec, container)</span>
}

func AddJobVolume(job *batchv1.Job, volume *corev1.Volume) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecVolume(&amp;job.Spec.Template.Spec, volume)</span>
}

func AddJobImagePullSecret(job *batchv1.Job, secret *corev1.LocalObjectReference) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecImagePullSecret(&amp;job.Spec.Template.Spec, secret)</span>
}

func AddJobToleration(job *batchv1.Job, toleration *corev1.Toleration) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecToleration(&amp;job.Spec.Template.Spec, toleration)</span>
}

func AddJobTopologySpreadConstraint(job *batchv1.Job, constraint *corev1.TopologySpreadConstraint) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecTopologySpreadConstraints(&amp;job.Spec.Template.Spec, constraint)</span>
}

func SetJobServiceAccountName(job *batchv1.Job, name string) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return SetPodSpecServiceAccountName(&amp;job.Spec.Template.Spec, name)</span>
}

func SetJobSecurityContext(job *batchv1.Job, sc *corev1.PodSecurityContext) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return SetPodSpecSecurityContext(&amp;job.Spec.Template.Spec, sc)</span>
}

func SetJobAffinity(job *batchv1.Job, aff *corev1.Affinity) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return SetPodSpecAffinity(&amp;job.Spec.Template.Spec, aff)</span>
}

func SetJobNodeSelector(job *batchv1.Job, selector map[string]string) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">return SetPodSpecNodeSelector(&amp;job.Spec.Template.Spec, selector)</span>
}

func SetJobCompletions(job *batchv1.Job, completions int32) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">job.Spec.Completions = &amp;completions
        return nil</span>
}

func SetJobParallelism(job *batchv1.Job, parallelism int32) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">job.Spec.Parallelism = &amp;parallelism
        return nil</span>
}

func SetJobBackoffLimit(job *batchv1.Job, limit int32) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">job.Spec.BackoffLimit = &amp;limit
        return nil</span>
}

func SetJobTTLSecondsAfterFinished(job *batchv1.Job, ttl int32) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">job.Spec.TTLSecondsAfterFinished = &amp;ttl
        return nil</span>
}

// SetJobActiveDeadlineSeconds sets the active deadline seconds for the job.
func SetJobActiveDeadlineSeconds(job *batchv1.Job, secs *int64) error <span class="cov1" title="1">{
        if job == nil </span><span class="cov0" title="0">{
                return errors.ErrNilJob
        }</span>
        <span class="cov1" title="1">job.Spec.ActiveDeadlineSeconds = secs
        return nil</span>
}

func CreateCronJob(name, namespace, schedule string) *batchv1.CronJob <span class="cov10" title="2">{
        obj := &amp;batchv1.CronJob{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "CronJob",
                        APIVersion: batchv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: batchv1.CronJobSpec{
                        Schedule: schedule,
                        JobTemplate: batchv1.JobTemplateSpec{
                                Spec: batchv1.JobSpec{
                                        Template: corev1.PodTemplateSpec{
                                                ObjectMeta: metav1.ObjectMeta{
                                                        Labels: map[string]string{
                                                                "app": name,
                                                        },
                                                },
                                                Spec: corev1.PodSpec{},
                                        },
                                },
                        },
                },
        }
        return obj
}</span>

// SetCronJobPodSpec assigns a PodSpec to the CronJob template.
func SetCronJobPodSpec(cron *batchv1.CronJob, spec *corev1.PodSpec) error <span class="cov0" title="0">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov0" title="0">if spec == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSpec
        }</span>
        <span class="cov0" title="0">cron.Spec.JobTemplate.Spec.Template.Spec = *spec
        return nil</span>
}

func AddCronJobContainer(cron *batchv1.CronJob, container *corev1.Container) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecContainer(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, container)</span>
}

func AddCronJobInitContainer(cron *batchv1.CronJob, container *corev1.Container) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecInitContainer(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, container)</span>
}

func AddCronJobVolume(cron *batchv1.CronJob, volume *corev1.Volume) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecVolume(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, volume)</span>
}

func AddCronJobImagePullSecret(cron *batchv1.CronJob, secret *corev1.LocalObjectReference) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecImagePullSecret(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, secret)</span>
}

func AddCronJobToleration(cron *batchv1.CronJob, toleration *corev1.Toleration) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecToleration(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, toleration)</span>
}

func AddCronJobTopologySpreadConstraint(cron *batchv1.CronJob, constraint *corev1.TopologySpreadConstraint) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return AddPodSpecTopologySpreadConstraints(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, constraint)</span>
}

func SetCronJobServiceAccountName(cron *batchv1.CronJob, name string) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return SetPodSpecServiceAccountName(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, name)</span>
}

func SetCronJobSecurityContext(cron *batchv1.CronJob, sc *corev1.PodSecurityContext) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return SetPodSpecSecurityContext(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, sc)</span>
}

func SetCronJobAffinity(cron *batchv1.CronJob, aff *corev1.Affinity) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return SetPodSpecAffinity(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, aff)</span>
}

func SetCronJobNodeSelector(cron *batchv1.CronJob, selector map[string]string) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">return SetPodSpecNodeSelector(&amp;cron.Spec.JobTemplate.Spec.Template.Spec, selector)</span>
}

func SetCronJobSchedule(cron *batchv1.CronJob, schedule string) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">cron.Spec.Schedule = schedule
        return nil</span>
}

func SetCronJobConcurrencyPolicy(cron *batchv1.CronJob, policy batchv1.ConcurrencyPolicy) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">cron.Spec.ConcurrencyPolicy = policy
        return nil</span>
}

func SetCronJobSuspend(cron *batchv1.CronJob, suspend bool) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">cron.Spec.Suspend = &amp;suspend
        return nil</span>
}

func SetCronJobSuccessfulJobsHistoryLimit(cron *batchv1.CronJob, limit int32) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">cron.Spec.SuccessfulJobsHistoryLimit = &amp;limit
        return nil</span>
}

func SetCronJobFailedJobsHistoryLimit(cron *batchv1.CronJob, limit int32) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">cron.Spec.FailedJobsHistoryLimit = &amp;limit
        return nil</span>
}

func SetCronJobStartingDeadlineSeconds(cron *batchv1.CronJob, sec int64) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">cron.Spec.StartingDeadlineSeconds = &amp;sec
        return nil</span>
}

// SetCronJobTimeZone sets the time zone field.
func SetCronJobTimeZone(cron *batchv1.CronJob, tz *string) error <span class="cov1" title="1">{
        if cron == nil </span><span class="cov0" title="0">{
                return errors.ErrNilCronJob
        }</span>
        <span class="cov1" title="1">cron.Spec.TimeZone = tz
        return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/internal/validation"

        "sigs.k8s.io/kustomize/api/types"
        "sigs.k8s.io/yaml"
)

// CreateKustomizationFile returns a types.Kustomization with
// apiVersion and kind set to the values used by the kustomize project.
// All list fields are initialized so entries can be appended safely.
func CreateKustomizationFile() *types.Kustomization <span class="cov10" title="2">{
        obj := &amp;types.Kustomization{
                TypeMeta: types.TypeMeta{
                        Kind:       types.KustomizationKind,
                        APIVersion: types.KustomizationVersion,
                },
                Resources:  []string{},
                Components: []string{},
                Crds:       []string{},
                Patches:    []types.Patch{},
                Images:     []types.Image{},
        }
        return obj
}</span>

// AddKustomizationResource appends a resource path to the kustomization.
func AddKustomizationResource(k *types.Kustomization, path string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateKustomization(k); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">k.Resources = append(k.Resources, path)
        return nil</span>
}

// AddKustomizationComponent appends a component path to the kustomization.
func AddKustomizationComponent(k *types.Kustomization, path string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateKustomization(k); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">k.Components = append(k.Components, path)
        return nil</span>
}

// AddKustomizationCRD appends a CRD path to the kustomization.
func AddKustomizationCRD(k *types.Kustomization, path string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateKustomization(k); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">k.Crds = append(k.Crds, path)
        return nil</span>
}

// AddKustomizationImage appends an image transformer entry.
func AddKustomizationImage(k *types.Kustomization, img types.Image) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateKustomization(k); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">k.Images = append(k.Images, img)
        return nil</span>
}

// AddKustomizationPatch appends a patch entry.
func AddKustomizationPatch(k *types.Kustomization, p types.Patch) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateKustomization(k); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">k.Patches = append(k.Patches, p)
        return nil</span>
}

// SetKustomizationNamespace sets the namespace for all resources.
func SetKustomizationNamespace(k *types.Kustomization, ns string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateKustomization(k); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">k.Namespace = ns
        return nil</span>
}

// MarshalKustomization returns the YAML encoding of the kustomization object.
func MarshalKustomization(k *types.Kustomization) ([]byte, error) <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidateKustomization(k); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return yaml.Marshal(k)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package kubernetes

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func CreateNamespace(name string) *corev1.Namespace <span class="cov10" title="4">{
        obj := &amp;corev1.Namespace{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Namespace",
                        APIVersion: corev1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: corev1.NamespaceSpec{
                        Finalizers: []corev1.FinalizerName{},
                },
        }
        return obj
}</span>

func AddNamespaceLabel(ns *corev1.Namespace, key, value string) <span class="cov1" title="1">{
        if ns.Labels == nil </span><span class="cov0" title="0">{
                ns.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">ns.Labels[key] = value</span>
}

func AddNamespaceAnnotation(ns *corev1.Namespace, key, value string) <span class="cov1" title="1">{
        if ns.Annotations == nil </span><span class="cov0" title="0">{
                ns.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">ns.Annotations[key] = value</span>
}

func AddNamespaceFinalizer(ns *corev1.Namespace, finalizer corev1.FinalizerName) <span class="cov1" title="1">{
        ns.Spec.Finalizers = append(ns.Spec.Finalizers, finalizer)
}</span>

func SetNamespaceLabels(ns *corev1.Namespace, labels map[string]string) <span class="cov1" title="1">{
        ns.Labels = labels
}</span>

func SetNamespaceAnnotations(ns *corev1.Namespace, annotations map[string]string) <span class="cov1" title="1">{
        ns.Annotations = annotations
}</span>

func SetNamespaceFinalizers(ns *corev1.Namespace, finalizers []corev1.FinalizerName) <span class="cov1" title="1">{
        ns.Spec.Finalizers = finalizers
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package kubernetes

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreatePersistentVolumeClaim returns a PersistentVolumeClaim object with sane defaults.
func CreatePersistentVolumeClaim(name string, namespace string) *corev1.PersistentVolumeClaim <span class="cov10" title="3">{
        mode := corev1.PersistentVolumeFilesystem
        obj := &amp;corev1.PersistentVolumeClaim{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "PersistentVolumeClaim",
                        APIVersion: corev1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: corev1.PersistentVolumeClaimSpec{
                        AccessModes: []corev1.PersistentVolumeAccessMode{},
                        Resources: corev1.VolumeResourceRequirements{
                                Requests: corev1.ResourceList{
                                        corev1.ResourceStorage: resource.MustParse("1Gi"),
                                },
                        },
                        VolumeMode: &amp;mode,
                },
        }
        return obj
}</span>

// AddPVCAccessMode appends an access mode to the claim.
func AddPVCAccessMode(pvc *corev1.PersistentVolumeClaim, mode corev1.PersistentVolumeAccessMode) <span class="cov1" title="1">{
        pvc.Spec.AccessModes = append(pvc.Spec.AccessModes, mode)
}</span>

// SetPVCStorageClassName sets the storage class name for the claim.
func SetPVCStorageClassName(pvc *corev1.PersistentVolumeClaim, class string) <span class="cov1" title="1">{
        pvc.Spec.StorageClassName = &amp;class
}</span>

// SetPVCVolumeMode sets the volume mode of the claim.
func SetPVCVolumeMode(pvc *corev1.PersistentVolumeClaim, mode corev1.PersistentVolumeMode) <span class="cov1" title="1">{
        pvc.Spec.VolumeMode = &amp;mode
}</span>

// SetPVCResources sets the resource requirements for the claim.
func SetPVCResources(pvc *corev1.PersistentVolumeClaim, resources corev1.VolumeResourceRequirements) <span class="cov1" title="1">{
        pvc.Spec.Resources = resources
}</span>

// SetPVCSelector sets the selector for the claim.
func SetPVCSelector(pvc *corev1.PersistentVolumeClaim, selector *metav1.LabelSelector) <span class="cov1" title="1">{
        pvc.Spec.Selector = selector
}</span>

// SetPVCVolumeName sets the bound volume name for the claim.
func SetPVCVolumeName(pvc *corev1.PersistentVolumeClaim, volumeName string) <span class="cov1" title="1">{
        pvc.Spec.VolumeName = volumeName
}</span>

// SetPVCDataSource sets the data source for the claim.
func SetPVCDataSource(pvc *corev1.PersistentVolumeClaim, src *corev1.TypedLocalObjectReference) <span class="cov1" title="1">{
        pvc.Spec.DataSource = src
}</span>

// SetPVCDataSourceRef sets the data source reference for the claim.
func SetPVCDataSourceRef(pvc *corev1.PersistentVolumeClaim, src *corev1.TypedObjectReference) <span class="cov1" title="1">{
        pvc.Spec.DataSourceRef = src
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/internal/validation"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreatePod returns a Pod with the provided name and namespace. The object is
// populated with sensible defaults for metadata and spec fields.
func CreatePod(name string, namespace string) *corev1.Pod <span class="cov10" title="3">{
        obj := corev1.Pod{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "v1",
                        Kind:       "Pod",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: corev1.PodSpec{},
        }
        return &amp;obj
}</span>

// SetPodSpec assigns a pod spec to the Pod.
func SetPodSpec(pod *corev1.Pod, spec *corev1.PodSpec) error <span class="cov0" title="0">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">pod.Spec = *spec
        return nil</span>
}

// AddPodContainer appends a container to the Pod spec.
func AddPodContainer(pod *corev1.Pod, container *corev1.Container) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecContainer(&amp;pod.Spec, container)</span>
}

// AddPodInitContainer appends an init container to the Pod spec.
func AddPodInitContainer(pod *corev1.Pod, container *corev1.Container) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecInitContainer(&amp;pod.Spec, container)</span>
}

// AddPodEphemeralContainer appends an ephemeral container to the Pod spec.
func AddPodEphemeralContainer(pod *corev1.Pod, container *corev1.EphemeralContainer) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecEphemeralContainer(&amp;pod.Spec, container)</span>
}

// AddPodVolume appends a volume to the Pod spec.
func AddPodVolume(pod *corev1.Pod, volume *corev1.Volume) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecVolume(&amp;pod.Spec, volume)</span>
}

// AddPodImagePullSecret appends an image pull secret to the Pod spec.
func AddPodImagePullSecret(pod *corev1.Pod, imagePullSecret *corev1.LocalObjectReference) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecImagePullSecret(&amp;pod.Spec, imagePullSecret)</span>
}

// AddPodToleration appends a toleration to the Pod spec.
func AddPodToleration(pod *corev1.Pod, toleration *corev1.Toleration) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecToleration(&amp;pod.Spec, toleration)</span>
}

// AddPodTopologySpreadConstraints appends a topology spread constraint if provided.
func AddPodTopologySpreadConstraints(pod *corev1.Pod, topologySpreadConstraint *corev1.TopologySpreadConstraint) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return AddPodSpecTopologySpreadConstraints(&amp;pod.Spec, topologySpreadConstraint)</span>
}

// SetPodServiceAccountName sets the service account used by the Pod.
func SetPodServiceAccountName(pod *corev1.Pod, serviceAccountName string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecServiceAccountName(&amp;pod.Spec, serviceAccountName)</span>
}

// SetPodSecurityContext sets the pod-level security context.
func SetPodSecurityContext(pod *corev1.Pod, securityContext *corev1.PodSecurityContext) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecSecurityContext(&amp;pod.Spec, securityContext)</span>
}

// SetPodAffinity assigns affinity rules to the Pod.
func SetPodAffinity(pod *corev1.Pod, affinity *corev1.Affinity) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecAffinity(&amp;pod.Spec, affinity)</span>
}

// SetPodNodeSelector sets the node selector map.
func SetPodNodeSelector(pod *corev1.Pod, nodeSelector map[string]string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecNodeSelector(&amp;pod.Spec, nodeSelector)</span>
}

// SetPodPriorityClassName sets the priority class name.
func SetPodPriorityClassName(pod *corev1.Pod, class string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecPriorityClassName(&amp;pod.Spec, class)</span>
}

// SetPodHostNetwork configures host networking for the Pod.
func SetPodHostNetwork(pod *corev1.Pod, hostNetwork bool) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecHostNetwork(&amp;pod.Spec, hostNetwork)</span>
}

// SetPodHostPID configures host PID namespace usage for the Pod.
func SetPodHostPID(pod *corev1.Pod, hostPID bool) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecHostPID(&amp;pod.Spec, hostPID)</span>
}

// SetPodHostIPC configures host IPC namespace usage for the Pod.
func SetPodHostIPC(pod *corev1.Pod, hostIPC bool) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecHostIPC(&amp;pod.Spec, hostIPC)</span>
}

// SetPodDNSPolicy sets the DNS policy for the Pod.
func SetPodDNSPolicy(pod *corev1.Pod, policy corev1.DNSPolicy) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecDNSPolicy(&amp;pod.Spec, policy)</span>
}

func SetPodDNSConfig(pod *corev1.Pod, dnsConfig *corev1.PodDNSConfig) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecDNSConfig(&amp;pod.Spec, dnsConfig)</span>
}

func SetPodHostname(pod *corev1.Pod, hostname string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecHostname(&amp;pod.Spec, hostname)</span>
}

func SetPodSubdomain(pod *corev1.Pod, subdomain string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecSubdomain(&amp;pod.Spec, subdomain)</span>
}

func SetPodRestartPolicy(pod *corev1.Pod, policy corev1.RestartPolicy) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecRestartPolicy(&amp;pod.Spec, policy)</span>
}

func SetPodTerminationGracePeriod(pod *corev1.Pod, secs int64) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecTerminationGracePeriod(&amp;pod.Spec, secs)</span>
}

func SetPodSchedulerName(pod *corev1.Pod, scheduler string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidatePod(pod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return SetPodSpecSchedulerName(&amp;pod.Spec, scheduler)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package kubernetes

import (
        corev1 "k8s.io/api/core/v1"

        "github.com/go-kure/kure/internal/validation"
)

// CreatePodSpec returns a PodSpec initialized with sensible defaults.
func CreatePodSpec() *corev1.PodSpec <span class="cov3" title="2">{
        obj := corev1.PodSpec{
                Containers:                    []corev1.Container{},
                InitContainers:                []corev1.Container{},
                Volumes:                       []corev1.Volume{},
                RestartPolicy:                 corev1.RestartPolicyAlways,
                TerminationGracePeriodSeconds: new(int64),
                SecurityContext:               &amp;corev1.PodSecurityContext{},
                ImagePullSecrets:              []corev1.LocalObjectReference{},
                ServiceAccountName:            "",
                NodeSelector:                  map[string]string{},
                Affinity:                      &amp;corev1.Affinity{},
                Tolerations:                   []corev1.Toleration{},
        }
        return &amp;obj
}</span>

// AddPodSpecContainer appends a container to the PodSpec.
func AddPodSpecContainer(spec *corev1.PodSpec, container *corev1.Container) error <span class="cov6" title="7">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">if err := validator.ValidateContainer(container); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">spec.Containers = append(spec.Containers, *container)
        return nil</span>
}

// AddPodSpecInitContainer appends an init container to the PodSpec.
func AddPodSpecInitContainer(spec *corev1.PodSpec, container *corev1.Container) error <span class="cov6" title="7">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">if err := validator.ValidateInitContainer(container); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">spec.InitContainers = append(spec.InitContainers, *container)
        return nil</span>
}

// AddPodSpecEphemeralContainer appends an ephemeral container to the PodSpec.
func AddPodSpecEphemeralContainer(spec *corev1.PodSpec, container *corev1.EphemeralContainer) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">if err := validator.ValidateEphemeralContainer(container); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.EphemeralContainers = append(spec.EphemeralContainers, *container)
        return nil</span>
}

// AddPodSpecVolume appends a volume to the PodSpec.
func AddPodSpecVolume(spec *corev1.PodSpec, volume *corev1.Volume) error <span class="cov6" title="7">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">if err := validator.ValidateVolume(volume); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">spec.Volumes = append(spec.Volumes, *volume)
        return nil</span>
}

// AddPodSpecImagePullSecret appends an image pull secret to the PodSpec.
func AddPodSpecImagePullSecret(spec *corev1.PodSpec, secret *corev1.LocalObjectReference) error <span class="cov6" title="7">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">if err := validator.ValidateImagePullSecret(secret); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">spec.ImagePullSecrets = append(spec.ImagePullSecrets, *secret)
        return nil</span>
}

// AddPodSpecToleration appends a toleration to the PodSpec.
func AddPodSpecToleration(spec *corev1.PodSpec, toleration *corev1.Toleration) error <span class="cov6" title="7">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">if err := validator.ValidateToleration(toleration); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">spec.Tolerations = append(spec.Tolerations, *toleration)
        return nil</span>
}

// AddPodSpecTopologySpreadConstraints appends a topology spread constraint if provided.
func AddPodSpecTopologySpreadConstraints(spec *corev1.PodSpec, constraint *corev1.TopologySpreadConstraint) error <span class="cov10" title="19">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="19">if constraint == nil </span><span class="cov4" title="3">{
                return nil
        }</span>
        <span class="cov9" title="16">spec.TopologySpreadConstraints = append(spec.TopologySpreadConstraints, *constraint)
        return nil</span>
}

// SetPodSpecServiceAccountName sets the service account name.
func SetPodSpecServiceAccountName(spec *corev1.PodSpec, name string) error <span class="cov6" title="7">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">spec.ServiceAccountName = name
        return nil</span>
}

// SetPodSpecSecurityContext sets the security context for the PodSpec.
func SetPodSpecSecurityContext(spec *corev1.PodSpec, sc *corev1.PodSecurityContext) error <span class="cov6" title="7">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">spec.SecurityContext = sc
        return nil</span>
}

// SetPodSpecAffinity assigns affinity rules to the PodSpec.
func SetPodSpecAffinity(spec *corev1.PodSpec, aff *corev1.Affinity) error <span class="cov6" title="7">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">spec.Affinity = aff
        return nil</span>
}

// SetPodSpecNodeSelector sets the node selector map.
func SetPodSpecNodeSelector(spec *corev1.PodSpec, selector map[string]string) error <span class="cov6" title="7">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">spec.NodeSelector = selector
        return nil</span>
}

// SetPodSpecPriorityClassName sets the priority class name.
func SetPodSpecPriorityClassName(spec *corev1.PodSpec, class string) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.PriorityClassName = class
        return nil</span>
}

// SetPodSpecHostNetwork configures host networking.
func SetPodSpecHostNetwork(spec *corev1.PodSpec, hostNetwork bool) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.HostNetwork = hostNetwork
        return nil</span>
}

// SetPodSpecHostPID configures host PID namespace usage.
func SetPodSpecHostPID(spec *corev1.PodSpec, hostPID bool) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.HostPID = hostPID
        return nil</span>
}

// SetPodSpecHostIPC configures host IPC namespace usage.
func SetPodSpecHostIPC(spec *corev1.PodSpec, hostIPC bool) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.HostIPC = hostIPC
        return nil</span>
}

// SetPodSpecDNSPolicy sets the DNS policy.
func SetPodSpecDNSPolicy(spec *corev1.PodSpec, policy corev1.DNSPolicy) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.DNSPolicy = policy
        return nil</span>
}

// SetPodSpecDNSConfig sets the DNS config.
func SetPodSpecDNSConfig(spec *corev1.PodSpec, cfg *corev1.PodDNSConfig) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.DNSConfig = cfg
        return nil</span>
}

// SetPodSpecHostname sets the hostname.
func SetPodSpecHostname(spec *corev1.PodSpec, hostname string) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.Hostname = hostname
        return nil</span>
}

// SetPodSpecSubdomain sets the subdomain.
func SetPodSpecSubdomain(spec *corev1.PodSpec, subdomain string) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.Subdomain = subdomain
        return nil</span>
}

// SetPodSpecRestartPolicy sets the restart policy.
func SetPodSpecRestartPolicy(spec *corev1.PodSpec, policy corev1.RestartPolicy) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.RestartPolicy = policy
        return nil</span>
}

// SetPodSpecTerminationGracePeriod sets the termination grace period seconds.
func SetPodSpecTerminationGracePeriod(spec *corev1.PodSpec, secs int64) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">if spec.TerminationGracePeriodSeconds == nil </span><span class="cov1" title="1">{
                spec.TerminationGracePeriodSeconds = new(int64)
        }</span>
        <span class="cov3" title="2">*spec.TerminationGracePeriodSeconds = secs
        return nil</span>
}

// SetPodSpecSchedulerName sets the scheduler name.
func SetPodSpecSchedulerName(spec *corev1.PodSpec, scheduler string) error <span class="cov3" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidatePodSpec(spec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">spec.SchedulerName = scheduler
        return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package kubernetes

import (
        corev1 "k8s.io/api/core/v1"
        netv1 "k8s.io/api/networking/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NetworkPolicy helpers

// CreateNetworkPolicy returns a basic NetworkPolicy object with default labels
// and empty rule slices.
func CreateNetworkPolicy(name, namespace string) *netv1.NetworkPolicy <span class="cov8" title="1">{
        obj := &amp;netv1.NetworkPolicy{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "NetworkPolicy",
                        APIVersion: netv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: netv1.NetworkPolicySpec{
                        PodSelector: metav1.LabelSelector{MatchLabels: map[string]string{"app": name}},
                        PolicyTypes: []netv1.PolicyType{},
                        Ingress:     []netv1.NetworkPolicyIngressRule{},
                        Egress:      []netv1.NetworkPolicyEgressRule{},
                },
        }
        return obj
}</span>

func SetNetworkPolicyPodSelector(np *netv1.NetworkPolicy, selector metav1.LabelSelector) <span class="cov0" title="0">{
        np.Spec.PodSelector = selector
}</span>

func AddNetworkPolicyPolicyType(np *netv1.NetworkPolicy, t netv1.PolicyType) <span class="cov8" title="1">{
        np.Spec.PolicyTypes = append(np.Spec.PolicyTypes, t)
}</span>

func SetNetworkPolicyPolicyTypes(np *netv1.NetworkPolicy, types []netv1.PolicyType) <span class="cov0" title="0">{
        np.Spec.PolicyTypes = types
}</span>

func AddNetworkPolicyIngressRule(np *netv1.NetworkPolicy, rule netv1.NetworkPolicyIngressRule) <span class="cov8" title="1">{
        np.Spec.Ingress = append(np.Spec.Ingress, rule)
}</span>

func SetNetworkPolicyIngressRules(np *netv1.NetworkPolicy, rules []netv1.NetworkPolicyIngressRule) <span class="cov0" title="0">{
        np.Spec.Ingress = rules
}</span>

func AddNetworkPolicyEgressRule(np *netv1.NetworkPolicy, rule netv1.NetworkPolicyEgressRule) <span class="cov0" title="0">{
        np.Spec.Egress = append(np.Spec.Egress, rule)
}</span>

func SetNetworkPolicyEgressRules(np *netv1.NetworkPolicy, rules []netv1.NetworkPolicyEgressRule) <span class="cov0" title="0">{
        np.Spec.Egress = rules
}</span>

func AddNetworkPolicyIngressPeer(rule *netv1.NetworkPolicyIngressRule, peer netv1.NetworkPolicyPeer) <span class="cov8" title="1">{
        rule.From = append(rule.From, peer)
}</span>

func SetNetworkPolicyIngressPeers(rule *netv1.NetworkPolicyIngressRule, peers []netv1.NetworkPolicyPeer) <span class="cov0" title="0">{
        rule.From = peers
}</span>

func AddNetworkPolicyIngressPort(rule *netv1.NetworkPolicyIngressRule, port netv1.NetworkPolicyPort) <span class="cov8" title="1">{
        rule.Ports = append(rule.Ports, port)
}</span>

func SetNetworkPolicyIngressPorts(rule *netv1.NetworkPolicyIngressRule, ports []netv1.NetworkPolicyPort) <span class="cov0" title="0">{
        rule.Ports = ports
}</span>

func AddNetworkPolicyEgressPeer(rule *netv1.NetworkPolicyEgressRule, peer netv1.NetworkPolicyPeer) <span class="cov0" title="0">{
        rule.To = append(rule.To, peer)
}</span>

func SetNetworkPolicyEgressPeers(rule *netv1.NetworkPolicyEgressRule, peers []netv1.NetworkPolicyPeer) <span class="cov0" title="0">{
        rule.To = peers
}</span>

func AddNetworkPolicyEgressPort(rule *netv1.NetworkPolicyEgressRule, port netv1.NetworkPolicyPort) <span class="cov0" title="0">{
        rule.Ports = append(rule.Ports, port)
}</span>

func SetNetworkPolicyEgressPorts(rule *netv1.NetworkPolicyEgressRule, ports []netv1.NetworkPolicyPort) <span class="cov0" title="0">{
        rule.Ports = ports
}</span>

// ResourceQuota helpers

// CreateResourceQuota creates a new ResourceQuota object with default metadata.
func CreateResourceQuota(name, namespace string) *corev1.ResourceQuota <span class="cov8" title="1">{
        obj := &amp;corev1.ResourceQuota{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ResourceQuota",
                        APIVersion: corev1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: corev1.ResourceQuotaSpec{
                        Hard:   corev1.ResourceList{},
                        Scopes: []corev1.ResourceQuotaScope{},
                },
        }
        return obj
}</span>

func AddResourceQuotaScope(rq *corev1.ResourceQuota, scope corev1.ResourceQuotaScope) <span class="cov8" title="1">{
        rq.Spec.Scopes = append(rq.Spec.Scopes, scope)
}</span>

func SetResourceQuotaScopes(rq *corev1.ResourceQuota, scopes []corev1.ResourceQuotaScope) <span class="cov0" title="0">{
        rq.Spec.Scopes = scopes
}</span>

func SetResourceQuotaHard(rq *corev1.ResourceQuota, hard corev1.ResourceList) <span class="cov0" title="0">{
        rq.Spec.Hard = hard
}</span>

func AddResourceQuotaHard(rq *corev1.ResourceQuota, name corev1.ResourceName, qty resource.Quantity) <span class="cov8" title="1">{
        if rq.Spec.Hard == nil </span><span class="cov0" title="0">{
                rq.Spec.Hard = make(corev1.ResourceList)
        }</span>
        <span class="cov8" title="1">rq.Spec.Hard[name] = qty</span>
}

func SetResourceQuotaScopeSelector(rq *corev1.ResourceQuota, selector *corev1.ScopeSelector) <span class="cov8" title="1">{
        rq.Spec.ScopeSelector = selector
}</span>

func AddScopeSelectorExpression(selector *corev1.ScopeSelector, req corev1.ScopedResourceSelectorRequirement) <span class="cov8" title="1">{
        if selector.MatchExpressions == nil </span><span class="cov8" title="1">{
                selector.MatchExpressions = []corev1.ScopedResourceSelectorRequirement{}
        }</span>
        <span class="cov8" title="1">selector.MatchExpressions = append(selector.MatchExpressions, req)</span>
}

func SetScopeSelectorExpressions(selector *corev1.ScopeSelector, reqs []corev1.ScopedResourceSelectorRequirement) <span class="cov0" title="0">{
        selector.MatchExpressions = reqs
}</span>

// LimitRange helpers

// CreateLimitRange returns a basic LimitRange object with empty limits list.
func CreateLimitRange(name, namespace string) *corev1.LimitRange <span class="cov8" title="1">{
        obj := &amp;corev1.LimitRange{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "LimitRange",
                        APIVersion: corev1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: corev1.LimitRangeSpec{
                        Limits: []corev1.LimitRangeItem{},
                },
        }
        return obj
}</span>

func AddLimitRangeItem(lr *corev1.LimitRange, item corev1.LimitRangeItem) <span class="cov8" title="1">{
        lr.Spec.Limits = append(lr.Spec.Limits, item)
}</span>

func SetLimitRangeItems(lr *corev1.LimitRange, items []corev1.LimitRangeItem) <span class="cov0" title="0">{
        lr.Spec.Limits = items
}</span>

func AddLimitRangeItemMax(item *corev1.LimitRangeItem, name corev1.ResourceName, qty resource.Quantity) <span class="cov8" title="1">{
        if item.Max == nil </span><span class="cov8" title="1">{
                item.Max = make(corev1.ResourceList)
        }</span>
        <span class="cov8" title="1">item.Max[name] = qty</span>
}

func AddLimitRangeItemMin(item *corev1.LimitRangeItem, name corev1.ResourceName, qty resource.Quantity) <span class="cov0" title="0">{
        if item.Min == nil </span><span class="cov0" title="0">{
                item.Min = make(corev1.ResourceList)
        }</span>
        <span class="cov0" title="0">item.Min[name] = qty</span>
}

func AddLimitRangeItemDefault(item *corev1.LimitRangeItem, name corev1.ResourceName, qty resource.Quantity) <span class="cov0" title="0">{
        if item.Default == nil </span><span class="cov0" title="0">{
                item.Default = make(corev1.ResourceList)
        }</span>
        <span class="cov0" title="0">item.Default[name] = qty</span>
}

func AddLimitRangeItemDefaultRequest(item *corev1.LimitRangeItem, name corev1.ResourceName, qty resource.Quantity) <span class="cov0" title="0">{
        if item.DefaultRequest == nil </span><span class="cov0" title="0">{
                item.DefaultRequest = make(corev1.ResourceList)
        }</span>
        <span class="cov0" title="0">item.DefaultRequest[name] = qty</span>
}

func AddLimitRangeItemMaxLimitRequestRatio(item *corev1.LimitRangeItem, name corev1.ResourceName, qty resource.Quantity) <span class="cov0" title="0">{
        if item.MaxLimitRequestRatio == nil </span><span class="cov0" title="0">{
                item.MaxLimitRequestRatio = make(corev1.ResourceList)
        }</span>
        <span class="cov0" title="0">item.MaxLimitRequestRatio[name] = qty</span>
}

func SetLimitRangeItemMax(item *corev1.LimitRangeItem, list corev1.ResourceList) <span class="cov0" title="0">{
        item.Max = list
}</span>

func SetLimitRangeItemMin(item *corev1.LimitRangeItem, list corev1.ResourceList) <span class="cov0" title="0">{
        item.Min = list
}</span>

func SetLimitRangeItemDefault(item *corev1.LimitRangeItem, list corev1.ResourceList) <span class="cov0" title="0">{
        item.Default = list
}</span>

func SetLimitRangeItemDefaultRequest(item *corev1.LimitRangeItem, list corev1.ResourceList) <span class="cov0" title="0">{
        item.DefaultRequest = list
}</span>

func SetLimitRangeItemMaxLimitRequestRatio(item *corev1.LimitRangeItem, list corev1.ResourceList) <span class="cov0" title="0">{
        item.MaxLimitRequestRatio = list
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package kubernetes

import (
        rbacv1 "k8s.io/api/rbac/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateRole returns a basic Role object.
func CreateRole(name, namespace string) *rbacv1.Role <span class="cov10" title="3">{
        obj := &amp;rbacv1.Role{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Role",
                        APIVersion: rbacv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Rules: []rbacv1.PolicyRule{},
        }
        return obj
}</span>

// AddRoleRule appends a PolicyRule to the Role.
func AddRoleRule(role *rbacv1.Role, rule rbacv1.PolicyRule) <span class="cov1" title="1">{
        role.Rules = append(role.Rules, rule)
}</span>

// SetRoleRules replaces all PolicyRules on the Role.
func SetRoleRules(role *rbacv1.Role, rules []rbacv1.PolicyRule) <span class="cov1" title="1">{
        role.Rules = rules
}</span>

// AddRoleLabel adds a label to the Role.
func AddRoleLabel(role *rbacv1.Role, key, value string) <span class="cov1" title="1">{
        if role.Labels == nil </span><span class="cov1" title="1">{
                role.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">role.Labels[key] = value</span>
}

// AddRoleAnnotation adds an annotation to the Role.
func AddRoleAnnotation(role *rbacv1.Role, key, value string) <span class="cov1" title="1">{
        if role.Annotations == nil </span><span class="cov1" title="1">{
                role.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">role.Annotations[key] = value</span>
}

// SetRoleLabels replaces all labels on the Role.
func SetRoleLabels(role *rbacv1.Role, labels map[string]string) <span class="cov1" title="1">{
        role.Labels = labels
}</span>

// SetRoleAnnotations replaces all annotations on the Role.
func SetRoleAnnotations(role *rbacv1.Role, annotations map[string]string) <span class="cov1" title="1">{
        role.Annotations = annotations
}</span>

// CreateRoleBinding returns a basic RoleBinding object.
func CreateRoleBinding(name, namespace string, roleRef rbacv1.RoleRef) *rbacv1.RoleBinding <span class="cov6" title="2">{
        obj := &amp;rbacv1.RoleBinding{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "RoleBinding",
                        APIVersion: rbacv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Subjects: []rbacv1.Subject{},
                RoleRef:  roleRef,
        }
        return obj
}</span>

// AddRoleBindingSubject appends a subject to the RoleBinding.
func AddRoleBindingSubject(rb *rbacv1.RoleBinding, subject rbacv1.Subject) <span class="cov1" title="1">{
        rb.Subjects = append(rb.Subjects, subject)
}</span>

// SetRoleBindingSubjects replaces all subjects on the RoleBinding.
func SetRoleBindingSubjects(rb *rbacv1.RoleBinding, subjects []rbacv1.Subject) <span class="cov1" title="1">{
        rb.Subjects = subjects
}</span>

// SetRoleBindingRoleRef updates the RoleRef on the RoleBinding.
func SetRoleBindingRoleRef(rb *rbacv1.RoleBinding, roleRef rbacv1.RoleRef) <span class="cov1" title="1">{
        rb.RoleRef = roleRef
}</span>

// AddRoleBindingLabel adds a label to the RoleBinding.
func AddRoleBindingLabel(rb *rbacv1.RoleBinding, key, value string) <span class="cov1" title="1">{
        if rb.Labels == nil </span><span class="cov1" title="1">{
                rb.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">rb.Labels[key] = value</span>
}

// AddRoleBindingAnnotation adds an annotation to the RoleBinding.
func AddRoleBindingAnnotation(rb *rbacv1.RoleBinding, key, value string) <span class="cov1" title="1">{
        if rb.Annotations == nil </span><span class="cov1" title="1">{
                rb.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">rb.Annotations[key] = value</span>
}

// SetRoleBindingLabels replaces all labels on the RoleBinding.
func SetRoleBindingLabels(rb *rbacv1.RoleBinding, labels map[string]string) <span class="cov1" title="1">{
        rb.Labels = labels
}</span>

// SetRoleBindingAnnotations replaces all annotations on the RoleBinding.
func SetRoleBindingAnnotations(rb *rbacv1.RoleBinding, annotations map[string]string) <span class="cov1" title="1">{
        rb.Annotations = annotations
}</span>

// CreateClusterRole returns a basic ClusterRole object.
func CreateClusterRole(name string) *rbacv1.ClusterRole <span class="cov6" title="2">{
        obj := &amp;rbacv1.ClusterRole{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ClusterRole",
                        APIVersion: rbacv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Rules: []rbacv1.PolicyRule{},
        }
        return obj
}</span>

// AddClusterRoleRule appends a PolicyRule to the ClusterRole.
func AddClusterRoleRule(cr *rbacv1.ClusterRole, rule rbacv1.PolicyRule) <span class="cov1" title="1">{
        cr.Rules = append(cr.Rules, rule)
}</span>

// SetClusterRoleRules replaces all PolicyRules on the ClusterRole.
func SetClusterRoleRules(cr *rbacv1.ClusterRole, rules []rbacv1.PolicyRule) <span class="cov1" title="1">{
        cr.Rules = rules
}</span>

// SetClusterRoleAggregationRule sets the AggregationRule for the ClusterRole.
func SetClusterRoleAggregationRule(cr *rbacv1.ClusterRole, rule *rbacv1.AggregationRule) <span class="cov1" title="1">{
        cr.AggregationRule = rule
}</span>

// AddClusterRoleLabel adds a label to the ClusterRole.
func AddClusterRoleLabel(cr *rbacv1.ClusterRole, key, value string) <span class="cov1" title="1">{
        if cr.Labels == nil </span><span class="cov1" title="1">{
                cr.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">cr.Labels[key] = value</span>
}

// AddClusterRoleAnnotation adds an annotation to the ClusterRole.
func AddClusterRoleAnnotation(cr *rbacv1.ClusterRole, key, value string) <span class="cov1" title="1">{
        if cr.Annotations == nil </span><span class="cov1" title="1">{
                cr.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">cr.Annotations[key] = value</span>
}

// SetClusterRoleLabels replaces all labels on the ClusterRole.
func SetClusterRoleLabels(cr *rbacv1.ClusterRole, labels map[string]string) <span class="cov1" title="1">{
        cr.Labels = labels
}</span>

// SetClusterRoleAnnotations replaces all annotations on the ClusterRole.
func SetClusterRoleAnnotations(cr *rbacv1.ClusterRole, annotations map[string]string) <span class="cov1" title="1">{
        cr.Annotations = annotations
}</span>

// CreateClusterRoleBinding returns a basic ClusterRoleBinding object.
func CreateClusterRoleBinding(name string, roleRef rbacv1.RoleRef) *rbacv1.ClusterRoleBinding <span class="cov6" title="2">{
        obj := &amp;rbacv1.ClusterRoleBinding{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ClusterRoleBinding",
                        APIVersion: rbacv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Subjects: []rbacv1.Subject{},
                RoleRef:  roleRef,
        }
        return obj
}</span>

// AddClusterRoleBindingSubject appends a subject to the ClusterRoleBinding.
func AddClusterRoleBindingSubject(crb *rbacv1.ClusterRoleBinding, subject rbacv1.Subject) <span class="cov1" title="1">{
        crb.Subjects = append(crb.Subjects, subject)
}</span>

// SetClusterRoleBindingSubjects replaces all subjects on the ClusterRoleBinding.
func SetClusterRoleBindingSubjects(crb *rbacv1.ClusterRoleBinding, subjects []rbacv1.Subject) <span class="cov1" title="1">{
        crb.Subjects = subjects
}</span>

// SetClusterRoleBindingRoleRef updates the RoleRef on the ClusterRoleBinding.
func SetClusterRoleBindingRoleRef(crb *rbacv1.ClusterRoleBinding, roleRef rbacv1.RoleRef) <span class="cov1" title="1">{
        crb.RoleRef = roleRef
}</span>

// AddClusterRoleBindingLabel adds a label to the ClusterRoleBinding.
func AddClusterRoleBindingLabel(crb *rbacv1.ClusterRoleBinding, key, value string) <span class="cov1" title="1">{
        if crb.Labels == nil </span><span class="cov1" title="1">{
                crb.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">crb.Labels[key] = value</span>
}

// AddClusterRoleBindingAnnotation adds an annotation to the ClusterRoleBinding.
func AddClusterRoleBindingAnnotation(crb *rbacv1.ClusterRoleBinding, key, value string) <span class="cov1" title="1">{
        if crb.Annotations == nil </span><span class="cov1" title="1">{
                crb.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">crb.Annotations[key] = value</span>
}

// SetClusterRoleBindingLabels replaces all labels on the ClusterRoleBinding.
func SetClusterRoleBindingLabels(crb *rbacv1.ClusterRoleBinding, labels map[string]string) <span class="cov1" title="1">{
        crb.Labels = labels
}</span>

// SetClusterRoleBindingAnnotations replaces all annotations on the ClusterRoleBinding.
func SetClusterRoleBindingAnnotations(crb *rbacv1.ClusterRoleBinding, annotations map[string]string) <span class="cov1" title="1">{
        crb.Annotations = annotations
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/pkg/errors"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func CreateSecret(name, namespace string) *corev1.Secret <span class="cov10" title="7">{
        obj := &amp;corev1.Secret{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Secret",
                        APIVersion: corev1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Data:       map[string][]byte{},
                StringData: map[string]string{},
                Type:       corev1.SecretTypeOpaque,
                Immutable:  new(bool),
        }
        return obj
}</span>

func AddSecretData(secret *corev1.Secret, key string, value []byte) error <span class="cov1" title="1">{
        if secret == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSecret
        }</span>
        <span class="cov1" title="1">if secret.Data == nil </span><span class="cov0" title="0">{
                secret.Data = make(map[string][]byte)
        }</span>
        <span class="cov1" title="1">secret.Data[key] = value
        return nil</span>
}

func AddSecretStringData(secret *corev1.Secret, key, value string) error <span class="cov1" title="1">{
        if secret == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSecret
        }</span>
        <span class="cov1" title="1">if secret.StringData == nil </span><span class="cov0" title="0">{
                secret.StringData = make(map[string]string)
        }</span>
        <span class="cov1" title="1">secret.StringData[key] = value
        return nil</span>
}

func SetSecretType(secret *corev1.Secret, type_ corev1.SecretType) error <span class="cov1" title="1">{
        if secret == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSecret
        }</span>
        <span class="cov1" title="1">secret.Type = type_
        return nil</span>
}

func SetSecretImmutable(secret *corev1.Secret, immutable bool) error <span class="cov4" title="2">{
        if secret == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSecret
        }</span>
        <span class="cov4" title="2">if secret.Immutable == nil </span><span class="cov0" title="0">{
                secret.Immutable = new(bool)
        }</span>
        <span class="cov4" title="2">*secret.Immutable = immutable
        return nil</span>
}

func AddSecretLabel(secret *corev1.Secret, key, value string) error <span class="cov1" title="1">{
        if secret == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSecret
        }</span>
        <span class="cov1" title="1">if secret.Labels == nil </span><span class="cov0" title="0">{
                secret.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">secret.Labels[key] = value
        return nil</span>
}

func AddSecretAnnotation(secret *corev1.Secret, key, value string) error <span class="cov1" title="1">{
        if secret == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSecret
        }</span>
        <span class="cov1" title="1">if secret.Annotations == nil </span><span class="cov0" title="0">{
                secret.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">secret.Annotations[key] = value
        return nil</span>
}

func SetSecretLabels(secret *corev1.Secret, labels map[string]string) error <span class="cov1" title="1">{
        if secret == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSecret
        }</span>
        <span class="cov1" title="1">secret.Labels = labels
        return nil</span>
}

func SetSecretAnnotations(secret *corev1.Secret, anns map[string]string) error <span class="cov1" title="1">{
        if secret == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSecret
        }</span>
        <span class="cov1" title="1">secret.Annotations = anns
        return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/internal/validation"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func CreateService(name string, namespace string) *corev1.Service <span class="cov10" title="2">{
        obj := &amp;corev1.Service{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Service",
                        APIVersion: corev1.SchemeGroupVersion.String(),
                },
                Spec: corev1.ServiceSpec{
                        Selector: map[string]string{},
                        Ports:    []corev1.ServicePort{},
                },
        }
        return obj
}</span>

func AddServicePort(service *corev1.Service, port corev1.ServicePort) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">service.Spec.Ports = append(service.Spec.Ports, port)
        return nil</span>
}

func SetServiceSelector(service *corev1.Service, selector map[string]string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">service.Spec.Selector = selector
        return nil</span>
}

func SetServiceType(service *corev1.Service, type_ corev1.ServiceType) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">service.Spec.Type = type_
        return nil</span>
}

// SetServiceClusterIP sets the clusterIP on the Service spec.
func SetServiceClusterIP(service *corev1.Service, ip string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">service.Spec.ClusterIP = ip
        return nil</span>
}

// AddServiceExternalIP appends an external IP address to the Service spec.
func AddServiceExternalIP(service *corev1.Service, ip string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">service.Spec.ExternalIPs = append(service.Spec.ExternalIPs, ip)
        return nil</span>
}

// SetServiceLoadBalancerIP sets the load balancer IP on the Service spec.
func SetServiceLoadBalancerIP(service *corev1.Service, ip string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">service.Spec.LoadBalancerIP = ip
        return nil</span>
}

/*
   service.Spec.LoadBalancerIP

   Deprecated: This field was under-specified and
   its meaning varies across implementations, and it cannot support dual-stack.
   As of Kubernetes v1.24, users are encouraged to use implementation-specific
   annotations when available.
*/

func SetServiceExternalTrafficPolicy(service *corev1.Service, trafficPolicy corev1.ServiceExternalTrafficPolicy) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">service.Spec.ExternalTrafficPolicy = trafficPolicy
        return nil</span>
}

func SetServiceSessionAffinity(service *corev1.Service, affinity corev1.ServiceAffinity) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(service); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">service.Spec.SessionAffinity = affinity
        return nil</span>
}

func SetServiceLoadBalancerClass(service *corev1.Service, class string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(service); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">service.Spec.LoadBalancerClass = &amp;class
        return nil</span>
}

func AddServiceLabel(svc *corev1.Service, key, value string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">if svc.Labels == nil </span><span class="cov0" title="0">{
                svc.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">svc.Labels[key] = value
        return nil</span>
}

func AddServiceAnnotation(svc *corev1.Service, key, value string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">if svc.Annotations == nil </span><span class="cov0" title="0">{
                svc.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">svc.Annotations[key] = value
        return nil</span>
}

func SetServiceLabels(svc *corev1.Service, labels map[string]string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Labels = labels
        return nil</span>
}

func SetServiceAnnotations(svc *corev1.Service, anns map[string]string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Annotations = anns
        return nil</span>
}

func SetServicePublishNotReadyAddresses(svc *corev1.Service, publish bool) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.PublishNotReadyAddresses = publish
        return nil</span>
}

func AddServiceLoadBalancerSourceRange(svc *corev1.Service, cidr string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.LoadBalancerSourceRanges = append(svc.Spec.LoadBalancerSourceRanges, cidr)
        return nil</span>
}

func SetServiceLoadBalancerSourceRanges(svc *corev1.Service, ranges []string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.LoadBalancerSourceRanges = ranges
        return nil</span>
}

func SetServiceIPFamilies(svc *corev1.Service, fams []corev1.IPFamily) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.IPFamilies = fams
        return nil</span>
}

func SetServiceIPFamilyPolicy(svc *corev1.Service, policy *corev1.IPFamilyPolicyType) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.IPFamilyPolicy = policy
        return nil</span>
}

func SetServiceInternalTrafficPolicy(svc *corev1.Service, policy *corev1.ServiceInternalTrafficPolicyType) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.InternalTrafficPolicy = policy
        return nil</span>
}

func SetServiceAllocateLoadBalancerNodePorts(svc *corev1.Service, allocate bool) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.AllocateLoadBalancerNodePorts = &amp;allocate
        return nil</span>
}

// SetServiceExternalName sets the externalName field for ExternalName services.
func SetServiceExternalName(svc *corev1.Service, name string) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.ExternalName = name
        return nil</span>
}

// SetServiceHealthCheckNodePort sets the healthCheckNodePort field for LoadBalancer services.
func SetServiceHealthCheckNodePort(svc *corev1.Service, port int32) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.HealthCheckNodePort = port
        return nil</span>
}

// SetServiceSessionAffinityConfig configures the session affinity options.
func SetServiceSessionAffinityConfig(svc *corev1.Service, cfg *corev1.SessionAffinityConfig) error <span class="cov1" title="1">{
        validator := validation.NewValidator()
        if err := validator.ValidateService(svc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">svc.Spec.SessionAffinityConfig = cfg
        return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/pkg/errors"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func CreateServiceAccount(name, namespace string) *corev1.ServiceAccount <span class="cov10" title="7">{
        obj := &amp;corev1.ServiceAccount{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ServiceAccount",
                        APIVersion: corev1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Secrets:                      []corev1.ObjectReference{},
                ImagePullSecrets:             []corev1.LocalObjectReference{},
                AutomountServiceAccountToken: new(bool),
        }
        return obj
}</span>

func AddServiceAccountSecret(sa *corev1.ServiceAccount, secret corev1.ObjectReference) error <span class="cov1" title="1">{
        if sa == nil </span><span class="cov0" title="0">{
                return errors.ErrNilServiceAccount
        }</span>
        <span class="cov1" title="1">sa.Secrets = append(sa.Secrets, secret)
        return nil</span>
}

func AddServiceAccountImagePullSecret(sa *corev1.ServiceAccount, secret corev1.LocalObjectReference) error <span class="cov1" title="1">{
        if sa == nil </span><span class="cov0" title="0">{
                return errors.ErrNilServiceAccount
        }</span>
        <span class="cov1" title="1">sa.ImagePullSecrets = append(sa.ImagePullSecrets, secret)
        return nil</span>
}

func SetServiceAccountSecrets(sa *corev1.ServiceAccount, secrets []corev1.ObjectReference) error <span class="cov1" title="1">{
        if sa == nil </span><span class="cov0" title="0">{
                return errors.ErrNilServiceAccount
        }</span>
        <span class="cov1" title="1">sa.Secrets = secrets
        return nil</span>
}

func SetServiceAccountImagePullSecrets(sa *corev1.ServiceAccount, secrets []corev1.LocalObjectReference) error <span class="cov1" title="1">{
        if sa == nil </span><span class="cov0" title="0">{
                return errors.ErrNilServiceAccount
        }</span>
        <span class="cov1" title="1">sa.ImagePullSecrets = secrets
        return nil</span>
}

func SetServiceAccountAutomountToken(sa *corev1.ServiceAccount, automount bool) error <span class="cov4" title="2">{
        if sa == nil </span><span class="cov0" title="0">{
                return errors.ErrNilServiceAccount
        }</span>
        <span class="cov4" title="2">if sa.AutomountServiceAccountToken == nil </span><span class="cov0" title="0">{
                sa.AutomountServiceAccountToken = new(bool)
        }</span>
        <span class="cov4" title="2">*sa.AutomountServiceAccountToken = automount
        return nil</span>
}

func AddServiceAccountLabel(sa *corev1.ServiceAccount, key, value string) <span class="cov1" title="1">{
        if sa.Labels == nil </span><span class="cov0" title="0">{
                sa.Labels = make(map[string]string)
        }</span>
        <span class="cov1" title="1">sa.Labels[key] = value</span>
}

func AddServiceAccountAnnotation(sa *corev1.ServiceAccount, key, value string) <span class="cov1" title="1">{
        if sa.Annotations == nil </span><span class="cov0" title="0">{
                sa.Annotations = make(map[string]string)
        }</span>
        <span class="cov1" title="1">sa.Annotations[key] = value</span>
}

func SetServiceAccountLabels(sa *corev1.ServiceAccount, labels map[string]string) <span class="cov1" title="1">{
        sa.Labels = labels
}</span>

func SetServiceAccountAnnotations(sa *corev1.ServiceAccount, annotations map[string]string) <span class="cov1" title="1">{
        sa.Annotations = annotations
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package kubernetes

import (
        "github.com/go-kure/kure/pkg/errors"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateStatefulSet returns a StatefulSet with sensible defaults set.
func CreateStatefulSet(name, namespace string) *appsv1.StatefulSet <span class="cov8" title="4">{
        obj := &amp;appsv1.StatefulSet{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "StatefulSet",
                        APIVersion: appsv1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Spec: appsv1.StatefulSetSpec{
                        Replicas: new(int32),
                        Selector: &amp;metav1.LabelSelector{MatchLabels: map[string]string{"app": name}},
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"app": name}},
                                Spec:       corev1.PodSpec{},
                        },
                        VolumeClaimTemplates: []corev1.PersistentVolumeClaim{},
                        ServiceName:          "",
                        PodManagementPolicy:  appsv1.OrderedReadyPodManagement,
                        UpdateStrategy:       appsv1.StatefulSetUpdateStrategy{},
                },
        }
        return obj
}</span>

// SetStatefulSetPodSpec assigns a PodSpec to the StatefulSet template.
func SetStatefulSetPodSpec(sts *appsv1.StatefulSet, spec *corev1.PodSpec) error <span class="cov0" title="0">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov0" title="0">if spec == nil </span><span class="cov0" title="0">{
                return errors.ErrNilSpec
        }</span>
        <span class="cov0" title="0">sts.Spec.Template.Spec = *spec
        return nil</span>
}

// AddStatefulSetContainer appends a container to the StatefulSet pod template.
func AddStatefulSetContainer(sts *appsv1.StatefulSet, c *corev1.Container) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecContainer(&amp;sts.Spec.Template.Spec, c)</span>
}

// AddStatefulSetInitContainer appends an init container to the pod template.
func AddStatefulSetInitContainer(sts *appsv1.StatefulSet, c *corev1.Container) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecInitContainer(&amp;sts.Spec.Template.Spec, c)</span>
}

// AddStatefulSetVolume appends a volume to the pod template.
func AddStatefulSetVolume(sts *appsv1.StatefulSet, v *corev1.Volume) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecVolume(&amp;sts.Spec.Template.Spec, v)</span>
}

// AddStatefulSetImagePullSecret appends an image pull secret to the pod template.
func AddStatefulSetImagePullSecret(sts *appsv1.StatefulSet, s *corev1.LocalObjectReference) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecImagePullSecret(&amp;sts.Spec.Template.Spec, s)</span>
}

// AddStatefulSetToleration appends a toleration to the pod template.
func AddStatefulSetToleration(sts *appsv1.StatefulSet, t *corev1.Toleration) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">return AddPodSpecToleration(&amp;sts.Spec.Template.Spec, t)</span>
}

// AddStatefulSetTopologySpreadConstraints appends a topology spread constraint if not nil.
func AddStatefulSetTopologySpreadConstraints(sts *appsv1.StatefulSet, c *corev1.TopologySpreadConstraint) error <span class="cov10" title="5">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov10" title="5">return AddPodSpecTopologySpreadConstraints(&amp;sts.Spec.Template.Spec, c)</span>
}

// AddStatefulSetVolumeClaimTemplate appends a PVC template to the StatefulSet.
func AddStatefulSetVolumeClaimTemplate(sts *appsv1.StatefulSet, pvc corev1.PersistentVolumeClaim) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">sts.Spec.VolumeClaimTemplates = append(sts.Spec.VolumeClaimTemplates, pvc)
        return nil</span>
}

// SetStatefulSetServiceAccountName sets the service account name for the pod template.
func SetStatefulSetServiceAccountName(sts *appsv1.StatefulSet, name string) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">return SetPodSpecServiceAccountName(&amp;sts.Spec.Template.Spec, name)</span>
}

// SetStatefulSetSecurityContext sets the pod security context.
func SetStatefulSetSecurityContext(sts *appsv1.StatefulSet, sc *corev1.PodSecurityContext) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">return SetPodSpecSecurityContext(&amp;sts.Spec.Template.Spec, sc)</span>
}

// SetStatefulSetAffinity sets the pod affinity rules.
func SetStatefulSetAffinity(sts *appsv1.StatefulSet, aff *corev1.Affinity) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">return SetPodSpecAffinity(&amp;sts.Spec.Template.Spec, aff)</span>
}

// SetStatefulSetNodeSelector sets the node selector.
func SetStatefulSetNodeSelector(sts *appsv1.StatefulSet, ns map[string]string) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">return SetPodSpecNodeSelector(&amp;sts.Spec.Template.Spec, ns)</span>
}

// SetStatefulSetUpdateStrategy sets the update strategy for the StatefulSet.
func SetStatefulSetUpdateStrategy(sts *appsv1.StatefulSet, strat appsv1.StatefulSetUpdateStrategy) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">sts.Spec.UpdateStrategy = strat
        return nil</span>
}

// SetStatefulSetReplicas sets the replica count.
func SetStatefulSetReplicas(sts *appsv1.StatefulSet, replicas int32) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">if sts.Spec.Replicas == nil </span><span class="cov0" title="0">{
                sts.Spec.Replicas = new(int32)
        }</span>
        <span class="cov1" title="1">*sts.Spec.Replicas = replicas
        return nil</span>
}

// SetStatefulSetServiceName sets the service name used by the StatefulSet.
func SetStatefulSetServiceName(sts *appsv1.StatefulSet, svc string) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">sts.Spec.ServiceName = svc
        return nil</span>
}

// SetStatefulSetPodManagementPolicy sets the pod management policy.
func SetStatefulSetPodManagementPolicy(sts *appsv1.StatefulSet, policy appsv1.PodManagementPolicyType) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">sts.Spec.PodManagementPolicy = policy
        return nil</span>
}

// SetStatefulSetRevisionHistoryLimit sets the revision history limit.
func SetStatefulSetRevisionHistoryLimit(sts *appsv1.StatefulSet, limit *int32) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">sts.Spec.RevisionHistoryLimit = limit
        return nil</span>
}

// SetStatefulSetMinReadySeconds sets the minimum ready seconds.
func SetStatefulSetMinReadySeconds(sts *appsv1.StatefulSet, secs int32) error <span class="cov1" title="1">{
        if sts == nil </span><span class="cov0" title="0">{
                return errors.ErrNilStatefulSet
        }</span>
        <span class="cov1" title="1">sts.Spec.MinReadySeconds = secs
        return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package kubernetes

import (
        corev1 "k8s.io/api/core/v1"
        storagev1 "k8s.io/api/storage/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateStorageClass returns a StorageClass object with sane defaults.
func CreateStorageClass(name string, provisioner string) *storagev1.StorageClass <span class="cov10" title="2">{
        policy := corev1.PersistentVolumeReclaimDelete
        binding := storagev1.VolumeBindingImmediate
        obj := &amp;storagev1.StorageClass{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "StorageClass",
                        APIVersion: storagev1.SchemeGroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                        Labels: map[string]string{
                                "app": name,
                        },
                        Annotations: map[string]string{
                                "app": name,
                        },
                },
                Provisioner:          provisioner,
                Parameters:           map[string]string{},
                MountOptions:         []string{},
                ReclaimPolicy:        &amp;policy,
                AllowVolumeExpansion: new(bool),
                VolumeBindingMode:    &amp;binding,
                AllowedTopologies:    []corev1.TopologySelectorTerm{},
        }
        return obj
}</span>

// AddStorageClassParameter inserts a single parameter into the StorageClass.
func AddStorageClassParameter(sc *storagev1.StorageClass, key, value string) <span class="cov1" title="1">{
        if sc.Parameters == nil </span><span class="cov0" title="0">{
                sc.Parameters = make(map[string]string)
        }</span>
        <span class="cov1" title="1">sc.Parameters[key] = value</span>
}

// AddStorageClassParameters merges the provided parameters into the StorageClass.
func AddStorageClassParameters(sc *storagev1.StorageClass, params map[string]string) <span class="cov1" title="1">{
        if sc.Parameters == nil </span><span class="cov0" title="0">{
                sc.Parameters = make(map[string]string)
        }</span>
        <span class="cov1" title="1">for k, v := range params </span><span class="cov1" title="1">{
                sc.Parameters[k] = v
        }</span>
}

// SetStorageClassParameters replaces the parameters map entirely.
func SetStorageClassParameters(sc *storagev1.StorageClass, params map[string]string) <span class="cov1" title="1">{
        sc.Parameters = params
}</span>

// AddStorageClassMountOption appends a mount option to the StorageClass.
func AddStorageClassMountOption(sc *storagev1.StorageClass, option string) <span class="cov1" title="1">{
        sc.MountOptions = append(sc.MountOptions, option)
}</span>

// AddStorageClassMountOptions appends multiple mount options to the StorageClass.
func AddStorageClassMountOptions(sc *storagev1.StorageClass, options []string) <span class="cov1" title="1">{
        sc.MountOptions = append(sc.MountOptions, options...)
}</span>

// SetStorageClassMountOptions replaces all mount options.
func SetStorageClassMountOptions(sc *storagev1.StorageClass, options []string) <span class="cov1" title="1">{
        sc.MountOptions = options
}</span>

// SetStorageClassProvisioner sets the provisioner field.
func SetStorageClassProvisioner(sc *storagev1.StorageClass, provisioner string) <span class="cov1" title="1">{
        sc.Provisioner = provisioner
}</span>

// SetStorageClassReclaimPolicy sets the reclaim policy.
func SetStorageClassReclaimPolicy(sc *storagev1.StorageClass, policy corev1.PersistentVolumeReclaimPolicy) <span class="cov1" title="1">{
        sc.ReclaimPolicy = &amp;policy
}</span>

// SetStorageClassAllowVolumeExpansion sets the allowVolumeExpansion field.
func SetStorageClassAllowVolumeExpansion(sc *storagev1.StorageClass, allow bool) <span class="cov1" title="1">{
        if sc.AllowVolumeExpansion == nil </span><span class="cov0" title="0">{
                sc.AllowVolumeExpansion = new(bool)
        }</span>
        <span class="cov1" title="1">*sc.AllowVolumeExpansion = allow</span>
}

// SetStorageClassVolumeBindingMode sets the volume binding mode.
func SetStorageClassVolumeBindingMode(sc *storagev1.StorageClass, mode storagev1.VolumeBindingMode) <span class="cov1" title="1">{
        sc.VolumeBindingMode = &amp;mode
}</span>

// AddStorageClassAllowedTopology appends an allowed topology term.
func AddStorageClassAllowedTopology(sc *storagev1.StorageClass, topo corev1.TopologySelectorTerm) <span class="cov1" title="1">{
        sc.AllowedTopologies = append(sc.AllowedTopologies, topo)
}</span>

// AddStorageClassAllowedTopologies appends multiple allowed topology terms.
func AddStorageClassAllowedTopologies(sc *storagev1.StorageClass, topos []corev1.TopologySelectorTerm) <span class="cov1" title="1">{
        sc.AllowedTopologies = append(sc.AllowedTopologies, topos...)
}</span>

// SetStorageClassAllowedTopologies replaces the allowed topologies slice.
func SetStorageClassAllowedTopologies(sc *storagev1.StorageClass, topos []corev1.TopologySelectorTerm) <span class="cov1" title="1">{
        sc.AllowedTopologies = topos
}</span>

// SetPVCStorageClass sets the StorageClass for the claim by name.
func SetPVCStorageClass(pvc *corev1.PersistentVolumeClaim, sc *storagev1.StorageClass) <span class="cov1" title="1">{
        if sc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">pvc.Spec.StorageClassName = &amp;sc.Name</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package metallb

import (
        "errors"

        metallbv1beta1 "go.universe.tf/metallb/api/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateBFDProfile returns a new BFDProfile object with the provided name, namespace and spec.
func CreateBFDProfile(name, namespace string, spec metallbv1beta1.BFDProfileSpec) *metallbv1beta1.BFDProfile <span class="cov10" title="2">{
        obj := &amp;metallbv1beta1.BFDProfile{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "BFDProfile",
                        APIVersion: metallbv1beta1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// SetBFDProfileDetectMultiplier sets the detect multiplier on the BFDProfile spec.
func SetBFDProfileDetectMultiplier(obj *metallbv1beta1.BFDProfile, mult uint32) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BFDProfile")
        }</span>
        <span class="cov1" title="1">obj.Spec.DetectMultiplier = &amp;mult
        return nil</span>
}

// SetBFDProfileEchoInterval sets the echo interval on the BFDProfile spec.
func SetBFDProfileEchoInterval(obj *metallbv1beta1.BFDProfile, interval uint32) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BFDProfile")
        }</span>
        <span class="cov1" title="1">obj.Spec.EchoInterval = &amp;interval
        return nil</span>
}

// SetBFDProfileEchoMode sets the echo mode on the BFDProfile spec.
func SetBFDProfileEchoMode(obj *metallbv1beta1.BFDProfile, mode bool) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BFDProfile")
        }</span>
        <span class="cov1" title="1">obj.Spec.EchoMode = &amp;mode
        return nil</span>
}

// SetBFDProfilePassiveMode sets the passive mode on the BFDProfile spec.
func SetBFDProfilePassiveMode(obj *metallbv1beta1.BFDProfile, mode bool) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BFDProfile")
        }</span>
        <span class="cov1" title="1">obj.Spec.PassiveMode = &amp;mode
        return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package metallb

import (
        "errors"

        metallbv1beta1 "go.universe.tf/metallb/api/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateBGPAdvertisement returns a new BGPAdvertisement object with the given name, namespace and spec.
func CreateBGPAdvertisement(name, namespace string, spec metallbv1beta1.BGPAdvertisementSpec) *metallbv1beta1.BGPAdvertisement <span class="cov10" title="2">{
        obj := &amp;metallbv1beta1.BGPAdvertisement{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "BGPAdvertisement",
                        APIVersion: metallbv1beta1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddBGPAdvertisementIPAddressPool appends an IPAddressPool name to the BGPAdvertisement spec.
func AddBGPAdvertisementIPAddressPool(obj *metallbv1beta1.BGPAdvertisement, pool string) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPAdvertisement")
        }</span>
        <span class="cov1" title="1">obj.Spec.IPAddressPools = append(obj.Spec.IPAddressPools, pool)
        return nil</span>
}

// AddBGPAdvertisementNodeSelector appends a node selector to the BGPAdvertisement spec.
func AddBGPAdvertisementNodeSelector(obj *metallbv1beta1.BGPAdvertisement, sel metav1.LabelSelector) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPAdvertisement")
        }</span>
        <span class="cov1" title="1">obj.Spec.NodeSelectors = append(obj.Spec.NodeSelectors, sel)
        return nil</span>
}

// AddBGPAdvertisementCommunity appends a BGP community to the BGPAdvertisement spec.
func AddBGPAdvertisementCommunity(obj *metallbv1beta1.BGPAdvertisement, c string) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPAdvertisement")
        }</span>
        <span class="cov1" title="1">obj.Spec.Communities = append(obj.Spec.Communities, c)
        return nil</span>
}

// AddBGPAdvertisementPeer appends a peer name to the BGPAdvertisement spec.
func AddBGPAdvertisementPeer(obj *metallbv1beta1.BGPAdvertisement, peer string) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPAdvertisement")
        }</span>
        <span class="cov1" title="1">obj.Spec.Peers = append(obj.Spec.Peers, peer)
        return nil</span>
}

// SetBGPAdvertisementLocalPref sets the localPref value on the BGPAdvertisement spec.
func SetBGPAdvertisementLocalPref(obj *metallbv1beta1.BGPAdvertisement, pref uint32) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPAdvertisement")
        }</span>
        <span class="cov1" title="1">obj.Spec.LocalPref = pref
        return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package metallb

import (
        "errors"

        metallbv1beta1 "go.universe.tf/metallb/api/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateBGPPeer returns a new BGPPeer object with the provided name, namespace and spec.
func CreateBGPPeer(name, namespace string, spec metallbv1beta1.BGPPeerSpec) *metallbv1beta1.BGPPeer <span class="cov10" title="2">{
        obj := &amp;metallbv1beta1.BGPPeer{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "BGPPeer",
                        APIVersion: metallbv1beta1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddBGPPeerNodeSelector appends a node selector to the BGPPeer spec.
func AddBGPPeerNodeSelector(obj *metallbv1beta1.BGPPeer, sel metallbv1beta1.NodeSelector) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPPeer")
        }</span>
        <span class="cov1" title="1">obj.Spec.NodeSelectors = append(obj.Spec.NodeSelectors, sel)
        return nil</span>
}

// SetBGPPeerPort sets the peer port on the BGPPeer spec.
func SetBGPPeerPort(obj *metallbv1beta1.BGPPeer, port uint16) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPPeer")
        }</span>
        <span class="cov1" title="1">obj.Spec.Port = port
        return nil</span>
}

// SetBGPPeerHoldTime sets the hold time on the BGPPeer spec.
func SetBGPPeerHoldTime(obj *metallbv1beta1.BGPPeer, d metav1.Duration) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPPeer")
        }</span>
        <span class="cov1" title="1">obj.Spec.HoldTime = d
        return nil</span>
}

// SetBGPPeerKeepaliveTime sets the keepalive time on the BGPPeer spec.
func SetBGPPeerKeepaliveTime(obj *metallbv1beta1.BGPPeer, d metav1.Duration) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPPeer")
        }</span>
        <span class="cov1" title="1">obj.Spec.KeepaliveTime = d
        return nil</span>
}

// SetBGPPeerSrcAddress sets the source address on the BGPPeer spec.
func SetBGPPeerSrcAddress(obj *metallbv1beta1.BGPPeer, addr string) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPPeer")
        }</span>
        <span class="cov1" title="1">obj.Spec.SrcAddress = addr
        return nil</span>
}

// SetBGPPeerRouterID sets the router ID on the BGPPeer spec.
func SetBGPPeerRouterID(obj *metallbv1beta1.BGPPeer, id string) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPPeer")
        }</span>
        <span class="cov1" title="1">obj.Spec.RouterID = id
        return nil</span>
}

// SetBGPPeerEBGPMultiHop sets the eBGP multi-hop flag on the BGPPeer spec.
func SetBGPPeerEBGPMultiHop(obj *metallbv1beta1.BGPPeer, multi bool) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPPeer")
        }</span>
        <span class="cov1" title="1">obj.Spec.EBGPMultiHop = multi
        return nil</span>
}

// SetBGPPeerPassword sets the password on the BGPPeer spec.
func SetBGPPeerPassword(obj *metallbv1beta1.BGPPeer, pw string) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPPeer")
        }</span>
        <span class="cov1" title="1">obj.Spec.Password = pw
        return nil</span>
}

// SetBGPPeerBFDProfile sets the BFD profile name on the BGPPeer spec.
func SetBGPPeerBFDProfile(obj *metallbv1beta1.BGPPeer, profile string) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil BGPPeer")
        }</span>
        <span class="cov1" title="1">obj.Spec.BFDProfile = profile
        return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package metallb

import (
        "github.com/go-kure/kure/internal/validation"

        metallbv1beta1 "go.universe.tf/metallb/api/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateIPAddressPool returns a new IPAddressPool object with the given name, namespace and spec.
func CreateIPAddressPool(name, namespace string, spec metallbv1beta1.IPAddressPoolSpec) *metallbv1beta1.IPAddressPool <span class="cov10" title="2">{
        obj := &amp;metallbv1beta1.IPAddressPool{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "IPAddressPool",
                        APIVersion: metallbv1beta1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddIPAddressPoolAddress adds an address range to the IPAddressPool spec.
func AddIPAddressPoolAddress(obj *metallbv1beta1.IPAddressPool, addr string) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateIPAddressPool(obj); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">obj.Spec.Addresses = append(obj.Spec.Addresses, addr)
        return nil</span>
}

// SetIPAddressPoolAutoAssign sets the autoAssign flag on the IPAddressPool spec.
func SetIPAddressPoolAutoAssign(obj *metallbv1beta1.IPAddressPool, auto bool) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateIPAddressPool(obj); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">obj.Spec.AutoAssign = &amp;auto
        return nil</span>
}

// SetIPAddressPoolAvoidBuggyIPs sets the avoidBuggyIPs flag on the IPAddressPool spec.
func SetIPAddressPoolAvoidBuggyIPs(obj *metallbv1beta1.IPAddressPool, avoid bool) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateIPAddressPool(obj); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">obj.Spec.AvoidBuggyIPs = avoid
        return nil</span>
}

// SetIPAddressPoolAllocateTo sets the allocation policy on the IPAddressPool spec.
func SetIPAddressPoolAllocateTo(obj *metallbv1beta1.IPAddressPool, alloc *metallbv1beta1.ServiceAllocation) error <span class="cov10" title="2">{
        validator := validation.NewValidator()
        if err := validator.ValidateIPAddressPool(obj); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">obj.Spec.AllocateTo = alloc
        return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package metallb

import (
        "errors"

        metallbv1beta1 "go.universe.tf/metallb/api/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateL2Advertisement returns a new L2Advertisement object with the given name, namespace and spec.
func CreateL2Advertisement(name, namespace string, spec metallbv1beta1.L2AdvertisementSpec) *metallbv1beta1.L2Advertisement <span class="cov10" title="2">{
        obj := &amp;metallbv1beta1.L2Advertisement{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "L2Advertisement",
                        APIVersion: metallbv1beta1.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: spec,
        }
        return obj
}</span>

// AddL2AdvertisementIPAddressPool appends an IPAddressPool reference to the L2Advertisement spec.
func AddL2AdvertisementIPAddressPool(obj *metallbv1beta1.L2Advertisement, pool string) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil L2Advertisement")
        }</span>
        <span class="cov1" title="1">obj.Spec.IPAddressPools = append(obj.Spec.IPAddressPools, pool)
        return nil</span>
}

// AddL2AdvertisementNodeSelector appends a node selector to the L2Advertisement spec.
func AddL2AdvertisementNodeSelector(obj *metallbv1beta1.L2Advertisement, sel metav1.LabelSelector) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil L2Advertisement")
        }</span>
        <span class="cov1" title="1">obj.Spec.NodeSelectors = append(obj.Spec.NodeSelectors, sel)
        return nil</span>
}

// AddL2AdvertisementInterface appends a network interface name to the L2Advertisement spec.
func AddL2AdvertisementInterface(obj *metallbv1beta1.L2Advertisement, iface string) error <span class="cov10" title="2">{
        if obj == nil </span><span class="cov1" title="1">{
                return errors.New("nil L2Advertisement")
        }</span>
        <span class="cov1" title="1">obj.Spec.Interfaces = append(obj.Spec.Interfaces, iface)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package validation

import (
        "reflect"

        "github.com/go-kure/kure/pkg/errors"

        appsv1 "k8s.io/api/apps/v1"
        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        policyv1 "k8s.io/api/policy/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        "sigs.k8s.io/kustomize/api/types"

        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        metallbv1beta1 "go.universe.tf/metallb/api/v1beta1"
)

// Validator provides centralized validation for Kubernetes resources and their components.
type Validator struct{}

// NewValidator creates a new validator instance.
func NewValidator() *Validator <span class="cov8" title="38">{
        return &amp;Validator{}
}</span>

// validateNotNil is a generic helper for nil validation
func (v *Validator) validateNotNil(obj interface{}, errType error) error <span class="cov10" title="90">{
        if obj == nil || (reflect.ValueOf(obj).Kind() == reflect.Ptr &amp;&amp; reflect.ValueOf(obj).IsNil()) </span><span class="cov8" title="39">{
                return errType
        }</span>
        <span class="cov8" title="51">return nil</span>
}

// Core Kubernetes Resources Validation

func (v *Validator) ValidatePod(pod *corev1.Pod) error <span class="cov2" title="2">{
        return v.validateNotNil(pod, errors.ErrNilPod)
}</span>

func (v *Validator) ValidateDeployment(deployment *appsv1.Deployment) error <span class="cov5" title="8">{
        return v.validateNotNil(deployment, errors.ErrNilDeployment)
}</span>

func (v *Validator) ValidateService(service *corev1.Service) error <span class="cov4" title="5">{
        return v.validateNotNil(service, errors.ErrNilService)
}</span>

func (v *Validator) ValidateConfigMap(cm *corev1.ConfigMap) error <span class="cov2" title="2">{
        return v.validateNotNil(cm, errors.ErrNilConfigMap)
}</span>

func (v *Validator) ValidateSecret(secret *corev1.Secret) error <span class="cov2" title="2">{
        return v.validateNotNil(secret, errors.ErrNilSecret)
}</span>

func (v *Validator) ValidateServiceAccount(sa *corev1.ServiceAccount) error <span class="cov2" title="2">{
        return v.validateNotNil(sa, errors.ErrNilServiceAccount)
}</span>

func (v *Validator) ValidateNamespace(ns *corev1.Namespace) error <span class="cov2" title="2">{
        return v.validateNotNil(ns, errors.ErrNilNamespace)
}</span>

func (v *Validator) ValidateIngress(ingress *networkingv1.Ingress) error <span class="cov2" title="2">{
        return v.validateNotNil(ingress, errors.ErrNilIngress)
}</span>

func (v *Validator) ValidateStatefulSet(sts *appsv1.StatefulSet) error <span class="cov2" title="2">{
        return v.validateNotNil(sts, errors.ErrNilStatefulSet)
}</span>

func (v *Validator) ValidateDaemonSet(ds *appsv1.DaemonSet) error <span class="cov2" title="2">{
        return v.validateNotNil(ds, errors.ErrNilDaemonSet)
}</span>

func (v *Validator) ValidateJob(job *batchv1.Job) error <span class="cov2" title="2">{
        return v.validateNotNil(job, errors.ErrNilJob)
}</span>

func (v *Validator) ValidateCronJob(cronJob *batchv1.CronJob) error <span class="cov2" title="2">{
        return v.validateNotNil(cronJob, errors.ErrNilCronJob)
}</span>

// RBAC Resources Validation

func (v *Validator) ValidateRole(role *rbacv1.Role) error <span class="cov2" title="2">{
        return v.validateNotNil(role, errors.ErrNilRole)
}</span>

func (v *Validator) ValidateClusterRole(clusterRole *rbacv1.ClusterRole) error <span class="cov2" title="2">{
        return v.validateNotNil(clusterRole, errors.ErrNilClusterRole)
}</span>

func (v *Validator) ValidateRoleBinding(roleBinding *rbacv1.RoleBinding) error <span class="cov2" title="2">{
        return v.validateNotNil(roleBinding, errors.ErrNilRoleBinding)
}</span>

func (v *Validator) ValidateClusterRoleBinding(clusterRoleBinding *rbacv1.ClusterRoleBinding) error <span class="cov2" title="2">{
        return v.validateNotNil(clusterRoleBinding, errors.ErrNilClusterRoleBinding)
}</span>

// Component Validation (specs, containers, etc.)

func (v *Validator) ValidatePodSpec(spec *corev1.PodSpec) error <span class="cov5" title="9">{
        return v.validateNotNil(spec, errors.ErrNilPodSpec)
}</span>

func (v *Validator) ValidateContainer(container *corev1.Container) error <span class="cov4" title="6">{
        return v.validateNotNil(container, errors.ErrNilContainer)
}</span>

func (v *Validator) ValidateInitContainer(container *corev1.Container) error <span class="cov2" title="2">{
        return v.validateNotNil(container, errors.ErrNilInitContainer)
}</span>

func (v *Validator) ValidateEphemeralContainer(container *corev1.EphemeralContainer) error <span class="cov2" title="2">{
        return v.validateNotNil(container, errors.ErrNilEphemeralContainer)
}</span>

func (v *Validator) ValidateVolume(volume *corev1.Volume) error <span class="cov2" title="2">{
        return v.validateNotNil(volume, errors.ErrNilVolume)
}</span>

func (v *Validator) ValidateImagePullSecret(secret *corev1.LocalObjectReference) error <span class="cov2" title="2">{
        return v.validateNotNil(secret, errors.ErrNilImagePullSecret)
}</span>

func (v *Validator) ValidateToleration(toleration *corev1.Toleration) error <span class="cov2" title="2">{
        return v.validateNotNil(toleration, errors.ErrNilToleration)
}</span>

func (v *Validator) ValidateServicePort(port *corev1.ServicePort) error <span class="cov3" title="4">{
        return v.validateNotNil(port, errors.ErrNilServicePort)
}</span>

func (v *Validator) ValidatePodDisruptionBudget(pdb *policyv1.PodDisruptionBudget) error <span class="cov2" title="2">{
        return v.validateNotNil(pdb, errors.ErrNilPodDisruptionBudget)
}</span>

// Other Resources Validation

func (v *Validator) ValidateKustomization(k *types.Kustomization) error <span class="cov2" title="2">{
        return v.validateNotNil(k, errors.ErrNilKustomization)
}</span>

// Flux Resources Validation

func (v *Validator) ValidateFluxInstance(fi *fluxv1.FluxInstance) error <span class="cov2" title="2">{
        return v.validateNotNil(fi, errors.ErrNilFluxInstance)
}</span>

// MetalLB Resources Validation

func (v *Validator) ValidateIPAddressPool(pool *metallbv1beta1.IPAddressPool) error <span class="cov2" title="2">{
        return v.validateNotNil(pool, errors.ErrNilIPAddressPool)
}</span>

func (v *Validator) ValidateBGPPeer(peer *metallbv1beta1.BGPPeer) error <span class="cov2" title="2">{
        return v.validateNotNil(peer, errors.ErrNilBGPPeer)
}</span>

func (v *Validator) ValidateBGPAdvertisement(adv *metallbv1beta1.BGPAdvertisement) error <span class="cov2" title="2">{
        return v.validateNotNil(adv, errors.ErrNilBGPAdvertisement)
}</span>

func (v *Validator) ValidateL2Advertisement(adv *metallbv1beta1.L2Advertisement) error <span class="cov2" title="2">{
        return v.validateNotNil(adv, errors.ErrNilL2Advertisement)
}</span>

func (v *Validator) ValidateBFDProfile(profile *metallbv1beta1.BFDProfile) error <span class="cov2" title="2">{
        return v.validateNotNil(profile, errors.ErrNilBFDProfile)
}</span>

// Compound validation methods for common patterns

// ValidateDeploymentWithSpec validates both deployment and its core spec components
func (v *Validator) ValidateDeploymentWithSpec(deployment *appsv1.Deployment, spec *corev1.PodSpec) error <span class="cov4" title="5">{
        if err := v.ValidateDeployment(deployment); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov3" title="4">if spec != nil </span><span class="cov2" title="2">{
                return v.ValidatePodSpec(spec)
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// ValidatePodSpecWithContainer validates PodSpec and Container together
func (v *Validator) ValidatePodSpecWithContainer(spec *corev1.PodSpec, container *corev1.Container) error <span class="cov3" title="4">{
        if err := v.ValidatePodSpec(spec); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov3" title="3">return v.ValidateContainer(container)</span>
}

// ValidateServiceWithPort validates Service and ServicePort together
func (v *Validator) ValidateServiceWithPort(service *corev1.Service, port *corev1.ServicePort) error <span class="cov3" title="3">{
        if err := v.ValidateService(service); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov2" title="2">return v.ValidateServicePort(port)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package cli

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/spf13/viper"
        "gopkg.in/yaml.v3"
)

// Config represents the kure configuration structure
type Config struct {
        // Default settings
        Defaults struct {
                Output    string `yaml:"output"`
                Namespace string `yaml:"namespace"`
                Verbose   bool   `yaml:"verbose"`
                Debug     bool   `yaml:"debug"`
        } `yaml:"defaults"`

        // Layout settings
        Layout struct {
                ManifestsDir        string `yaml:"manifestsDir"`
                BundleGrouping      string `yaml:"bundleGrouping"`
                ApplicationGrouping string `yaml:"applicationGrouping"`
                FluxPlacement       string `yaml:"fluxPlacement"`
        } `yaml:"layout"`

        // GitOps settings
        GitOps struct {
                Type       string `yaml:"type"`
                Repository string `yaml:"repository"`
                Branch     string `yaml:"branch"`
                Path       string `yaml:"path"`
        } `yaml:"gitops"`
}

// NewDefaultConfig returns a config with default values
func NewDefaultConfig() *Config <span class="cov10" title="10">{
        config := &amp;Config{}

        // Set defaults
        config.Defaults.Output = "yaml"
        config.Defaults.Namespace = ""
        config.Defaults.Verbose = false
        config.Defaults.Debug = false

        // Layout defaults
        config.Layout.ManifestsDir = "manifests"
        config.Layout.BundleGrouping = "flat"
        config.Layout.ApplicationGrouping = "flat"
        config.Layout.FluxPlacement = "integrated"

        // GitOps defaults
        config.GitOps.Type = "flux"
        config.GitOps.Branch = "main"
        config.GitOps.Path = "clusters"

        return config
}</span>

// LoadConfig loads configuration from file
func LoadConfig(configFile string) (*Config, error) <span class="cov7" title="5">{
        config := NewDefaultConfig()

        if configFile == "" </span><span class="cov1" title="1">{
                return config, nil
        }</span>

        <span class="cov6" title="4">data, err := os.ReadFile(configFile)
        if err != nil </span><span class="cov1" title="1">{
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return config, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read config file: %w", err)</span>
        }

        <span class="cov5" title="3">if err := yaml.Unmarshal(data, config); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        <span class="cov3" title="2">return config, nil</span>
}

// SaveConfig saves configuration to file
func SaveConfig(config *Config, configFile string) error <span class="cov3" title="2">{
        // Create directory if it doesn't exist
        dir := filepath.Dir(configFile)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov3" title="2">data, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov3" title="2">if err := os.WriteFile(configFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// GetConfigPath returns the default config file path
func GetConfigPath() string <span class="cov5" title="3">{
        if configFile := viper.ConfigFileUsed(); configFile != "" </span><span class="cov5" title="3">{
                return configFile
        }</span>

        <span class="cov0" title="0">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return ".kure.yaml"
        }</span>

        <span class="cov0" title="0">return filepath.Join(home, ".kure.yaml")</span>
}

// EnsureConfigDir ensures the config directory exists
func EnsureConfigDir() error <span class="cov1" title="1">{
        configPath := GetConfigPath()
        dir := filepath.Dir(configPath)
        return os.MkdirAll(dir, 0755)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package cli

import (
        "io"
        "os"

        "github.com/go-kure/kure/pkg/cmd/shared/options"
)

// Factory provides access to common dependencies and configuration
type Factory interface {
        // Configuration
        GlobalOptions() *options.GlobalOptions

        // IO
        IOStreams() IOStreams

        // Validation
        Validate() error
}

// IOStreams represents the standard input, output, and error streams
type IOStreams struct {
        In     io.Reader
        Out    io.Writer
        ErrOut io.Writer
}

// NewIOStreams creates IOStreams with standard streams
func NewIOStreams() IOStreams <span class="cov10" title="10">{
        return IOStreams{
                In:     os.Stdin,
                Out:    os.Stdout,
                ErrOut: os.Stderr,
        }
}</span>

// factoryImpl implements the Factory interface
type factoryImpl struct {
        globalOpts *options.GlobalOptions
        ioStreams  IOStreams
}

// NewFactory creates a new Factory implementation
func NewFactory(globalOpts *options.GlobalOptions) Factory <span class="cov9" title="9">{
        return &amp;factoryImpl{
                globalOpts: globalOpts,
                ioStreams:  NewIOStreams(),
        }
}</span>

// GlobalOptions returns the global options
func (f *factoryImpl) GlobalOptions() *options.GlobalOptions <span class="cov3" title="2">{
        return f.globalOpts
}</span>

// IOStreams returns the IO streams
func (f *factoryImpl) IOStreams() IOStreams <span class="cov6" title="4">{
        return f.ioStreams
}</span>

// Validate validates the factory configuration
func (f *factoryImpl) Validate() error <span class="cov5" title="3">{
        return f.globalOpts.Validate()
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package cli

import (
        "encoding/json"
        "fmt"
        "io"
        "text/tabwriter"

        "gopkg.in/yaml.v3"
        "k8s.io/apimachinery/pkg/runtime"

        "github.com/go-kure/kure/pkg/cmd/shared/options"
)

// Printer interface for outputting resources
type Printer interface {
        Print(objects []runtime.Object, writer io.Writer) error
}

// PrinterOptions contains options for printing
type PrinterOptions struct {
        OutputFormat string
        NoHeaders    bool
        ShowLabels   bool
        Wide         bool
}

// NewPrinter creates a new printer based on global options
func NewPrinter(globalOpts *options.GlobalOptions) Printer <span class="cov6" title="7">{
        opts := PrinterOptions{
                OutputFormat: globalOpts.Output,
                NoHeaders:    globalOpts.NoHeaders,
                ShowLabels:   globalOpts.ShowLabels,
                Wide:         globalOpts.Wide,
        }

        switch globalOpts.Output </span>{
        case "json":<span class="cov1" title="1">
                return &amp;jsonPrinter{}</span>
        case "table", "wide":<span class="cov3" title="2">
                return &amp;tablePrinter{options: opts}</span>
        case "name":<span class="cov1" title="1">
                return &amp;namePrinter{}</span>
        default:<span class="cov4" title="3">
                return &amp;yamlPrinter{}</span>
        }
}

// yamlPrinter prints resources as YAML
type yamlPrinter struct{}

func (p *yamlPrinter) Print(objects []runtime.Object, writer io.Writer) error <span class="cov5" title="4">{
        if len(objects) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="3">for i, obj := range objects </span><span class="cov5" title="4">{
                if i &gt; 0 </span><span class="cov1" title="1">{
                        fmt.Fprintln(writer, "---")
                }</span>

                <span class="cov5" title="4">data, err := yaml.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal object to YAML: %w", err)
                }</span>

                <span class="cov5" title="4">if _, err := writer.Write(data); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write YAML: %w", err)
                }</span>
        }

        <span class="cov4" title="3">return nil</span>
}

// jsonPrinter prints resources as JSON
type jsonPrinter struct{}

func (p *jsonPrinter) Print(objects []runtime.Object, writer io.Writer) error <span class="cov5" title="4">{
        if len(objects) == 0 </span><span class="cov3" title="2">{
                fmt.Fprint(writer, "{}\n")
                return nil
        }</span>

        <span class="cov3" title="2">if len(objects) == 1 </span><span class="cov1" title="1">{
                return json.NewEncoder(writer).Encode(objects[0])
        }</span>

        // Multiple objects - wrap in array
        <span class="cov1" title="1">return json.NewEncoder(writer).Encode(objects)</span>
}

// tablePrinter prints resources in table format
type tablePrinter struct {
        options PrinterOptions
}

func (p *tablePrinter) Print(objects []runtime.Object, writer io.Writer) error <span class="cov5" title="5">{
        if len(objects) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov5" title="4">w := tabwriter.NewWriter(writer, 0, 0, 2, ' ', 0)
        defer w.Flush()

        // Print headers
        if !p.options.NoHeaders </span><span class="cov4" title="3">{
                headers := []string{"NAME", "KIND", "NAMESPACE"}
                if p.options.Wide </span><span class="cov1" title="1">{
                        headers = append(headers, "API-VERSION", "CREATED")
                }</span>
                <span class="cov4" title="3">if p.options.ShowLabels </span><span class="cov1" title="1">{
                        headers = append(headers, "LABELS")
                }</span>
                <span class="cov4" title="3">fmt.Fprintln(w, joinTabs(headers))</span>
        }

        // Print objects
        <span class="cov5" title="4">for _, obj := range objects </span><span class="cov5" title="4">{
                if unstructuredObj, ok := obj.(interface {
                        GetName() string
                        GetKind() string
                        GetNamespace() string
                        GetAPIVersion() string
                        GetLabels() map[string]string
                }); ok </span><span class="cov5" title="4">{
                        row := []string{
                                unstructuredObj.GetName(),
                                unstructuredObj.GetKind(),
                                unstructuredObj.GetNamespace(),
                        }

                        if p.options.Wide </span><span class="cov1" title="1">{
                                row = append(row, unstructuredObj.GetAPIVersion(), "&lt;unknown&gt;")
                        }</span>

                        <span class="cov5" title="4">if p.options.ShowLabels </span><span class="cov1" title="1">{
                                labels := formatLabels(unstructuredObj.GetLabels())
                                row = append(row, labels)
                        }</span>

                        <span class="cov5" title="4">fmt.Fprintln(w, joinTabs(row))</span>
                }
        }

        <span class="cov5" title="4">return nil</span>
}

// namePrinter prints only resource names
type namePrinter struct{}

func (p *namePrinter) Print(objects []runtime.Object, writer io.Writer) error <span class="cov1" title="1">{
        for _, obj := range objects </span><span class="cov3" title="2">{
                if namedObj, ok := obj.(interface {
                        GetName() string
                        GetKind() string
                }); ok </span><span class="cov3" title="2">{
                        fmt.Fprintf(writer, "%s/%s\n", namedObj.GetKind(), namedObj.GetName())
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// Helper functions
func joinTabs(strs []string) string <span class="cov7" title="10">{
        if len(strs) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov7" title="9">result := strs[0]
        for _, s := range strs[1:] </span><span class="cov10" title="22">{
                result += "\t" + s
        }</span>
        <span class="cov7" title="9">return result</span>
}

func formatLabels(labels map[string]string) string <span class="cov5" title="5">{
        if len(labels) == 0 </span><span class="cov3" title="2">{
                return "&lt;none&gt;"
        }</span>

        <span class="cov4" title="3">result := ""
        first := true
        for k, v := range labels </span><span class="cov5" title="4">{
                if !first </span><span class="cov1" title="1">{
                        result += ","
                }</span>
                <span class="cov5" title="4">result += k + "=" + v
                first = false</span>
        }
        <span class="cov4" title="3">return result</span>
}

// PrintObjects is a convenience function for printing objects
func PrintObjects(objects []runtime.Object, globalOpts *options.GlobalOptions, writer io.Writer) error <span class="cov1" title="1">{
        printer := NewPrinter(globalOpts)
        return printer.Print(objects, writer)
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package kure

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"

        "github.com/go-kure/kure/pkg/cmd/kure/generate"
        "github.com/go-kure/kure/pkg/cmd/shared"
        "github.com/go-kure/kure/pkg/cmd/shared/options"
)

// NewKureCommand creates the root command for kure CLI
func NewKureCommand() *cobra.Command <span class="cov9" title="15">{
        globalOpts := options.NewGlobalOptions()

        cmd := &amp;cobra.Command{
                Use:   "kure",
                Short: "A Go library for programmatically building Kubernetes resources",
                Long: `Kure is a Go library for programmatically building Kubernetes resources used by GitOps tools.

The library emphasizes strongly-typed object construction over templating engines,
supporting both Flux and ArgoCD workflows for GitOps-native resource management.`,
                SilenceUsage:  true,
                SilenceErrors: true,
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="10">{
                        return globalOpts.Complete()
                }</span>,
        }

        // Add global flags
        <span class="cov9" title="15">globalOpts.AddFlags(cmd.PersistentFlags())

        // Initialize configuration
        shared.InitConfig("kure", globalOpts)

        // Add subcommands
        cmd.AddCommand(
                newGenerateCommand(globalOpts),
                NewPatchCommand(globalOpts),
                newValidateCommand(globalOpts),
                newConfigCommand(globalOpts),
                shared.NewCompletionCommand(),
                shared.NewVersionCommand("kure"),
        )

        return cmd</span>
}

// Execute runs the root command
func Execute() <span class="cov0" title="0">{
        cmd := NewKureCommand()
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

func newGenerateCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov10" title="16">{
        return generate.NewGenerateCommand(globalOpts)
}</span>

func newValidateCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov10" title="16">{
        return &amp;cobra.Command{
                Use:   "validate",
                Short: "Validate configuration files",
                Long:  "Validate Kure configuration files for syntax and consistency",
        }
}</span>

func newConfigCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov10" title="16">{
        return &amp;cobra.Command{
                Use:   "config",
                Short: "Manage kure configuration",
                Long:  "View and modify kure configuration settings",
        }
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package generate

import (
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "gopkg.in/yaml.v3"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/cli"
        "github.com/go-kure/kure/pkg/errors"
        kio "github.com/go-kure/kure/pkg/io"
        "github.com/go-kure/kure/pkg/stack"
        _ "github.com/go-kure/kure/pkg/stack/generators/appworkload" // Register AppWorkload
        _ "github.com/go-kure/kure/pkg/stack/generators/fluxhelm"    // Register FluxHelm
)

// AppOptions contains options for the app command
type AppOptions struct {
        // Input options
        ConfigFiles []string
        InputDir    string

        // Output options
        OutputDir  string
        OutputFile string

        // Dependencies
        Factory   cli.Factory
        IOStreams cli.IOStreams
}

// NewAppCommand creates the app subcommand
func NewAppCommand(factory cli.Factory) *cobra.Command <span class="cov10" title="10">{
        o := &amp;AppOptions{
                Factory:   factory,
                IOStreams: factory.IOStreams(),
        }

        cmd := &amp;cobra.Command{
                Use:   "app [flags] CONFIG_FILE...",
                Short: "Generate application workload manifests",
                Long: `Generate application workload manifests from configuration files.

This command processes application workload configuration files and generates
Kubernetes manifests for deployments, services, and other application resources.

Examples:
  # Generate from single config file
  kure generate app app-config.yaml

  # Generate from multiple config files
  kure generate app app1.yaml app2.yaml app3.yaml

  # Generate from directory
  kure generate app --input-dir ./apps

  # Generate to specific output file
  kure generate app --output-file manifests.yaml app-config.yaml`,
                Args: cobra.ArbitraryArgs,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        o.ConfigFiles = args

                        if err := o.Complete(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := o.Validate(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return o.Run()</span>
                },
        }

        // Add flags
        <span class="cov10" title="10">o.AddFlags(cmd.Flags())

        return cmd</span>
}

// AddFlags adds flags to the command
func (o *AppOptions) AddFlags(flags *pflag.FlagSet) <span class="cov10" title="10">{
        flags.StringVarP(&amp;o.InputDir, "input-dir", "i", "", "input directory containing app config files")
        flags.StringVarP(&amp;o.OutputDir, "output-dir", "d", "out/apps", "output directory for generated manifests")
        flags.StringVar(&amp;o.OutputFile, "output-file", "", "output file for generated manifests (stdout if not specified)")
}</span>

// Complete completes the options
func (o *AppOptions) Complete() error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        // Use global output file if specified
        if globalOpts.OutputFile != "" </span><span class="cov0" title="0">{
                o.OutputFile = globalOpts.OutputFile
        }</span>

        // If input directory is specified, scan for config files
        <span class="cov0" title="0">if o.InputDir != "" </span><span class="cov0" title="0">{
                files, err := o.scanInputDirectory()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to scan input directory")
                }</span>
                <span class="cov0" title="0">o.ConfigFiles = append(o.ConfigFiles, files...)</span>
        }

        // Apply dry-run logic
        <span class="cov0" title="0">if globalOpts.DryRun &amp;&amp; o.OutputFile == "" </span><span class="cov0" title="0">{
                o.OutputFile = "/dev/stdout"
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validate validates the options
func (o *AppOptions) Validate() error <span class="cov0" title="0">{
        if len(o.ConfigFiles) == 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError("config-files", "empty", "Required", []string{"at least one config file or input directory"})
        }</span>

        // Validate all config files exist
        <span class="cov0" title="0">for _, file := range o.ConfigFiles </span><span class="cov0" title="0">{
                if _, err := os.Stat(file); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return errors.NewFileError("read", file, "file does not exist", errors.ErrFileNotFound)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Run executes the app command
func (o *AppOptions) Run() error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        if globalOpts.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Processing %d app config files\n", len(o.ConfigFiles))
        }</span>

        // Load all applications
        <span class="cov0" title="0">apps, err := o.loadApplications()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to load applications")
        }</span>

        <span class="cov0" title="0">if len(apps) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "No applications found in config files\n")
                return nil
        }</span>

        // Generate manifests
        <span class="cov0" title="0">resources, err := o.generateManifests(apps)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to generate manifests")
        }</span>

        // Write output
        <span class="cov0" title="0">if err := o.writeOutput(resources); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to write output")
        }</span>

        <span class="cov0" title="0">if globalOpts.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Generated %d resources for %d applications\n", len(resources), len(apps))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// scanInputDirectory scans the input directory for config files
func (o *AppOptions) scanInputDirectory() ([]string, error) <span class="cov0" title="0">{
        var files []string

        err := filepath.Walk(o.InputDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">ext := filepath.Ext(info.Name())
                if ext == ".yaml" || ext == ".yml" </span><span class="cov0" title="0">{
                        files = append(files, path)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return files, err</span>
}

// loadApplications loads all applications from config files
func (o *AppOptions) loadApplications() ([]*stack.Application, error) <span class="cov0" title="0">{
        var apps []*stack.Application

        for _, configFile := range o.ConfigFiles </span><span class="cov0" title="0">{
                fileApps, err := o.loadApplicationsFromFile(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewFileError("read", configFile, "failed to load applications", err)
                }</span>
                <span class="cov0" title="0">apps = append(apps, fileApps...)</span>
        }

        <span class="cov0" title="0">return apps, nil</span>
}

// loadApplicationsFromFile loads applications from a single config file
func (o *AppOptions) loadApplicationsFromFile(configFile string) ([]*stack.Application, error) <span class="cov0" title="0">{
        file, err := os.Open(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var apps []*stack.Application
        dec := yaml.NewDecoder(file)

        for </span><span class="cov0" title="0">{
                var wrapper stack.ApplicationWrapper
                if err := dec.Decode(&amp;wrapper); err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }

                <span class="cov0" title="0">app := wrapper.ToApplication()
                apps = append(apps, app)</span>
        }

        <span class="cov0" title="0">return apps, nil</span>
}

// generateManifests generates Kubernetes manifests from applications
func (o *AppOptions) generateManifests(apps []*stack.Application) ([]runtime.Object, error) <span class="cov0" title="0">{
        var allResources []runtime.Object

        for _, app := range apps </span><span class="cov0" title="0">{
                // Create a bundle for the application
                bundle, err := stack.NewBundle(app.Name, []*stack.Application{app}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to create bundle for app %s", app.Name)
                }</span>

                // Generate resources
                <span class="cov0" title="0">resources, err := bundle.Generate()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to generate resources for app %s", app.Name)
                }</span>

                // Convert to runtime.Object if needed
                <span class="cov0" title="0">for _, resource := range resources </span><span class="cov0" title="0">{
                        // resource is *client.Object, need to dereference it
                        if *resource != nil </span><span class="cov0" title="0">{
                                if runtimeObj, ok := (*resource).(runtime.Object); ok </span><span class="cov0" title="0">{
                                        allResources = append(allResources, runtimeObj)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return allResources, nil</span>
}

// writeOutput writes the generated resources to output
func (o *AppOptions) writeOutput(resources []runtime.Object) error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        // Convert to client.Object pointers
        clientObjects := make([]*client.Object, 0, len(resources))
        for _, resource := range resources </span><span class="cov0" title="0">{
                if clientObj, ok := resource.(client.Object); ok </span><span class="cov0" title="0">{
                        clientObjects = append(clientObjects, &amp;clientObj)
                }</span>
        }

        // Encode resources to YAML
        <span class="cov0" title="0">output, err := kio.EncodeObjectsToYAML(clientObjects)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to encode resources")
        }</span>

        // Determine output destination
        <span class="cov0" title="0">if o.OutputFile != "" </span><span class="cov0" title="0">{
                return o.writeToFile(output)
        }</span>

        <span class="cov0" title="0">if globalOpts.DryRun </span><span class="cov0" title="0">{
                _, err := o.IOStreams.Out.Write(output)
                return err
        }</span>

        // Write to directory structure
        <span class="cov0" title="0">return o.writeToDirectory(resources)</span>
}

// writeToFile writes output to a single file
func (o *AppOptions) writeToFile(output []byte) error <span class="cov0" title="0">{
        if o.OutputFile == "/dev/stdout" </span><span class="cov0" title="0">{
                _, err := o.IOStreams.Out.Write(output)
                return err
        }</span>

        // Create directory if needed
        <span class="cov0" title="0">dir := filepath.Dir(o.OutputFile)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(o.OutputFile, output, 0644)</span>
}

// writeToDirectory writes output to organized directory structure
func (o *AppOptions) writeToDirectory(resources []runtime.Object) error <span class="cov0" title="0">{
        // Clean output directory
        if err := os.RemoveAll(o.OutputDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Group resources by application
        <span class="cov0" title="0">appResources := make(map[string][]runtime.Object)

        for _, resource := range resources </span><span class="cov0" title="0">{
                appName := "unknown"
                if namedObj, ok := resource.(interface{ GetName() string }); ok </span><span class="cov0" title="0">{
                        appName = namedObj.GetName()
                }</span>
                <span class="cov0" title="0">appResources[appName] = append(appResources[appName], resource)</span>
        }

        // Write each application's resources to separate files
        <span class="cov0" title="0">for appName, appRes := range appResources </span><span class="cov0" title="0">{
                appDir := filepath.Join(o.OutputDir, appName)
                if err := os.MkdirAll(appDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Convert to client.Object pointers
                <span class="cov0" title="0">clientObjects := make([]*client.Object, 0, len(appRes))
                for _, resource := range appRes </span><span class="cov0" title="0">{
                        if clientObj, ok := resource.(client.Object); ok </span><span class="cov0" title="0">{
                                clientObjects = append(clientObjects, &amp;clientObj)
                        }</span>
                }

                <span class="cov0" title="0">output, err := kio.EncodeObjectsToYAML(clientObjects)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">fileName := fmt.Sprintf("%s-generated.yaml", appName)
                filePath := filepath.Join(appDir, fileName)

                if err := os.WriteFile(filePath, output, 0644); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package generate

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "gopkg.in/yaml.v3"

        "github.com/go-kure/kure/pkg/cli"
        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/layout"

        // Import implementations to register workflow factories
        _ "github.com/go-kure/kure/pkg/stack/argocd"
        _ "github.com/go-kure/kure/pkg/stack/fluxcd"
)

// BootstrapOptions contains options for the bootstrap command
type BootstrapOptions struct {
        // Input options
        ConfigFile string

        // Output options
        OutputDir   string
        ManifestDir string

        // Bootstrap options
        GitOpsType string
        FluxMode   string

        // Dependencies
        Factory   cli.Factory
        IOStreams cli.IOStreams
}

// NewBootstrapCommand creates the bootstrap subcommand
func NewBootstrapCommand(factory cli.Factory) *cobra.Command <span class="cov10" title="10">{
        o := &amp;BootstrapOptions{
                Factory:   factory,
                IOStreams: factory.IOStreams(),
        }

        cmd := &amp;cobra.Command{
                Use:   "bootstrap [flags] CONFIG_FILE",
                Short: "Generate bootstrap configurations for GitOps tools",
                Long: `Generate bootstrap configurations for GitOps tools like Flux or ArgoCD.

This command processes bootstrap configuration files and generates the necessary
manifests to bootstrap a GitOps workflow in a Kubernetes cluster.

Examples:
  # Generate Flux bootstrap configuration
  kure generate bootstrap examples/bootstrap/flux-operator.yaml

  # Generate ArgoCD bootstrap configuration  
  kure generate bootstrap examples/bootstrap/argocd.yaml

  # Generate with custom output directory
  kure generate bootstrap --output-dir ./bootstrap cluster.yaml

  # Generate with specific GitOps type
  kure generate bootstrap --gitops-type=flux --flux-mode=operator bootstrap.yaml`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        o.ConfigFile = args[0]

                        if err := o.Complete(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := o.Validate(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return o.Run()</span>
                },
        }

        // Add flags
        <span class="cov10" title="10">o.AddFlags(cmd.Flags())

        return cmd</span>
}

// AddFlags adds flags to the command
func (o *BootstrapOptions) AddFlags(flags *pflag.FlagSet) <span class="cov10" title="10">{
        flags.StringVarP(&amp;o.OutputDir, "output-dir", "d", "out/bootstrap", "output directory for generated manifests")
        flags.StringVarP(&amp;o.ManifestDir, "manifest-dir", "m", "", "manifests directory name in output")
        flags.StringVarP(&amp;o.GitOpsType, "gitops-type", "g", "", "GitOps tool type (flux|argocd) - auto-detected if not specified")
        flags.StringVar(&amp;o.FluxMode, "flux-mode", "", "Flux installation mode (operator|toolkit) - auto-detected if not specified")
}</span>

// Complete completes the options
func (o *BootstrapOptions) Complete() error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        // Apply dry-run logic
        if globalOpts.DryRun &amp;&amp; o.OutputDir == "out/bootstrap" </span><span class="cov0" title="0">{
                o.OutputDir = "/dev/stdout"
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validate validates the options
func (o *BootstrapOptions) Validate() error <span class="cov0" title="0">{
        // Validate config file exists
        if _, err := os.Stat(o.ConfigFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return errors.NewFileError("read", o.ConfigFile, "file does not exist", errors.ErrFileNotFound)
        }</span>

        // Validate GitOps type if specified
        <span class="cov0" title="0">if o.GitOpsType != "" </span><span class="cov0" title="0">{
                validTypes := []string{"flux", "argocd"}
                if !contains(validTypes, o.GitOpsType) </span><span class="cov0" title="0">{
                        return errors.NewValidationError("gitops-type", o.GitOpsType, "Options", validTypes)
                }</span>
        }

        // Validate Flux mode if specified
        <span class="cov0" title="0">if o.FluxMode != "" </span><span class="cov0" title="0">{
                validModes := []string{"operator", "toolkit"}
                if !contains(validModes, o.FluxMode) </span><span class="cov0" title="0">{
                        return errors.NewValidationError("flux-mode", o.FluxMode, "Options", validModes)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Run executes the bootstrap command
func (o *BootstrapOptions) Run() error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        if globalOpts.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Processing bootstrap config: %s\n", o.ConfigFile)
        }</span>

        // Load cluster configuration
        <span class="cov0" title="0">cluster, err := o.loadClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to load cluster config")
        }</span>

        // Detect GitOps type and mode if not specified
        <span class="cov0" title="0">if err := o.detectGitOpsSettings(cluster); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to detect GitOps settings")
        }</span>

        // Generate bootstrap manifests
        <span class="cov0" title="0">ml, err := o.generateBootstrap(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to generate bootstrap manifests")
        }</span>

        // Write output
        <span class="cov0" title="0">if err := o.writeOutput(ml, cluster); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to write output")
        }</span>

        <span class="cov0" title="0">if globalOpts.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Generated bootstrap manifests: %s\n", o.OutputDir)
                if cluster.GitOps != nil &amp;&amp; cluster.GitOps.Bootstrap != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(o.IOStreams.ErrOut, "GitOps type: %s\n", o.GitOpsType)
                        if o.GitOpsType == "flux" </span><span class="cov0" title="0">{
                                fmt.Fprintf(o.IOStreams.ErrOut, "Flux mode: %s\n", cluster.GitOps.Bootstrap.FluxMode)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// loadClusterConfig loads and parses the cluster configuration file
func (o *BootstrapOptions) loadClusterConfig() (*stack.Cluster, error) <span class="cov0" title="0">{
        file, err := os.Open(o.ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        dec := yaml.NewDecoder(file)
        var cluster stack.Cluster
        if err := dec.Decode(&amp;cluster); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Ensure basic structure for bootstrap
        <span class="cov0" title="0">if cluster.Node == nil </span><span class="cov0" title="0">{
                cluster.Node = &amp;stack.Node{Name: "flux-system"}
        }</span>
        <span class="cov0" title="0">if cluster.Node.Bundle == nil </span><span class="cov0" title="0">{
                cluster.Node.Bundle = &amp;stack.Bundle{Name: "infrastructure"}
        }</span>

        <span class="cov0" title="0">return &amp;cluster, nil</span>
}

// detectGitOpsSettings detects GitOps type and mode from configuration
func (o *BootstrapOptions) detectGitOpsSettings(cluster *stack.Cluster) error <span class="cov0" title="0">{
        // Override with command line flags if specified
        if o.GitOpsType != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Auto-detect from cluster configuration
        <span class="cov0" title="0">if cluster.GitOps != nil </span><span class="cov0" title="0">{
                o.GitOpsType = cluster.GitOps.Type

                if cluster.GitOps.Bootstrap != nil </span><span class="cov0" title="0">{
                        if o.FluxMode == "" </span><span class="cov0" title="0">{
                                o.FluxMode = cluster.GitOps.Bootstrap.FluxMode
                        }</span>
                }
        }

        // Default to flux if not specified
        <span class="cov0" title="0">if o.GitOpsType == "" </span><span class="cov0" title="0">{
                o.GitOpsType = "flux"
        }</span>

        // Default flux mode to operator if not specified
        <span class="cov0" title="0">if o.GitOpsType == "flux" &amp;&amp; o.FluxMode == "" </span><span class="cov0" title="0">{
                o.FluxMode = "operator"
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateBootstrap generates bootstrap manifests based on GitOps type
func (o *BootstrapOptions) generateBootstrap(cluster *stack.Cluster) (*layout.ManifestLayout, error) <span class="cov0" title="0">{
        rules := layout.DefaultLayoutRules()
        rules.FluxPlacement = layout.FluxSeparate

        switch o.GitOpsType </span>{
        case "argocd":<span class="cov0" title="0">
                return o.generateArgoCDBootstrap(cluster, rules)</span>
        case "flux":<span class="cov0" title="0">
                return o.generateFluxBootstrap(cluster, rules)</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewValidationError("gitops-type", o.GitOpsType, "Supported types", []string{"flux", "argocd"})</span>
        }
}

// generateArgoCDBootstrap generates ArgoCD bootstrap manifests
func (o *BootstrapOptions) generateArgoCDBootstrap(cluster *stack.Cluster, rules layout.LayoutRules) (*layout.ManifestLayout, error) <span class="cov0" title="0">{
        wf, err := stack.NewWorkflow("argocd")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Generate bootstrap resources directly
        <span class="cov0" title="0">bootstrapObjs, err := wf.GenerateBootstrap(cluster.GitOps.Bootstrap, cluster.Node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create a basic manifest layout for ArgoCD
        <span class="cov0" title="0">ml := &amp;layout.ManifestLayout{
                Name:      cluster.Node.Name,
                Namespace: cluster.Name,
                Resources: bootstrapObjs,
        }

        return ml, nil</span>
}

// generateFluxBootstrap generates Flux bootstrap manifests
func (o *BootstrapOptions) generateFluxBootstrap(cluster *stack.Cluster, rules layout.LayoutRules) (*layout.ManifestLayout, error) <span class="cov0" title="0">{
        wf, err := stack.NewWorkflow("flux")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := wf.CreateLayoutWithResources(cluster, rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ml, ok := result.(*layout.ManifestLayout)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.NewValidationError("result", "interface{}", "Expected", []string{"*layout.ManifestLayout"})
        }</span>

        <span class="cov0" title="0">return ml, nil</span>
}

// writeOutput writes the generated manifests to output
func (o *BootstrapOptions) writeOutput(ml *layout.ManifestLayout, cluster *stack.Cluster) error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        if globalOpts.DryRun </span><span class="cov0" title="0">{
                return o.printToStdout(ml)
        }</span>

        // Determine output directory structure
        <span class="cov0" title="0">configBaseName := strings.TrimSuffix(filepath.Base(o.ConfigFile), filepath.Ext(o.ConfigFile))
        outputDir := filepath.Join(o.OutputDir, configBaseName)

        // Clean and create output directory
        if err := os.RemoveAll(outputDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set manifest directory from config or use default
        <span class="cov0" title="0">manifestDir := o.ManifestDir
        if manifestDir == "" </span><span class="cov0" title="0">{
                manifestDir = ""
        }</span>

        // Write manifests
        <span class="cov0" title="0">cfg := layout.Config{ManifestsDir: manifestDir}
        return layout.WriteManifest(outputDir, cfg, ml)</span>
}

// printToStdout prints the manifests to stdout for dry-run
func (o *BootstrapOptions) printToStdout(ml *layout.ManifestLayout) error <span class="cov0" title="0">{
        fmt.Fprintf(o.IOStreams.Out, "# Generated bootstrap manifests for: %s\n", ml.Name)
        fmt.Fprintf(o.IOStreams.Out, "# GitOps type: %s\n", o.GitOpsType)
        if o.GitOpsType == "flux" </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.Out, "# Flux mode: %s\n", o.FluxMode)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(o.IOStreams.Out, "# Namespace: %s\n", ml.Namespace)
        fmt.Fprintf(o.IOStreams.Out, "# Resources: %d\n", len(ml.Resources))

        // Print basic info about resources
        for _, resource := range ml.Resources </span><span class="cov0" title="0">{
                if namedObj, ok := resource.(interface {
                        GetKind() string
                        GetName() string
                        GetNamespace() string
                }); ok </span><span class="cov0" title="0">{
                        fmt.Fprintf(o.IOStreams.Out, "# - %s/%s (%s)\n",
                                namedObj.GetKind(), namedObj.GetName(), namedObj.GetNamespace())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package generate

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "gopkg.in/yaml.v3"

        "github.com/go-kure/kure/pkg/cli"
        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/layout"

        // Import implementations to register workflow factories
        _ "github.com/go-kure/kure/pkg/stack/argocd"
        _ "github.com/go-kure/kure/pkg/stack/fluxcd"

        // Import generators to register them
        _ "github.com/go-kure/kure/pkg/stack/generators/appworkload"
        _ "github.com/go-kure/kure/pkg/stack/generators/fluxhelm"
)

// ClusterOptions contains options for the cluster command
type ClusterOptions struct {
        // Input options
        ConfigFile string
        InputDir   string

        // Output options
        OutputDir   string
        ManifestDir string

        // Layout options
        BundleGrouping      string
        ApplicationGrouping string
        FluxPlacement       string

        // Dependencies
        Factory   cli.Factory
        IOStreams cli.IOStreams
}

// NewClusterCommand creates the cluster subcommand
func NewClusterCommand(factory cli.Factory) *cobra.Command <span class="cov10" title="10">{
        o := &amp;ClusterOptions{
                Factory:   factory,
                IOStreams: factory.IOStreams(),
        }

        cmd := &amp;cobra.Command{
                Use:   "cluster [flags] CONFIG_FILE",
                Short: "Generate cluster manifests from configuration",
                Long: `Generate complete cluster manifests with GitOps configuration.

This command processes cluster configuration files and generates a complete
directory structure with Kubernetes manifests organized for GitOps workflows.

Examples:
  # Generate cluster from config file
  kure generate cluster examples/clusters/basic/cluster.yaml

  # Generate with custom output directory
  kure generate cluster --output-dir ./output cluster.yaml

  # Generate with different layout options
  kure generate cluster --bundle-grouping=nested --flux-placement=separate cluster.yaml`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        o.ConfigFile = args[0]

                        if err := o.Complete(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := o.Validate(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return o.Run()</span>
                },
        }

        // Add flags
        <span class="cov10" title="10">o.AddFlags(cmd.Flags())

        return cmd</span>
}

// AddFlags adds flags to the command
func (o *ClusterOptions) AddFlags(flags *pflag.FlagSet) <span class="cov10" title="10">{
        flags.StringVarP(&amp;o.OutputDir, "output-dir", "d", "out", "output directory for generated manifests")
        flags.StringVar(&amp;o.ManifestDir, "manifest-dir", "clusters", "manifests directory name in output")
        flags.StringVarP(&amp;o.BundleGrouping, "bundle-grouping", "b", "flat", "bundle grouping strategy (flat|nested)")
        flags.StringVarP(&amp;o.ApplicationGrouping, "application-grouping", "a", "flat", "application grouping strategy (flat|nested)")
        flags.StringVar(&amp;o.FluxPlacement, "flux-placement", "integrated", "flux placement strategy (integrated|separate)")
        flags.StringVarP(&amp;o.InputDir, "input-dir", "i", "", "input directory for loading app configs (defaults to config file directory)")
}</span>

// Complete completes the options
func (o *ClusterOptions) Complete() error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        // Set input directory default
        if o.InputDir == "" </span><span class="cov0" title="0">{
                o.InputDir = filepath.Dir(o.ConfigFile)
        }</span>

        // Apply dry-run logic
        <span class="cov0" title="0">if globalOpts.DryRun &amp;&amp; o.OutputDir == "out" </span><span class="cov0" title="0">{
                o.OutputDir = "/dev/stdout"
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validate validates the options
func (o *ClusterOptions) Validate() error <span class="cov0" title="0">{
        // Validate config file exists
        if _, err := os.Stat(o.ConfigFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return errors.NewFileError("read", o.ConfigFile, "file does not exist", errors.ErrFileNotFound)
        }</span>

        // Validate grouping options
        <span class="cov0" title="0">validGroupings := []string{"flat", "nested"}
        if !contains(validGroupings, o.BundleGrouping) </span><span class="cov0" title="0">{
                return errors.NewValidationError("bundle-grouping", o.BundleGrouping, "Options", validGroupings)
        }</span>
        <span class="cov0" title="0">if !contains(validGroupings, o.ApplicationGrouping) </span><span class="cov0" title="0">{
                return errors.NewValidationError("application-grouping", o.ApplicationGrouping, "Options", validGroupings)
        }</span>

        // Validate flux placement
        <span class="cov0" title="0">validPlacements := []string{"integrated", "separate"}
        if !contains(validPlacements, o.FluxPlacement) </span><span class="cov0" title="0">{
                return errors.NewValidationError("flux-placement", o.FluxPlacement, "Options", validPlacements)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Run executes the cluster command
func (o *ClusterOptions) Run() error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        if globalOpts.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Processing cluster config: %s\n", o.ConfigFile)
        }</span>

        // Load cluster configuration
        <span class="cov0" title="0">cluster, err := o.loadClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to load cluster config")
        }</span>

        // Load applications from input directory
        <span class="cov0" title="0">if err := o.loadClusterApps(cluster); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to load cluster apps")
        }</span>

        // Generate layout
        <span class="cov0" title="0">rules := o.buildLayoutRules(cluster)
        ml, err := o.generateLayout(cluster, rules)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to generate layout")
        }</span>

        // Write output
        <span class="cov0" title="0">if err := o.writeOutput(ml); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to write output")
        }</span>

        <span class="cov0" title="0">if globalOpts.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Generated cluster manifests: %s\n", o.OutputDir)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// loadClusterConfig loads and parses the cluster configuration file
func (o *ClusterOptions) loadClusterConfig() (*stack.Cluster, error) <span class="cov0" title="0">{
        file, err := os.Open(o.ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        dec := yaml.NewDecoder(file)
        var cluster stack.Cluster
        if err := dec.Decode(&amp;cluster); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cluster, nil</span>
}

// loadClusterApps loads application configurations for the cluster
func (o *ClusterOptions) loadClusterApps(cluster *stack.Cluster) error <span class="cov0" title="0">{
        if cluster.Node == nil </span><span class="cov0" title="0">{
                return errors.NewValidationError("cluster.node", "nil", "Expected", []string{"non-nil cluster node"})
        }</span>

        // Create root bundle
        <span class="cov0" title="0">rootBundle, err := stack.NewBundle(cluster.Node.Name, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cluster.Node.Bundle = rootBundle

        // Process child nodes
        for _, child := range cluster.Node.Children </span><span class="cov0" title="0">{
                child.SetParent(cluster.Node)
                childBundle, err := stack.NewBundle(child.Name, nil, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">child.Bundle = childBundle
                childBundle.SetParent(rootBundle)

                // Load apps for this node
                if err := o.loadNodeApps(child); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to load apps for node %s", child.Name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// loadNodeApps loads application configs for a specific node
func (o *ClusterOptions) loadNodeApps(node *stack.Node) error <span class="cov0" title="0">{
        nodeDir := filepath.Join(o.InputDir, node.Name)
        entries, err := os.ReadDir(nodeDir)
        if err != nil </span><span class="cov0" title="0">{
                // Directory might not exist for some nodes
                return nil
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ext := filepath.Ext(entry.Name())
                if ext != ".yaml" &amp;&amp; ext != ".yml" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">appConfigPath := filepath.Join(nodeDir, entry.Name())
                if err := o.loadAppConfig(node, appConfigPath); err != nil </span><span class="cov0" title="0">{
                        return errors.NewFileError("read", appConfigPath, "failed to load app config", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// loadAppConfig loads a single application configuration
func (o *ClusterOptions) loadAppConfig(node *stack.Node, configPath string) error <span class="cov0" title="0">{
        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        dec := yaml.NewDecoder(file)
        for </span><span class="cov0" title="0">{
                var wrapper stack.ApplicationWrapper
                if err := dec.Decode(&amp;wrapper); err != nil </span><span class="cov0" title="0">{
                        if err.Error() == "EOF" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">app := wrapper.ToApplication()
                bundle, err := stack.NewBundle(wrapper.Metadata.Name, []*stack.Application{app}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">bundle.SetParent(node.Bundle)

                childNode := &amp;stack.Node{Name: wrapper.Metadata.Name, Bundle: bundle}
                childNode.SetParent(node)
                node.Children = append(node.Children, childNode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// buildLayoutRules creates layout rules from options
func (o *ClusterOptions) buildLayoutRules(cluster *stack.Cluster) layout.LayoutRules <span class="cov0" title="0">{
        rules := layout.DefaultLayoutRules()
        rules.ClusterName = cluster.Name

        // Set grouping strategies
        switch o.BundleGrouping </span>{
        case "nested":<span class="cov0" title="0">
                rules.BundleGrouping = layout.GroupByName</span>
        default:<span class="cov0" title="0">
                rules.BundleGrouping = layout.GroupFlat</span>
        }

        <span class="cov0" title="0">switch o.ApplicationGrouping </span>{
        case "nested":<span class="cov0" title="0">
                rules.ApplicationGrouping = layout.GroupByName</span>
        default:<span class="cov0" title="0">
                rules.ApplicationGrouping = layout.GroupFlat</span>
        }

        // Set flux placement
        <span class="cov0" title="0">switch o.FluxPlacement </span>{
        case "separate":<span class="cov0" title="0">
                rules.FluxPlacement = layout.FluxSeparate</span>
        default:<span class="cov0" title="0">
                rules.FluxPlacement = layout.FluxIntegrated</span>
        }

        <span class="cov0" title="0">return rules</span>
}

// generateLayout generates the manifest layout
func (o *ClusterOptions) generateLayout(cluster *stack.Cluster, rules layout.LayoutRules) (*layout.ManifestLayout, error) <span class="cov0" title="0">{
        // Determine GitOps provider from cluster config
        provider := "flux" // default
        if cluster.GitOps != nil &amp;&amp; cluster.GitOps.Type != "" </span><span class="cov0" title="0">{
                provider = cluster.GitOps.Type
        }</span>

        // Create workflow using the interface
        <span class="cov0" title="0">wf, err := stack.NewWorkflow(provider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create workflow for provider %s", provider)
        }</span>

        <span class="cov0" title="0">result, err := wf.CreateLayoutWithResources(cluster, rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ml, ok := result.(*layout.ManifestLayout)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.NewValidationError("result", "interface{}", "Expected", []string{"*layout.ManifestLayout"})
        }</span>

        <span class="cov0" title="0">return ml, nil</span>
}

// writeOutput writes the generated manifests to output
func (o *ClusterOptions) writeOutput(ml *layout.ManifestLayout) error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        if globalOpts.DryRun </span><span class="cov0" title="0">{
                // For dry-run, print to stdout
                return o.printToStdout(ml)
        }</span>

        // Clean and create output directory
        <span class="cov0" title="0">if err := os.RemoveAll(o.OutputDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write manifests
        <span class="cov0" title="0">cfg := layout.Config{ManifestsDir: o.ManifestDir}
        return layout.WriteManifest(o.OutputDir, cfg, ml)</span>
}

// printToStdout prints the manifests to stdout for dry-run
func (o *ClusterOptions) printToStdout(ml *layout.ManifestLayout) error <span class="cov0" title="0">{
        // This is a simplified version - in a real implementation,
        // you'd want to serialize all the resources in the layout
        fmt.Fprintf(o.IOStreams.Out, "# Generated cluster manifests for: %s\n", ml.Name)
        fmt.Fprintf(o.IOStreams.Out, "# Namespace: %s\n", ml.Namespace)
        fmt.Fprintf(o.IOStreams.Out, "# Resources: %d\n", len(ml.Resources))

        // Print basic info about resources
        for _, resource := range ml.Resources </span><span class="cov0" title="0">{
                if namedObj, ok := resource.(interface {
                        GetKind() string
                        GetName() string
                        GetNamespace() string
                }); ok </span><span class="cov0" title="0">{
                        fmt.Fprintf(o.IOStreams.Out, "# - %s/%s (%s)\n",
                                namedObj.GetKind(), namedObj.GetName(), namedObj.GetNamespace())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper functions
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package generate

import (
        "github.com/spf13/cobra"

        "github.com/go-kure/kure/pkg/cli"
        "github.com/go-kure/kure/pkg/cmd/shared/options"
)

// NewGenerateCommand creates the generate command and its subcommands
func NewGenerateCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov10" title="9">{
        cmd := &amp;cobra.Command{
                Use:   "generate",
                Short: "Generate Kubernetes manifests",
                Long: `Generate Kubernetes manifests from configuration files using Kure builders.

The generate command supports multiple subcommands for different types of resources:
- cluster: Generate complete cluster manifests with GitOps configuration
- app: Generate application workload manifests
- bootstrap: Generate bootstrap configurations for GitOps tools`,
                Aliases: []string{"gen"},
        }

        // Create factory for dependency injection
        factory := cli.NewFactory(globalOpts)

        // Add subcommands
        cmd.AddCommand(
                NewClusterCommand(factory),
                NewAppCommand(factory),
                NewBootstrapCommand(factory),
        )

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package kure

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"

        "github.com/go-kure/kure/pkg/cli"
        "github.com/go-kure/kure/pkg/cmd/shared/options"
        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/patch"
)

// PatchOptions contains options for the patch command
type PatchOptions struct {
        // Input options
        BaseFile   string
        PatchFiles []string
        PatchDir   string

        // Output options
        OutputFile string
        OutputDir  string

        // Patch options
        ValidateOnly bool
        Interactive  bool

        // Dependencies
        Factory   cli.Factory
        IOStreams cli.IOStreams
}

// NewPatchCommand creates the top-level patch command
func NewPatchCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov9" title="18">{
        // Create factory for dependency injection
        factory := cli.NewFactory(globalOpts)
        o := &amp;PatchOptions{
                Factory:   factory,
                IOStreams: factory.IOStreams(),
        }

        cmd := &amp;cobra.Command{
                Use:   "patch [flags] BASE_FILE PATCH_FILE...",
                Short: "Apply patches to Kubernetes manifests",
                Long: `Apply patches to existing Kubernetes manifests using Kure's patch system.

This command applies declarative patches to base YAML files containing
Kubernetes resources, supporting JSONPath-based modifications.

Examples:
  # Apply single patch to base file
  kure patch base.yaml patch.yaml

  # Apply multiple patches
  kure patch base.yaml patch1.yaml patch2.yaml patch3.yaml

  # Apply all patches from directory
  kure patch --patch-dir ./patches base.yaml

  # Validate patches without applying
  kure patch --validate-only base.yaml patch.yaml

  # Apply patches interactively
  kure patch --interactive base.yaml`,
                Args: cobra.MinimumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        o.BaseFile = args[0]
                        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                                o.PatchFiles = args[1:]
                        }</span>

                        <span class="cov0" title="0">if err := o.Complete(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := o.Validate(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return o.Run()</span>
                },
        }

        // Add flags
        <span class="cov9" title="18">o.AddFlags(cmd.Flags())

        return cmd</span>
}

// AddFlags adds flags to the command
func (o *PatchOptions) AddFlags(flags *pflag.FlagSet) <span class="cov10" title="19">{
        flags.StringVarP(&amp;o.PatchDir, "patch-dir", "p", "", "directory containing patch files")
        flags.StringVar(&amp;o.OutputFile, "output-file", "", "output file for patched resources (stdout if not specified)")
        flags.StringVarP(&amp;o.OutputDir, "output-dir", "d", "out/patches", "output directory for patched resources")
        flags.BoolVar(&amp;o.ValidateOnly, "validate-only", false, "validate patches without applying them")
        flags.BoolVar(&amp;o.Interactive, "interactive", false, "interactive patch mode")
}</span>

// Complete completes the options
func (o *PatchOptions) Complete() error <span class="cov4" title="3">{
        globalOpts := o.Factory.GlobalOptions()

        // Use global output file if specified
        if globalOpts.OutputFile != "" </span><span class="cov1" title="1">{
                o.OutputFile = globalOpts.OutputFile
        }</span>

        // Scan patch directory if specified
        <span class="cov4" title="3">if o.PatchDir != "" </span><span class="cov0" title="0">{
                patchFiles, err := o.scanPatchDirectory()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan patch directory: %w", err)
                }</span>
                <span class="cov0" title="0">o.PatchFiles = append(o.PatchFiles, patchFiles...)</span>
        }

        // Apply dry-run logic
        <span class="cov4" title="3">if globalOpts.DryRun &amp;&amp; o.OutputFile == "" </span><span class="cov1" title="1">{
                o.OutputFile = "/dev/stdout"
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// Validate validates the options
func (o *PatchOptions) Validate() error <span class="cov5" title="5">{
        // Validate base file exists
        if _, err := os.Stat(o.BaseFile); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return errors.NewFileError("read", o.BaseFile, "file does not exist", errors.ErrFileNotFound)
        }</span>

        // For interactive mode, we don't need patch files
        <span class="cov5" title="4">if o.Interactive </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Validate we have patch files
        <span class="cov4" title="3">if len(o.PatchFiles) == 0 </span><span class="cov1" title="1">{
                return errors.NewValidationError("patches", "", "PatchOptions", []string{"patch-file", "patch-dir"})
        }</span>

        // Validate all patch files exist
        <span class="cov3" title="2">for _, file := range o.PatchFiles </span><span class="cov3" title="2">{
                if _, err := os.Stat(file); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return errors.NewFileError("read", file, "patch file does not exist", errors.ErrFileNotFound)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// Run executes the patch command
func (o *PatchOptions) Run() error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        if o.Interactive </span><span class="cov0" title="0">{
                return o.runInteractive()
        }</span>

        <span class="cov0" title="0">if o.ValidateOnly </span><span class="cov0" title="0">{
                return o.runValidation()
        }</span>

        <span class="cov0" title="0">if globalOpts.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Applying %d patches to %s\n", len(o.PatchFiles), o.BaseFile)
        }</span>

        // Load base resources
        <span class="cov0" title="0">documentSet, err := o.loadBaseResources()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load base resources: %w", err)
        }</span>

        // Apply patches
        <span class="cov0" title="0">patchedSet, err := o.applyPatches(documentSet)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply patches: %w", err)
        }</span>

        // Write output
        <span class="cov0" title="0">if err := o.writeOutput(patchedSet); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write output: %w", err)
        }</span>

        <span class="cov0" title="0">if globalOpts.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Successfully applied patches to %d resources\n", len(documentSet.Documents))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// scanPatchDirectory scans directory for patch files
func (o *PatchOptions) scanPatchDirectory() ([]string, error) <span class="cov1" title="1">{
        var patchFiles []string

        entries, err := os.ReadDir(o.PatchDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">for _, entry := range entries </span><span class="cov6" title="6">{
                if entry.IsDir() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov5" title="5">name := entry.Name()
                if strings.HasSuffix(name, ".kpatch") || strings.HasSuffix(name, ".yaml") || strings.HasSuffix(name, ".yml") </span><span class="cov4" title="3">{
                        patchFiles = append(patchFiles, filepath.Join(o.PatchDir, name))
                }</span>
        }

        <span class="cov1" title="1">return patchFiles, nil</span>
}

// runValidation validates patches without applying them
func (o *PatchOptions) runValidation() error <span class="cov1" title="1">{
        globalOpts := o.Factory.GlobalOptions()

        if globalOpts.Verbose </span><span class="cov1" title="1">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Validating %d patch files\n", len(o.PatchFiles))
        }</span>

        <span class="cov1" title="1">for _, patchFile := range o.PatchFiles </span><span class="cov1" title="1">{
                if err := o.validatePatchFile(patchFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation failed for %s: %w", patchFile, err)
                }</span>

                <span class="cov1" title="1">if globalOpts.Verbose </span><span class="cov1" title="1">{
                        fmt.Fprintf(o.IOStreams.ErrOut, "✓ %s\n", patchFile)
                }</span>
        }

        <span class="cov1" title="1">fmt.Fprintf(o.IOStreams.Out, "All patch files are valid\n")
        return nil</span>
}

// validatePatchFile validates a single patch file
func (o *PatchOptions) validatePatchFile(patchFile string) error <span class="cov5" title="4">{
        file, err := os.Open(patchFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="4">defer file.Close()

        _, err = patch.LoadPatchFile(file)
        return err</span>
}

// runInteractive runs interactive patch mode
func (o *PatchOptions) runInteractive() error <span class="cov0" title="0">{
        // Load base resources
        file, err := os.Open(o.BaseFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open base file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        resources, err := patch.LoadResourcesFromMultiYAML(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load base resources: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(o.IOStreams.Out, "=== Interactive Patch Mode ===\n")
        fmt.Fprintf(o.IOStreams.Out, "Loaded %d resources from %s\n", len(resources), o.BaseFile)
        fmt.Fprintf(o.IOStreams.Out, "Type 'help' for available commands\n\n")

        // This would implement the interactive loop similar to the existing main.go
        // For now, returning a placeholder
        return errors.ErrInteractiveMode</span>
}

// loadBaseResources loads and parses the base YAML file
func (o *PatchOptions) loadBaseResources() (*patch.YAMLDocumentSet, error) <span class="cov0" title="0">{
        file, err := os.Open(o.BaseFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return patch.LoadResourcesWithStructure(file)</span>
}

// applyPatches applies all patch files to the document set
func (o *PatchOptions) applyPatches(documentSet *patch.YAMLDocumentSet) (*patch.PatchableAppSet, error) <span class="cov0" title="0">{
        // Create patchable set
        patchableSet := &amp;patch.PatchableAppSet{
                Resources:   documentSet.GetResources(),
                DocumentSet: documentSet,
                Patches: make([]struct {
                        Target string
                        Patch  patch.PatchOp
                }, 0),
        }

        // Apply each patch file
        for _, patchFile := range o.PatchFiles </span><span class="cov0" title="0">{
                if err := o.applyPatchFile(patchableSet, patchFile); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply patch file %s: %w", patchFile, err)
                }</span>
        }

        <span class="cov0" title="0">return patchableSet, nil</span>
}

// applyPatchFile applies a single patch file to the patchable set
func (o *PatchOptions) applyPatchFile(patchableSet *patch.PatchableAppSet, patchFile string) error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        if globalOpts.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(o.IOStreams.ErrOut, "Applying patch: %s\n", patchFile)
        }</span>

        // For now, use the WritePatchedFiles method from the existing patch system
        <span class="cov0" title="0">outputDir := filepath.Join(o.OutputDir, "temp")
        return patchableSet.WritePatchedFiles(o.BaseFile, []string{patchFile}, outputDir)</span>
}

// writeOutput writes the patched resources to output
func (o *PatchOptions) writeOutput(patchableSet *patch.PatchableAppSet) error <span class="cov0" title="0">{
        globalOpts := o.Factory.GlobalOptions()

        if o.OutputFile != "" </span><span class="cov0" title="0">{
                return o.writeToFile(patchableSet)
        }</span>

        <span class="cov0" title="0">if globalOpts.DryRun </span><span class="cov0" title="0">{
                return o.writeToStdout(patchableSet)
        }</span>

        // Write to directory
        <span class="cov0" title="0">return o.writeToDirectory(patchableSet)</span>
}

// writeToFile writes output to a single file
func (o *PatchOptions) writeToFile(patchableSet *patch.PatchableAppSet) error <span class="cov0" title="0">{
        if o.OutputFile == "/dev/stdout" </span><span class="cov0" title="0">{
                return o.writeToStdout(patchableSet)
        }</span>

        // Create directory if needed
        <span class="cov0" title="0">dir := filepath.Dir(o.OutputFile)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use document set to write with preserved structure
        <span class="cov0" title="0">return patchableSet.DocumentSet.WriteToFile(o.OutputFile)</span>
}

// writeToStdout writes output to stdout
func (o *PatchOptions) writeToStdout(patchableSet *patch.PatchableAppSet) error <span class="cov0" title="0">{
        return patchableSet.DocumentSet.WriteToFile("/dev/stdout")
}</span>

// writeToDirectory writes output to organized directory structure
func (o *PatchOptions) writeToDirectory(patchableSet *patch.PatchableAppSet) error <span class="cov0" title="0">{
        // Clean output directory
        if err := os.RemoveAll(o.OutputDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create base filename from input
        <span class="cov0" title="0">baseName := strings.TrimSuffix(filepath.Base(o.BaseFile), filepath.Ext(o.BaseFile))
        outputFile := filepath.Join(o.OutputDir, baseName+"-patched.yaml")

        // Create directory
        if err := os.MkdirAll(o.OutputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write patched resources
        <span class="cov0" title="0">return patchableSet.DocumentSet.WriteToFile(outputFile)</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package kurel

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"

        "github.com/go-kure/kure/pkg/cmd/shared"
        "github.com/go-kure/kure/pkg/cmd/shared/options"
        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/launcher"
        "github.com/go-kure/kure/pkg/logger"
)

// NewKurelCommand creates the root command for kurel CLI
func NewKurelCommand() *cobra.Command <span class="cov9" title="15">{
        globalOpts := options.NewGlobalOptions()

        cmd := &amp;cobra.Command{
                Use:   "kurel",
                Short: "Kurel - Kubernetes Resources Launcher",
                Long: `Kurel is a CLI tool for launching and managing Kubernetes resources.
It extends the Kure library with deployment and resource management capabilities.

Kurel uses a package-based approach to create reusable, customizable Kubernetes 
applications without the complexity of templating engines.`,
                SilenceUsage:  true,
                SilenceErrors: true,
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="10">{
                        return globalOpts.Complete()
                }</span>,
        }

        // Add global flags
        <span class="cov9" title="15">globalOpts.AddFlags(cmd.PersistentFlags())

        // Initialize configuration
        shared.InitConfig("kurel", globalOpts)

        // Add subcommands
        cmd.AddCommand(
                newBuildCommand(globalOpts),
                newValidateCommand(globalOpts),
                newInfoCommand(globalOpts),
                newSchemaCommand(globalOpts),
                newConfigCommand(globalOpts),
                shared.NewCompletionCommand(),
                shared.NewVersionCommand("kurel"),
        )

        return cmd</span>
}

// Execute runs the root command
func Execute() <span class="cov0" title="0">{
        cmd := NewKurelCommand()
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

func newBuildCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov10" title="18">{
        var (
                outputPath   string
                valuesFile   string
                patches      []string
                outputFormat string
                filterKind   string
                filterName   string
                addLabels    map[string]string
        )

        cmd := &amp;cobra.Command{
                Use:   "build &lt;package&gt;",
                Short: "Build Kubernetes manifests from kurel package",
                Long: `Build generates Kubernetes manifests from a kurel package.

The build command processes the package structure, applies patches based on
configuration, and outputs phase-organized manifests ready for GitOps deployment.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Setup logger
                        log := logger.Default()
                        if globalOpts.Verbose </span><span class="cov0" title="0">{
                                log = logger.Default()
                        }</span> else<span class="cov0" title="0"> {
                                log = logger.Noop()
                        }</span>

                        // Create launcher components
                        <span class="cov0" title="0">loader := launcher.NewPackageLoader(log)
                        resolver := launcher.NewResolver(log)
                        processor := launcher.NewPatchProcessor(log, resolver)
                        builder := launcher.NewBuilder(log)
                        extension := launcher.NewExtensionLoader(log)

                        // Create launcher options
                        opts := launcher.DefaultOptions()
                        opts.Logger = log
                        opts.Verbose = globalOpts.Verbose

                        // Load package
                        ctx := context.Background()
                        packagePath := args[0]

                        def, err := loader.LoadDefinition(ctx, packagePath, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to load package")
                        }</span>

                        // Load values if provided
                        <span class="cov0" title="0">userValues := make(launcher.ParameterMap)
                        if valuesFile != "" </span><span class="cov0" title="0">{
                                data, err := os.ReadFile(valuesFile)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.NewFileError("read", valuesFile, "failed to read values file", err)
                                }</span>
                                <span class="cov0" title="0">if err := yaml.Unmarshal(data, &amp;userValues); err != nil </span><span class="cov0" title="0">{
                                        return errors.NewParseError(valuesFile, "invalid YAML", 0, 0, err)
                                }</span>
                        }

                        // Apply extensions
                        <span class="cov0" title="0">def, err = extension.LoadWithExtensions(ctx, def, "", opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to load extensions")
                        }</span>

                        // Resolve patch dependencies
                        <span class="cov0" title="0">enabledPatches, err := processor.ResolveDependencies(ctx, def.Patches, def.Parameters)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to resolve patch dependencies")
                        }</span>

                        // Create package instance
                        <span class="cov0" title="0">instance := &amp;launcher.PackageInstance{
                                Definition:     def,
                                UserValues:     userValues,
                                EnabledPatches: enabledPatches,
                        }

                        // Configure build options
                        buildOpts := launcher.BuildOptions{
                                FilterKind: filterKind,
                                FilterName: filterName,
                                AddLabels:  addLabels,
                        }

                        // Determine output
                        if outputPath != "" </span><span class="cov0" title="0">{
                                if info, err := os.Stat(outputPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                                        buildOpts.Output = launcher.OutputDirectory
                                }</span> else<span class="cov0" title="0"> {
                                        buildOpts.Output = launcher.OutputFile
                                }</span>
                                <span class="cov0" title="0">buildOpts.OutputPath = outputPath</span>
                        } else<span class="cov0" title="0"> {
                                buildOpts.Output = launcher.OutputStdout
                        }</span>

                        // Set format
                        <span class="cov0" title="0">switch strings.ToLower(outputFormat) </span>{
                        case "json":<span class="cov0" title="0">
                                buildOpts.Format = launcher.FormatJSON</span>
                        default:<span class="cov0" title="0">
                                buildOpts.Format = launcher.FormatYAML</span>
                        }

                        // Build manifests
                        <span class="cov0" title="0">return builder.Build(ctx, instance, buildOpts, opts)</span>
                },
        }

        // Add flags
        <span class="cov10" title="18">cmd.Flags().StringVarP(&amp;outputPath, "output", "o", "", "Output path (default: stdout)")
        cmd.Flags().StringVar(&amp;valuesFile, "values", "", "Values file for parameter overrides")
        cmd.Flags().StringSliceVarP(&amp;patches, "patch", "p", nil, "Enable specific patches")
        cmd.Flags().StringVar(&amp;outputFormat, "format", "yaml", "Output format (yaml, json)")
        cmd.Flags().StringVar(&amp;filterKind, "kind", "", "Filter by resource kind")
        cmd.Flags().StringVar(&amp;filterName, "name", "", "Filter by resource name")
        cmd.Flags().StringToStringVar(&amp;addLabels, "add-label", nil, "Add labels to all resources")

        return cmd</span>
}

func newValidateCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov9" title="16">{
        var (
                valuesFile string
                schemaFile string
                outputJSON bool
        )

        cmd := &amp;cobra.Command{
                Use:   "validate &lt;package&gt;",
                Short: "Validate kurel package structure and configuration",
                Long: `Validate checks the kurel package for structural correctness,
parameter validation, and patch consistency.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Setup logger
                        log := logger.Default()
                        if !globalOpts.Verbose </span><span class="cov0" title="0">{
                                log = logger.Noop()
                        }</span>

                        // Create launcher components
                        <span class="cov0" title="0">loader := launcher.NewPackageLoader(log)
                        validator := launcher.NewValidator(log)

                        // Create launcher options
                        opts := launcher.DefaultOptions()
                        opts.Logger = log
                        opts.Verbose = globalOpts.Verbose
                        opts.StrictMode = globalOpts.Strict

                        // Load package
                        ctx := context.Background()
                        packagePath := args[0]

                        def, err := loader.LoadDefinition(ctx, packagePath, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to load package")
                        }</span>

                        // Load values if provided
                        <span class="cov0" title="0">if valuesFile != "" </span><span class="cov0" title="0">{
                                var userValues launcher.ParameterMap
                                data, err := os.ReadFile(valuesFile)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.NewFileError("read", valuesFile, "failed to read values file", err)
                                }</span>
                                <span class="cov0" title="0">if err := yaml.Unmarshal(data, &amp;userValues); err != nil </span><span class="cov0" title="0">{
                                        return errors.NewParseError(valuesFile, "invalid YAML", 0, 0, err)
                                }</span>
                                // Merge user values into parameters for validation
                                <span class="cov0" title="0">for k, v := range userValues </span><span class="cov0" title="0">{
                                        def.Parameters[k] = v
                                }</span>
                        }

                        // Validate package
                        <span class="cov0" title="0">result, err := validator.ValidatePackage(ctx, def)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "validation failed")
                        }</span>

                        // Output results
                        <span class="cov0" title="0">if outputJSON </span><span class="cov0" title="0">{
                                encoder := json.NewEncoder(os.Stdout)
                                encoder.SetIndent("", "  ")
                                return encoder.Encode(result)
                        }</span>

                        // Text output
                        <span class="cov0" title="0">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Errors (%d):\n", len(result.Errors))
                                for _, e := range result.Errors </span><span class="cov0" title="0">{
                                        fmt.Printf("  ✗ %s\n", e.Error())
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }

                        <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Warnings (%d):\n", len(result.Warnings))
                                for _, w := range result.Warnings </span><span class="cov0" title="0">{
                                        fmt.Printf("  ⚠ %s\n", w.String())
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }

                        <span class="cov0" title="0">if result.IsValid() </span><span class="cov0" title="0">{
                                fmt.Println("✓ Package is valid")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("✗ Package has errors")
                                if opts.StrictMode </span><span class="cov0" title="0">{
                                        return errors.New("validation failed")
                                }</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        // Add flags
        <span class="cov9" title="16">cmd.Flags().StringVar(&amp;valuesFile, "values", "", "Values file for validation")
        cmd.Flags().StringVar(&amp;schemaFile, "schema", "", "Custom schema file")
        cmd.Flags().BoolVar(&amp;outputJSON, "json", false, "Output validation results as JSON")

        return cmd</span>
}

func newInfoCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov9" title="16">{
        var (
                outputFormat string
                showAll      bool
        )

        cmd := &amp;cobra.Command{
                Use:   "info &lt;package&gt;",
                Short: "Show package information",
                Long: `Info displays detailed information about a kurel package including
metadata, available patches, configurable parameters, and deployment phases.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Setup logger
                        log := logger.Default()
                        if !globalOpts.Verbose </span><span class="cov0" title="0">{
                                log = logger.Noop()
                        }</span>

                        // Create launcher components
                        <span class="cov0" title="0">loader := launcher.NewPackageLoader(log)

                        // Create launcher options
                        opts := launcher.DefaultOptions()
                        opts.Logger = log
                        opts.Verbose = globalOpts.Verbose

                        // Load package
                        ctx := context.Background()
                        packagePath := args[0]

                        def, err := loader.LoadDefinition(ctx, packagePath, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to load package")
                        }</span>

                        // Format output
                        <span class="cov0" title="0">switch outputFormat </span>{
                        case "json":<span class="cov0" title="0">
                                encoder := json.NewEncoder(os.Stdout)
                                encoder.SetIndent("", "  ")
                                return encoder.Encode(def)</span>

                        case "yaml":<span class="cov0" title="0">
                                encoder := yaml.NewEncoder(os.Stdout)
                                encoder.SetIndent(2)
                                return encoder.Encode(def)</span>

                        default:<span class="cov0" title="0"> // text
                                fmt.Printf("Package: %s\n", def.Metadata.Name)
                                fmt.Printf("Version: %s\n", def.Metadata.Version)
                                if def.Metadata.Description != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("Description: %s\n", def.Metadata.Description)
                                }</span>
                                <span class="cov0" title="0">fmt.Println()

                                if len(def.Parameters) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("Parameters (%d):\n", len(def.Parameters))
                                        for k, v := range def.Parameters </span><span class="cov0" title="0">{
                                                fmt.Printf("  %s: %v\n", k, formatParameterValue(v))
                                        }</span>
                                        <span class="cov0" title="0">fmt.Println()</span>
                                }

                                <span class="cov0" title="0">fmt.Printf("Resources (%d):\n", len(def.Resources))
                                for _, r := range def.Resources </span><span class="cov0" title="0">{
                                        fmt.Printf("  - %s/%s", r.Kind, r.GetName())
                                        if ns := r.GetNamespace(); ns != "" </span><span class="cov0" title="0">{
                                                fmt.Printf(" (namespace: %s)", ns)
                                        }</span>
                                        <span class="cov0" title="0">fmt.Println()</span>
                                }

                                <span class="cov0" title="0">if len(def.Patches) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("\nPatches (%d):\n", len(def.Patches))
                                        for _, p := range def.Patches </span><span class="cov0" title="0">{
                                                fmt.Printf("  - %s", p.Name)
                                                if p.Metadata != nil &amp;&amp; p.Metadata.Description != "" </span><span class="cov0" title="0">{
                                                        fmt.Printf(": %s", p.Metadata.Description)
                                                }</span>
                                                <span class="cov0" title="0">if p.Metadata != nil &amp;&amp; p.Metadata.Enabled != "" </span><span class="cov0" title="0">{
                                                        fmt.Printf(" [enabled: %s]", p.Metadata.Enabled)
                                                }</span>
                                                <span class="cov0" title="0">fmt.Println()</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        // Add flags
        <span class="cov9" title="16">cmd.Flags().StringVarP(&amp;outputFormat, "output", "o", "text", "Output format (text, yaml, json)")
        cmd.Flags().BoolVar(&amp;showAll, "all", false, "Show all details including resource content")

        return cmd</span>
}

func newSchemaCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov9" title="16">{
        schemaCmd := &amp;cobra.Command{
                Use:   "schema",
                Short: "Schema generation and validation commands",
                Long:  "Manage JSON schemas for kurel package validation",
        }

        // Add generate subcommand
        generateCmd := &amp;cobra.Command{
                Use:   "generate &lt;package&gt;",
                Short: "Generate JSON schema for package parameters",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        var (
                                outputPath string
                                includeK8s  bool
                                prettyPrint bool
                        )

                        // Get flags from command
                        outputPath, _ = cmd.Flags().GetString("output")
                        includeK8s, _ = cmd.Flags().GetBool("k8s")
                        prettyPrint, _ = cmd.Flags().GetBool("pretty")

                        // Setup logger
                        log := logger.Default()
                        if !globalOpts.Verbose </span><span class="cov0" title="0">{
                                log = logger.Noop()
                        }</span>

                        // Create launcher components
                        <span class="cov0" title="0">schemaGen := launcher.NewSchemaGenerator(log)

                        // Generate schema
                        ctx := context.Background()
                        schema, err := schemaGen.GeneratePackageSchemaWithOptions(ctx, &amp;launcher.SchemaOptions{
                                IncludeK8s: includeK8s,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to generate schema")
                        }</span>

                        // Export to JSON
                        <span class="cov0" title="0">data, err := schemaGen.ExportSchema(schema)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to export schema")
                        }</span>

                        // Pretty print if requested
                        <span class="cov0" title="0">if prettyPrint </span><span class="cov0" title="0">{
                                var obj interface{}
                                if err := json.Unmarshal(data, &amp;obj); err == nil </span><span class="cov0" title="0">{
                                        if pretty, err := json.MarshalIndent(obj, "", "  "); err == nil </span><span class="cov0" title="0">{
                                                data = pretty
                                        }</span>
                                }
                        }

                        // Write output
                        <span class="cov0" title="0">if outputPath != "" </span><span class="cov0" title="0">{
                                dir := filepath.Dir(outputPath)
                                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "failed to create output directory")
                                }</span>
                                <span class="cov0" title="0">return os.WriteFile(outputPath, data, 0644)</span>
                        }

                        <span class="cov0" title="0">_, err = os.Stdout.Write(data)
                        return err</span>
                },
        }

        // Add flags to generate command
        <span class="cov9" title="16">generateCmd.Flags().StringP("output", "o", "", "Output path (default: stdout)")
        generateCmd.Flags().Bool("k8s", false, "Include Kubernetes resource schemas")
        generateCmd.Flags().Bool("pretty", true, "Pretty print JSON output")

        schemaCmd.AddCommand(generateCmd)

        return schemaCmd</span>
}

// formatParameterValue formats a parameter value for display
func formatParameterValue(v interface{}) string <span class="cov0" title="0">{
        switch val := v.(type) </span>{
        case string:<span class="cov0" title="0">
                if strings.Contains(val, "\n") </span><span class="cov0" title="0">{
                        return "(multiline)"
                }</span>
                <span class="cov0" title="0">return val</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return fmt.Sprintf("(map with %d keys)", len(val))</span>
        case []interface{}:<span class="cov0" title="0">
                return fmt.Sprintf("(array with %d items)", len(val))</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val)</span>
        }
}

func newConfigCommand(globalOpts *options.GlobalOptions) *cobra.Command <span class="cov9" title="16">{
        configCmd := &amp;cobra.Command{
                Use:   "config",
                Short: "Manage kurel configuration",
                Long:  "View and modify kurel configuration settings",
        }

        // Add view subcommand
        configCmd.AddCommand(&amp;cobra.Command{
                Use:   "view",
                Short: "View current configuration",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Println("Configuration:")
                        fmt.Printf("  Verbose: %v\n", globalOpts.Verbose)
                        fmt.Printf("  Debug: %v\n", globalOpts.Debug)
                        fmt.Printf("  Strict: %v\n", globalOpts.Strict)
                        fmt.Printf("  Config File: %s\n", globalOpts.ConfigFile)
                }</span>,
        })

        // Add init subcommand
        <span class="cov9" title="16">configCmd.AddCommand(&amp;cobra.Command{
                Use:   "init",
                Short: "Initialize configuration file",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        configPath := filepath.Join(".kurel", "config.yaml")
                        if globalOpts.ConfigFile != "" </span><span class="cov0" title="0">{
                                configPath = globalOpts.ConfigFile
                        }</span>

                        <span class="cov0" title="0">dir := filepath.Dir(configPath)
                        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to create config directory")
                        }</span>

                        <span class="cov0" title="0">defaultConfig := `# Kurel Configuration
# For more information, see: https://github.com/go-kure/kure

# Global settings
verbose: false
debug: false
strict: false

# Launcher settings
launcher:
  maxDepth: 10
  timeout: 30s
  cacheEnabled: true
  cacheTTL: 1h

# Extension settings
extensions:
  enabled: true
  searchPaths:
    - .
    - ~/.kurel/extensions
`
                        if err := os.WriteFile(configPath, []byte(defaultConfig), 0644); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to write config file")
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Configuration initialized at %s\n", configPath)
                        return nil</span>
                },
        })

        <span class="cov9" title="16">return configCmd</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package shared

import (
        "os"

        "github.com/spf13/cobra"
)

// NewCompletionCommand creates a completion command for any CLI
func NewCompletionCommand() *cobra.Command <span class="cov10" title="9">{
        return &amp;cobra.Command{
                Use:   "completion [bash|zsh|fish|powershell]",
                Short: "Generate completion script",
                Long: `Generate the autocompletion script for the specified shell.
See each sub-command's help for details on how to use the generated script.`,
                DisableFlagsInUseLine: true,
                ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},
                Args:                  cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov6" title="4">{
                        switch args[0] </span>{
                        case "bash":<span class="cov1" title="1">
                                cmd.Root().GenBashCompletion(os.Stdout)</span>
                        case "zsh":<span class="cov1" title="1">
                                cmd.Root().GenZshCompletion(os.Stdout)</span>
                        case "fish":<span class="cov1" title="1">
                                cmd.Root().GenFishCompletion(os.Stdout, true)</span>
                        case "powershell":<span class="cov1" title="1">
                                cmd.Root().GenPowerShellCompletion(os.Stdout)</span>
                        }
                },
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package shared

import (
        "fmt"
        "os"

        "github.com/go-kure/kure/pkg/cmd/shared/options"
        "github.com/spf13/viper"
)

// InitConfig initializes Viper configuration for any CLI
func InitConfig(appName string, globalOpts *options.GlobalOptions) <span class="cov10" title="10">{
        if globalOpts.ConfigFile != "" </span><span class="cov7" title="5">{
                viper.SetConfigFile(globalOpts.ConfigFile)
        }</span> else<span class="cov7" title="5"> {
                // Search for config in home directory
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov1" title="1">{
                        return
                }</span>

                // Search config in home directory with name ".{appname}" (without extension)
                <span class="cov6" title="4">viper.AddConfigPath(home)
                viper.AddConfigPath(".")
                viper.SetConfigName(fmt.Sprintf(".%s", appName))
                viper.SetConfigType("yaml")</span>
        }

        // Environment variable prefix (uppercase app name)
        <span class="cov9" title="9">viper.SetEnvPrefix(appName)
        viper.AutomaticEnv()

        // Read config file if found
        if err := viper.ReadInConfig(); err == nil &amp;&amp; globalOpts.Verbose </span><span class="cov1" title="1">{
                fmt.Fprintf(os.Stderr, "Using config file: %s\n", viper.ConfigFileUsed())
        }</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package options

import (
        "os"

        "github.com/spf13/pflag"
        "github.com/spf13/viper"

        "github.com/go-kure/kure/pkg/errors"
)

// GlobalOptions contains global flags and configuration
type GlobalOptions struct {
        // Configuration
        ConfigFile string
        Verbose    bool
        Debug      bool
        Strict     bool

        // Output options
        Output     string
        OutputFile string
        NoHeaders  bool
        ShowLabels bool
        Wide       bool

        // Common flags
        DryRun    bool
        Namespace string
}

// NewGlobalOptions creates a new GlobalOptions with defaults
func NewGlobalOptions() *GlobalOptions <span class="cov4" title="5">{
        return &amp;GlobalOptions{
                Output:    "yaml",
                Verbose:   false,
                Debug:     false,
                DryRun:    false,
                Namespace: "",
        }
}</span>

// AddFlags adds global flags to the provided FlagSet
func (o *GlobalOptions) AddFlags(flags *pflag.FlagSet) <span class="cov3" title="3">{
        // Configuration flags
        flags.StringVarP(&amp;o.ConfigFile, "config", "c", o.ConfigFile, "config file (default is $HOME/.kure.yaml)")
        flags.BoolVarP(&amp;o.Verbose, "verbose", "v", o.Verbose, "verbose output")
        flags.BoolVar(&amp;o.Debug, "debug", o.Debug, "debug output")
        flags.BoolVar(&amp;o.Strict, "strict", o.Strict, "treat warnings as errors")

        // Output flags
        flags.StringVarP(&amp;o.Output, "output", "o", o.Output, "output format (yaml|json|table|wide|name)")
        flags.StringVarP(&amp;o.OutputFile, "output-file", "f", o.OutputFile, "write output to file instead of stdout")
        flags.BoolVar(&amp;o.NoHeaders, "no-headers", o.NoHeaders, "don't print headers (for table output)")
        flags.BoolVar(&amp;o.ShowLabels, "show-labels", o.ShowLabels, "show resource labels in table output")
        flags.BoolVar(&amp;o.Wide, "wide", o.Wide, "use wide output format")

        // Common flags
        flags.BoolVar(&amp;o.DryRun, "dry-run", o.DryRun, "print generated resources without writing to files")
        flags.StringVarP(&amp;o.Namespace, "namespace", "n", o.Namespace, "target namespace for operations")
}</span>

// Complete completes the global options by reading from configuration
func (o *GlobalOptions) Complete() error <span class="cov5" title="6">{
        // Override with viper values if available
        if viper.IsSet("verbose") </span><span class="cov1" title="1">{
                o.Verbose = viper.GetBool("verbose")
        }</span>
        <span class="cov5" title="6">if viper.IsSet("debug") </span><span class="cov2" title="2">{
                o.Debug = viper.GetBool("debug")
        }</span>
        <span class="cov5" title="6">if viper.IsSet("output") </span><span class="cov3" title="3">{
                o.Output = viper.GetString("output")
        }</span>
        <span class="cov5" title="6">if viper.IsSet("namespace") </span><span class="cov1" title="1">{
                o.Namespace = viper.GetString("namespace")
        }</span>

        // Set debug logging if requested
        <span class="cov5" title="6">if o.Debug </span><span class="cov2" title="2">{
                os.Setenv("KURE_DEBUG", "1")
                o.Verbose = true
        }</span>

        <span class="cov5" title="6">return o.Validate()</span>
}

// Validate validates the global options
func (o *GlobalOptions) Validate() error <span class="cov7" title="13">{
        // Validate output format
        validOutputs := []string{"yaml", "json", "table", "wide", "name"}
        valid := false
        for _, format := range validOutputs </span><span class="cov10" title="40">{
                if o.Output == format </span><span class="cov6" title="9">{
                        valid = true
                        break</span>
                }
        }
        <span class="cov7" title="13">if !valid </span><span class="cov4" title="4">{
                return errors.NewValidationError("output", o.Output, "GlobalOptions", validOutputs)
        }</span>

        // Adjust wide flag based on output format
        <span class="cov6" title="9">if o.Output == "wide" </span><span class="cov1" title="1">{
                o.Wide = true
                o.Output = "table"
        }</span>

        <span class="cov6" title="9">return nil</span>
}

// IsTableOutput returns true if output format requires table formatting
func (o *GlobalOptions) IsTableOutput() bool <span class="cov5" title="7">{
        return o.Output == "table" || o.Output == "wide" || o.Output == "name"
}</span>

// IsJSONOutput returns true if output format is JSON
func (o *GlobalOptions) IsJSONOutput() bool <span class="cov5" title="7">{
        return o.Output == "json"
}</span>

// IsYAMLOutput returns true if output format is YAML
func (o *GlobalOptions) IsYAMLOutput() bool <span class="cov5" title="7">{
        return o.Output == "yaml"
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package shared

import (
        "fmt"
        "runtime"

        "github.com/spf13/cobra"
)

// Version information that gets injected during build
var (
        Version   = "dev"
        GitCommit = "unknown"
        BuildDate = "unknown"
)

// NewVersionCommand creates a version command for any CLI
func NewVersionCommand(appName string) *cobra.Command <span class="cov10" title="8">{
        return &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information",
                Long:  fmt.Sprintf("Print the version number of %s", appName),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov9" title="7">{
                        fmt.Printf("%s version %s\n", appName, Version)
                        fmt.Printf("  Git commit: %s\n", GitCommit)
                        fmt.Printf("  Build date: %s\n", BuildDate)
                        fmt.Printf("  Go version: %s\n", runtime.Version())
                        fmt.Printf("  OS/Arch: %s/%s\n", runtime.GOOS, runtime.GOARCH)
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package errors

import (
        "errors"
        "fmt"
        "strings"
)

// Wrap wraps an error with a message using Go's standard error wrapping.
func Wrap(err error, message string) error <span class="cov3" title="3">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov2" title="2">return fmt.Errorf("%s: %w", message, err)</span>
}

// Wrapf wraps an error with a formatted message using Go's standard error wrapping.
func Wrapf(err error, format string, args ...interface{}) error <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return fmt.Errorf(format+": %w", append(args, err)...)</span>
}

// Errorf creates a new formatted error using Go's standard error formatting.
func Errorf(format string, args ...interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf(format, args...)
}</span>

// New creates a new error with the given message.
func New(message string) error <span class="cov0" title="0">{
        return errors.New(message)
}</span>

// Standard error variables using the standard library
var (
        ErrGVKNotFound   = errors.New("could not determine GroupVersionKind")
        ErrGVKNotAllowed = errors.New("GroupVersionKind is not allowed")
        ErrNilObject     = errors.New("provided object is nil")
)

// Common Kubernetes resource validation errors
var (
        // Nil resource errors
        ErrNilDeployment     = ResourceValidationError("Deployment", "", "deployment", "deployment cannot be nil", nil)
        ErrNilPod            = ResourceValidationError("Pod", "", "pod", "pod cannot be nil", nil)
        ErrNilPodSpec        = ResourceValidationError("PodSpec", "", "spec", "pod spec cannot be nil", nil)
        ErrNilContainer      = ResourceValidationError("Container", "", "container", "container cannot be nil", nil)
        ErrNilStatefulSet    = ResourceValidationError("StatefulSet", "", "statefulset", "statefulset cannot be nil", nil)
        ErrNilDaemonSet      = ResourceValidationError("DaemonSet", "", "daemonset", "daemonset cannot be nil", nil)
        ErrNilJob            = ResourceValidationError("Job", "", "job", "job cannot be nil", nil)
        ErrNilCronJob        = ResourceValidationError("CronJob", "", "cronjob", "cronjob cannot be nil", nil)
        ErrNilService        = ResourceValidationError("Service", "", "service", "service cannot be nil", nil)
        ErrNilSecret         = ResourceValidationError("Secret", "", "secret", "secret cannot be nil", nil)
        ErrNilConfigMap      = ResourceValidationError("ConfigMap", "", "configmap", "configmap cannot be nil", nil)
        ErrNilServiceAccount = ResourceValidationError("ServiceAccount", "", "serviceaccount", "serviceaccount cannot be nil", nil)
        ErrNilIngress        = ResourceValidationError("Ingress", "", "ingress", "ingress cannot be nil", nil)
        ErrNilBundle         = ResourceValidationError("Bundle", "", "bundle", "bundle cannot be nil", nil)

        // Common field validation errors
        ErrNilSpec               = ResourceValidationError("Resource", "", "spec", "spec cannot be nil", nil)
        ErrNilInitContainer      = ResourceValidationError("PodSpec", "", "container", "init container cannot be nil", nil)
        ErrNilEphemeralContainer = ResourceValidationError("PodSpec", "", "container", "ephemeral container cannot be nil", nil)
        ErrNilVolume             = ResourceValidationError("PodSpec", "", "volume", "volume cannot be nil", nil)
        ErrNilImagePullSecret    = ResourceValidationError("PodSpec", "", "secret", "image pull secret cannot be nil", nil)
        ErrNilToleration         = ResourceValidationError("PodSpec", "", "toleration", "toleration cannot be nil", nil)

        // Additional resource errors
        ErrNilNamespace           = ResourceValidationError("Namespace", "", "namespace", "namespace cannot be nil", nil)
        ErrNilRole                = ResourceValidationError("Role", "", "role", "role cannot be nil", nil)
        ErrNilClusterRole         = ResourceValidationError("ClusterRole", "", "clusterrole", "cluster role cannot be nil", nil)
        ErrNilRoleBinding         = ResourceValidationError("RoleBinding", "", "rolebinding", "role binding cannot be nil", nil)
        ErrNilClusterRoleBinding  = ResourceValidationError("ClusterRoleBinding", "", "clusterrolebinding", "cluster role binding cannot be nil", nil)
        ErrNilServicePort         = ResourceValidationError("Service", "", "port", "service port cannot be nil", nil)
        ErrNilPodDisruptionBudget = ResourceValidationError("PodDisruptionBudget", "", "pdb", "pod disruption budget cannot be nil", nil)
        ErrNilKustomization       = ResourceValidationError("Kustomization", "", "kustomization", "kustomization cannot be nil", nil)

        // Flux resources
        ErrNilFluxInstance = ResourceValidationError("FluxInstance", "", "fluxinstance", "flux instance cannot be nil", nil)

        // MetalLB resources
        ErrNilIPAddressPool    = ResourceValidationError("IPAddressPool", "", "ipaddresspool", "ip address pool cannot be nil", nil)
        ErrNilBGPPeer          = ResourceValidationError("BGPPeer", "", "bgppeer", "bgp peer cannot be nil", nil)
        ErrNilBGPAdvertisement = ResourceValidationError("BGPAdvertisement", "", "bgpadvertisement", "bgp advertisement cannot be nil", nil)
        ErrNilL2Advertisement  = ResourceValidationError("L2Advertisement", "", "l2advertisement", "l2 advertisement cannot be nil", nil)
        ErrNilBFDProfile       = ResourceValidationError("BFDProfile", "", "bfdprofile", "bfd profile cannot be nil", nil)
)

// Common file operation errors
var (
        ErrFileNotFound      = errors.New("file not found")
        ErrDirectoryNotFound = errors.New("directory not found")
        ErrInvalidPath       = errors.New("invalid file path")
)

// Common parse/processing errors
var (
        ErrNilRuntimeObject   = errors.New("nil runtime object provided")
        ErrSchemeRegistration = errors.New("failed to register schemes")
        ErrUnsupportedKind    = errors.New("unsupported object kind")
        ErrInteractiveMode    = errors.New("interactive mode not yet implemented")
)

// Common configuration errors
var (
        ErrInvalidOutputFormat = errors.New("invalid output format")
        ErrInvalidGrouping     = errors.New("invalid grouping option")
        ErrInvalidPlacement    = errors.New("invalid placement option")
)

// ErrorType represents the category of error
type ErrorType string

const (
        ErrorTypeValidation    ErrorType = "validation"
        ErrorTypeResource      ErrorType = "resource"
        ErrorTypePatch         ErrorType = "patch"
        ErrorTypeParse         ErrorType = "parse"
        ErrorTypeFile          ErrorType = "file"
        ErrorTypeConfiguration ErrorType = "configuration"
        ErrorTypeInternal      ErrorType = "internal"
)

// KureError is the base interface for all Kure-specific errors
type KureError interface {
        error
        Type() ErrorType
        Suggestion() string
        Context() map[string]interface{}
}

// BaseError provides common functionality for all Kure errors
type BaseError struct {
        ErrType    ErrorType              `json:"type"`
        Message    string                 `json:"message"`
        Cause      error                  `json:"cause,omitempty"`
        ErrContext map[string]interface{} `json:"context,omitempty"`
        Help       string                 `json:"suggestion,omitempty"`
}

func (e *BaseError) Error() string <span class="cov7" title="12">{
        if e.Cause != nil </span><span class="cov6" title="8">{
                return fmt.Sprintf("%s: %v", e.Message, e.Cause)
        }</span>
        <span class="cov4" title="4">return e.Message</span>
}

func (e *BaseError) Type() ErrorType <span class="cov7" title="15">{
        return e.ErrType
}</span>

func (e *BaseError) Suggestion() string <span class="cov6" title="10">{
        return e.Help
}</span>

func (e *BaseError) Context() map[string]interface{} <span class="cov4" title="4">{
        return e.ErrContext
}</span>

func (e *BaseError) Unwrap() error <span class="cov3" title="3">{
        return e.Cause
}</span>

// ValidationError represents validation failures with suggestions
type ValidationError struct {
        *BaseError
        Field       string   `json:"field"`
        Value       string   `json:"value"`
        ValidValues []string `json:"validValues,omitempty"`
        Component   string   `json:"component"`
}

func NewValidationError(field, value, component string, validValues []string) *ValidationError <span class="cov3" title="3">{
        help := ""
        if len(validValues) &gt; 0 </span><span class="cov2" title="2">{
                help = fmt.Sprintf("Valid values are: %s", strings.Join(validValues, ", "))
        }</span>

        <span class="cov3" title="3">return &amp;ValidationError{
                BaseError: &amp;BaseError{
                        ErrType: ErrorTypeValidation,
                        Message: fmt.Sprintf("invalid %s for %s: %s", field, component, value),
                        Help:    help,
                        ErrContext: map[string]interface{}{
                                "field":     field,
                                "value":     value,
                                "component": component,
                        },
                },
                Field:       field,
                Value:       value,
                ValidValues: validValues,
                Component:   component,
        }</span>
}

// ResourceError represents resource-related errors
type ResourceError struct {
        *BaseError
        ResourceType string   `json:"resourceType"`
        Name         string   `json:"name"`
        Namespace    string   `json:"namespace,omitempty"`
        Available    []string `json:"available,omitempty"`
}

func ResourceNotFoundError(resourceType, name, namespace string, available []string) *ResourceError <span class="cov3" title="3">{
        help := "Check that the resource exists and is spelled correctly"
        if len(available) &gt; 0 </span><span class="cov2" title="2">{
                help = fmt.Sprintf("Available resources: %s", strings.Join(available, ", "))
        }</span>

        <span class="cov3" title="3">message := fmt.Sprintf("%s '%s' not found", resourceType, name)
        if namespace != "" </span><span class="cov2" title="2">{
                message += fmt.Sprintf(" in namespace '%s'", namespace)
        }</span>

        <span class="cov3" title="3">return &amp;ResourceError{
                BaseError: &amp;BaseError{
                        ErrType: ErrorTypeResource,
                        Message: message,
                        Help:    help,
                        ErrContext: map[string]interface{}{
                                "resourceType": resourceType,
                                "name":         name,
                                "namespace":    namespace,
                        },
                },
                ResourceType: resourceType,
                Name:         name,
                Namespace:    namespace,
                Available:    available,
        }</span>
}

func ResourceValidationError(resourceType, name, field, reason string, cause error) *ResourceError <span class="cov10" title="35">{
        message := fmt.Sprintf("validation failed for %s '%s'", resourceType, name)
        if field != "" </span><span class="cov10" title="35">{
                message += fmt.Sprintf(" field '%s'", field)
        }</span>
        <span class="cov10" title="35">if reason != "" </span><span class="cov10" title="35">{
                message += fmt.Sprintf(": %s", reason)
        }</span>

        <span class="cov10" title="35">return &amp;ResourceError{
                BaseError: &amp;BaseError{
                        ErrType: ErrorTypeResource,
                        Message: message,
                        Cause:   cause,
                        Help:    "Check the resource specification and ensure all required fields are present",
                        ErrContext: map[string]interface{}{
                                "resourceType": resourceType,
                                "name":         name,
                                "field":        field,
                                "reason":       reason,
                        },
                },
                ResourceType: resourceType,
                Name:         name,
        }</span>
}

// PatchError represents patch-specific errors
type PatchError struct {
        *BaseError
        Operation    string `json:"operation"`
        Path         string `json:"path"`
        ResourceName string `json:"resourceName"`
}

func NewPatchError(operation, path, resourceName, reason string, cause error) *PatchError <span class="cov1" title="1">{
        message := fmt.Sprintf("patch operation '%s' failed", operation)
        if resourceName != "" </span><span class="cov1" title="1">{
                message += fmt.Sprintf(" on resource '%s'", resourceName)
        }</span>
        <span class="cov1" title="1">if path != "" </span><span class="cov1" title="1">{
                message += fmt.Sprintf(" at path '%s'", path)
        }</span>
        <span class="cov1" title="1">if reason != "" </span><span class="cov1" title="1">{
                message += fmt.Sprintf(": %s", reason)
        }</span>

        <span class="cov1" title="1">help := "Check the patch syntax and ensure the target path exists"
        if strings.Contains(reason, "not found") || strings.Contains(reason, "missing") </span><span class="cov1" title="1">{
                help = "Verify the resource name and path are correct, or use graceful mode to skip missing targets"
        }</span>

        <span class="cov1" title="1">return &amp;PatchError{
                BaseError: &amp;BaseError{
                        ErrType: ErrorTypePatch,
                        Message: message,
                        Cause:   cause,
                        Help:    help,
                        ErrContext: map[string]interface{}{
                                "operation":    operation,
                                "path":         path,
                                "resourceName": resourceName,
                                "reason":       reason,
                        },
                },
                Operation:    operation,
                Path:         path,
                ResourceName: resourceName,
        }</span>
}

// ParseError represents parsing errors with location information
type ParseError struct {
        *BaseError
        Source string `json:"source"`
        Line   int    `json:"line,omitempty"`
        Column int    `json:"column,omitempty"`
}

func NewParseError(source, reason string, line, column int, cause error) *ParseError <span class="cov2" title="2">{
        message := fmt.Sprintf("parse error in %s", source)
        if line &gt; 0 </span><span class="cov2" title="2">{
                message += fmt.Sprintf(" at line %d", line)
                if column &gt; 0 </span><span class="cov1" title="1">{
                        message += fmt.Sprintf(", column %d", column)
                }</span>
        }
        <span class="cov2" title="2">if reason != "" </span><span class="cov2" title="2">{
                message += fmt.Sprintf(": %s", reason)
        }</span>

        <span class="cov2" title="2">help := "Check the file syntax and format"
        if strings.Contains(reason, "YAML") || strings.Contains(reason, "yaml") </span><span class="cov1" title="1">{
                help = "Verify YAML syntax, check indentation and special characters"
        }</span> else<span class="cov1" title="1"> if strings.Contains(reason, "JSON") || strings.Contains(reason, "json") </span><span class="cov0" title="0">{
                help = "Verify JSON syntax, check brackets and commas"
        }</span>

        <span class="cov2" title="2">return &amp;ParseError{
                BaseError: &amp;BaseError{
                        ErrType: ErrorTypeParse,
                        Message: message,
                        Cause:   cause,
                        Help:    help,
                        ErrContext: map[string]interface{}{
                                "source": source,
                                "line":   line,
                                "column": column,
                                "reason": reason,
                        },
                },
                Source: source,
                Line:   line,
                Column: column,
        }</span>
}

// FileError represents file operation errors
type FileError struct {
        *BaseError
        Operation string `json:"operation"`
        Path      string `json:"path"`
}

func NewFileError(operation, path, reason string, cause error) *FileError <span class="cov4" title="4">{
        message := fmt.Sprintf("file %s failed for '%s'", operation, path)
        if reason != "" </span><span class="cov4" title="4">{
                message += fmt.Sprintf(": %s", reason)
        }</span>

        <span class="cov4" title="4">help := getFileErrorSuggestion(operation, cause)

        return &amp;FileError{
                BaseError: &amp;BaseError{
                        ErrType: ErrorTypeFile,
                        Message: message,
                        Cause:   cause,
                        Help:    help,
                        ErrContext: map[string]interface{}{
                                "operation": operation,
                                "path":      path,
                                "reason":    reason,
                        },
                },
                Operation: operation,
                Path:      path,
        }</span>
}

func getFileErrorSuggestion(operation string, cause error) string <span class="cov4" title="4">{
        if cause == nil </span><span class="cov0" title="0">{
                return "Check file path and permissions"
        }</span>

        <span class="cov4" title="4">errMsg := cause.Error()
        switch </span>{
        case strings.Contains(errMsg, "permission denied"):<span class="cov1" title="1">
                return "Check file permissions and ensure you have appropriate access"</span>
        case strings.Contains(errMsg, "no such file"):<span class="cov1" title="1">
                return "Verify the file path exists and is spelled correctly"</span>
        case strings.Contains(errMsg, "is a directory"):<span class="cov1" title="1">
                return "The path points to a directory, specify a file instead"</span>
        case strings.Contains(errMsg, "disk") || strings.Contains(errMsg, "space"):<span class="cov1" title="1">
                return "Check available disk space"</span>
        default:<span class="cov0" title="0">
                return "Check file path and permissions"</span>
        }
}

// ConfigError represents configuration errors
type ConfigError struct {
        *BaseError
        Source      string   `json:"source"`
        Field       string   `json:"field"`
        ValidValues []string `json:"validValues,omitempty"`
}

func NewConfigError(source, field, value, reason string, validValues []string) *ConfigError <span class="cov1" title="1">{
        message := fmt.Sprintf("configuration error in %s", source)
        if field != "" </span><span class="cov1" title="1">{
                message += fmt.Sprintf(" for field '%s'", field)
        }</span>
        <span class="cov1" title="1">if value != "" </span><span class="cov1" title="1">{
                message += fmt.Sprintf(" with value '%s'", value)
        }</span>
        <span class="cov1" title="1">if reason != "" </span><span class="cov1" title="1">{
                message += fmt.Sprintf(": %s", reason)
        }</span>

        <span class="cov1" title="1">help := "Check the configuration syntax and values"
        if len(validValues) &gt; 0 </span><span class="cov1" title="1">{
                help = fmt.Sprintf("Valid values for %s: %s", field, strings.Join(validValues, ", "))
        }</span>

        <span class="cov1" title="1">return &amp;ConfigError{
                BaseError: &amp;BaseError{
                        ErrType: ErrorTypeConfiguration,
                        Message: message,
                        Help:    help,
                        ErrContext: map[string]interface{}{
                                "source": source,
                                "field":  field,
                                "value":  value,
                                "reason": reason,
                        },
                },
                Source:      source,
                Field:       field,
                ValidValues: validValues,
        }</span>
}

// IsKureError checks if an error is a Kure-specific error
func IsKureError(err error) bool <span class="cov3" title="3">{
        _, ok := err.(KureError)
        return ok
}</span>

// GetKureError extracts a KureError from an error chain
func GetKureError(err error) KureError <span class="cov5" title="5">{
        var kureErr KureError
        if errors.As(err, &amp;kureErr) </span><span class="cov4" title="4">{
                return kureErr
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// IsType checks if an error is of a specific Kure error type
func IsType(err error, errType ErrorType) bool <span class="cov2" title="2">{
        kureErr := GetKureError(err)
        if kureErr == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="2">return kureErr.Type() == errType</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package errors

import "strings"

// ParseErrors aggregates multiple errors returned during YAML decoding.
// It implements the error interface and unwraps to the underlying errors.
type ParseErrors struct {
        Errors []error
}

func (pe *ParseErrors) Error() string <span class="cov0" title="0">{
        if len(pe.Errors) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if len(pe.Errors) == 1 </span><span class="cov0" title="0">{
                return pe.Errors[0].Error()
        }</span>
        <span class="cov0" title="0">var b strings.Builder
        b.WriteString("multiple parse errors:")
        for _, err := range pe.Errors </span><span class="cov0" title="0">{
                b.WriteString(" ")
                b.WriteString(err.Error())
                b.WriteString(";")
        }</span>
        <span class="cov0" title="0">return strings.TrimSuffix(b.String(), ";")</span>
}

func (pe *ParseErrors) Unwrap() []error <span class="cov0" title="0">{
        return pe.Errors
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package io

import (
        "fmt"
        "io"
        "strings"
        "time"

        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/cli-runtime/pkg/printers"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/errors"
)

// OutputFormat represents the supported output formats for printing resources
type OutputFormat string

const (
        OutputFormatYAML  OutputFormat = "yaml"
        OutputFormatJSON  OutputFormat = "json"
        OutputFormatTable OutputFormat = "table"
        OutputFormatWide  OutputFormat = "wide"
        OutputFormatName  OutputFormat = "name"
)

// PrintOptions contains configuration for resource printing
type PrintOptions struct {
        // OutputFormat specifies the desired output format
        OutputFormat OutputFormat
        // NoHeaders suppresses table headers when true
        NoHeaders bool
        // ShowLabels displays resource labels in table output
        ShowLabels bool
        // ColumnLabels is a list of label keys to display as columns
        ColumnLabels []string
        // SortBy specifies the column to sort by (for table output)
        SortBy string
}

// ResourcePrinter provides a unified interface for printing Kubernetes resources
// in various formats, compatible with kubectl output styles
type ResourcePrinter struct {
        options PrintOptions
}

// NewResourcePrinter creates a new ResourcePrinter with the given options
func NewResourcePrinter(options PrintOptions) *ResourcePrinter <span class="cov8" title="7">{
        return &amp;ResourcePrinter{
                options: options,
        }
}</span>

// Print outputs the given resources to the writer using the configured format
func (rp *ResourcePrinter) Print(resources []*client.Object, w io.Writer) error <span class="cov8" title="7">{
        if len(resources) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="7">switch rp.options.OutputFormat </span>{
        case OutputFormatYAML:<span class="cov1" title="1">
                return rp.printYAML(resources, w)</span>
        case OutputFormatJSON:<span class="cov1" title="1">
                return rp.printJSON(resources, w)</span>
        case OutputFormatTable:<span class="cov1" title="1">
                return rp.printTable(resources, w, false)</span>
        case OutputFormatWide:<span class="cov0" title="0">
                return rp.printTable(resources, w, true)</span>
        case OutputFormatName:<span class="cov6" title="4">
                return rp.printNames(resources, w)</span>
        default:<span class="cov0" title="0">
                return errors.NewValidationError("OutputFormat", string(rp.options.OutputFormat), "ResourcePrinter", []string{"yaml", "json", "table", "wide", "name"})</span>
        }
}

// printYAML outputs resources in YAML format
func (rp *ResourcePrinter) printYAML(resources []*client.Object, w io.Writer) error <span class="cov1" title="1">{
        data, err := EncodeObjectsToYAML(resources)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "encode to YAML")
        }</span>
        <span class="cov1" title="1">_, err = w.Write(data)
        return err</span>
}

// printJSON outputs resources in JSON format
func (rp *ResourcePrinter) printJSON(resources []*client.Object, w io.Writer) error <span class="cov1" title="1">{
        data, err := EncodeObjectsToJSON(resources)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "encode to JSON")
        }</span>
        <span class="cov1" title="1">_, err = w.Write(data)
        return err</span>
}

// printNames outputs resource names in kubectl-compatible format
func (rp *ResourcePrinter) printNames(resources []*client.Object, w io.Writer) error <span class="cov6" title="4">{
        for _, obj := range resources </span><span class="cov6" title="4">{
                if obj == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="4">gvk := (*obj).GetObjectKind().GroupVersionKind()
                name := (*obj).GetName()
                namespace := (*obj).GetNamespace()

                // Format: kind/name or kind.group/name
                kind := strings.ToLower(gvk.Kind)
                if gvk.Group != "" </span><span class="cov0" title="0">{
                        kind = fmt.Sprintf("%s.%s", kind, gvk.Group)
                }</span>

                <span class="cov6" title="4">resourceName := fmt.Sprintf("%s/%s", kind, name)
                if namespace != "" </span><span class="cov6" title="4">{
                        fmt.Fprintf(w, "%s (namespace: %s)\n", resourceName, namespace)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(w, "%s\n", resourceName)
                }</span>
        }
        <span class="cov6" title="4">return nil</span>
}

// printTable outputs resources in table format using k8s.io/cli-runtime/pkg/printers
func (rp *ResourcePrinter) printTable(resources []*client.Object, w io.Writer, wide bool) error <span class="cov1" title="1">{
        if len(resources) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create a table printer
        <span class="cov1" title="1">printer := printers.NewTablePrinter(printers.PrintOptions{
                NoHeaders:     rp.options.NoHeaders,
                WithNamespace: true,
                Wide:          wide,
                ShowLabels:    rp.options.ShowLabels,
                ColumnLabels:  rp.options.ColumnLabels,
        })

        // Convert resources to runtime objects for the table printer
        runtimeObjects := make([]runtime.Object, 0, len(resources))
        for _, obj := range resources </span><span class="cov1" title="1">{
                if obj != nil </span><span class="cov1" title="1">{
                        runtimeObjects = append(runtimeObjects, *obj)
                }</span>
        }

        // Print each resource
        <span class="cov1" title="1">for _, obj := range runtimeObjects </span><span class="cov1" title="1">{
                if err := printer.PrintObj(obj, w); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "print object")
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// PrintSingle is a convenience function for printing a single resource
func (rp *ResourcePrinter) PrintSingle(resource client.Object, w io.Writer) error <span class="cov1" title="1">{
        if resource == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return rp.Print([]*client.Object{&amp;resource}, w)</span>
}

// FormatAge returns a human-readable age string for a resource
func FormatAge(t *metav1.Time) string <span class="cov10" title="12">{
        if t == nil </span><span class="cov1" title="1">{
                return "&lt;unknown&gt;"
        }</span>

        <span class="cov9" title="11">duration := time.Since(t.Time)
        if duration.Seconds() &lt; 60 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%.0fs", duration.Seconds())
        }</span>
        <span class="cov9" title="10">if duration.Minutes() &lt; 60 </span><span class="cov8" title="8">{
                return fmt.Sprintf("%.0fm", duration.Minutes())
        }</span>
        <span class="cov3" title="2">if duration.Hours() &lt; 24 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%.0fh", duration.Hours())
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%.0fd", duration.Hours()/24)</span>
}

// GetResourceAge returns the age of a resource based on its creation timestamp
func GetResourceAge(obj client.Object) string <span class="cov8" title="8">{
        if obj == nil </span><span class="cov1" title="1">{
                return "&lt;unknown&gt;"
        }</span>

        <span class="cov8" title="7">accessor, err := meta.Accessor(obj)
        if err != nil </span><span class="cov0" title="0">{
                return "&lt;unknown&gt;"
        }</span>

        <span class="cov8" title="7">creationTime := accessor.GetCreationTimestamp()
        return FormatAge(&amp;creationTime)</span>
}

// GetResourceStatus attempts to extract a status string from common status fields
func GetResourceStatus(obj client.Object) string <span class="cov9" title="10">{
        if obj == nil </span><span class="cov1" title="1">{
                return "Unknown"
        }</span>

        // Try to get status from common fields using unstructured access
        <span class="cov8" title="9">unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>

        <span class="cov8" title="9">statusVal, found := unstructured.UnstructuredContent()["status"]
        if !found </span><span class="cov8" title="7">{
                return "Unknown"
        }</span>

        <span class="cov3" title="2">statusMap, ok := statusVal.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>

        // Look for common status indicators
        <span class="cov3" title="2">if phase, ok := statusMap["phase"]; ok </span><span class="cov1" title="1">{
                if phaseStr, ok := phase.(string); ok </span><span class="cov1" title="1">{
                        return phaseStr
                }</span>
        }

        <span class="cov1" title="1">if ready, ok := statusMap["ready"]; ok </span><span class="cov0" title="0">{
                if readyBool, ok := ready.(bool); ok </span><span class="cov0" title="0">{
                        if readyBool </span><span class="cov0" title="0">{
                                return "Ready"
                        }</span>
                        <span class="cov0" title="0">return "NotReady"</span>
                }
        }

        // Check conditions for Ready status
        <span class="cov1" title="1">if conditions, ok := statusMap["conditions"]; ok </span><span class="cov1" title="1">{
                if conditionsSlice, ok := conditions.([]interface{}); ok </span><span class="cov1" title="1">{
                        for _, condition := range conditionsSlice </span><span class="cov1" title="1">{
                                if condMap, ok := condition.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                                        if condType, ok := condMap["type"].(string); ok &amp;&amp; condType == "Ready" </span><span class="cov1" title="1">{
                                                if statusVal, ok := condMap["status"].(string); ok </span><span class="cov1" title="1">{
                                                        if statusVal == "True" </span><span class="cov1" title="1">{
                                                                return "Ready"
                                                        }</span>
                                                        <span class="cov0" title="0">return "NotReady"</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return "Unknown"</span>
}

// NewTablePrinter creates a table printer configured for Kure resources
func NewTablePrinter(options PrintOptions) *ResourcePrinter <span class="cov1" title="1">{
        // Ensure table format for table printer
        if options.OutputFormat != OutputFormatTable &amp;&amp; options.OutputFormat != OutputFormatWide </span><span class="cov1" title="1">{
                options.OutputFormat = OutputFormatTable
        }</span>

        <span class="cov1" title="1">return NewResourcePrinter(options)</span>
}

// PrintToString returns the printed output as a string instead of writing to a writer
func (rp *ResourcePrinter) PrintToString(resources []*client.Object) (string, error) <span class="cov1" title="1">{
        var buf strings.Builder
        err := rp.Print(resources, &amp;buf)
        return buf.String(), err
}</span>

// ValidateOutputFormat checks if the given format string is valid
func ValidateOutputFormat(format string) (OutputFormat, error) <span class="cov8" title="8">{
        switch strings.ToLower(format) </span>{
        case "yaml", "yml":<span class="cov3" title="2">
                return OutputFormatYAML, nil</span>
        case "json":<span class="cov1" title="1">
                return OutputFormatJSON, nil</span>
        case "table":<span class="cov1" title="1">
                return OutputFormatTable, nil</span>
        case "wide":<span class="cov1" title="1">
                return OutputFormatWide, nil</span>
        case "name":<span class="cov1" title="1">
                return OutputFormatName, nil</span>
        default:<span class="cov3" title="2">
                return "", errors.NewValidationError("format", format, "ParseOutputFormat", []string{"yaml", "json", "table", "wide", "name"})</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package io

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "reflect"

        "k8s.io/apimachinery/pkg/runtime"
        yamlutil "k8s.io/apimachinery/pkg/util/yaml"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/kubernetes"
)

func parse(yamlbytes []byte) ([]client.Object, error) <span class="cov5" title="4">{

        // Parsing approach adapted from
        // https://dx13.co.uk/articles/2021/01/15/kubernetes-types-using-go/

        decoder := yamlutil.NewYAMLOrJSONDecoder(bytes.NewReader(yamlbytes), 4096)
        retVal := make([]runtime.Object, 0)

        if err := kubernetes.RegisterSchemes(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "register schemes")
        }</span>
        <span class="cov5" title="4">decode := kubernetes.Codecs.UniversalDeserializer().Decode

        var errs []error

        for </span><span class="cov10" title="17">{
                var raw runtime.RawExtension
                if err := decoder.Decode(&amp;raw); err != nil </span><span class="cov5" title="4">{
                        if err == io.EOF </span><span class="cov5" title="4">{
                                break</span>
                        }
                        <span class="cov0" title="0">errs = append(errs, errors.NewParseError("YAML document", "failed to decode document", 0, 0, err))
                        continue</span>
                }
                <span class="cov9" title="13">if len(bytes.TrimSpace(raw.Raw)) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov9" title="13">obj, _, err := decode(raw.Raw, nil, nil)
                if err != nil </span><span class="cov3" title="2">{
                        errs = append(errs, errors.NewParseError("Kubernetes object", "failed to decode object", 0, 0, err))
                        continue</span>
                }
                <span class="cov8" title="11">if err := checkType(obj); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }
                <span class="cov8" title="11">retVal = append(retVal, obj)</span>
        }

        <span class="cov5" title="4">retValCO := make([]client.Object, len(retVal))
        for i, obj := range retVal </span><span class="cov8" title="11">{
                retValCO[i] = obj.(client.Object)
        }</span>
        <span class="cov5" title="4">if len(errs) &gt; 0 </span><span class="cov1" title="1">{
                return retValCO, &amp;errors.ParseErrors{Errors: errs}
        }</span>
        <span class="cov4" title="3">return retValCO, nil</span>
}

// ParseFile reads the YAML file at path and returns the runtime objects
// defined within. Each object is decoded using the k8s scheme. An error is
// returned if the file cannot be read or if decoding any document fails.
func ParseFile(path string) ([]client.Object, error) <span class="cov1" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return parse(data)</span>
}

// ParseYAML parses YAML bytes and returns the runtime objects
// defined within. Each object is decoded using the k8s scheme. An error is
// returned if decoding any document fails.
func ParseYAML(data []byte) ([]client.Object, error) <span class="cov0" title="0">{
        return parse(data)
}</span>

func checkType(obj runtime.Object) error <span class="cov9" title="14">{
        if obj == nil </span><span class="cov0" title="0">{
                return errors.ErrNilRuntimeObject
        }</span>

        <span class="cov9" title="14">gvk := obj.GetObjectKind().GroupVersionKind()
        if err := kubernetes.RegisterSchemes(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "register schemes")
        }</span>
        <span class="cov9" title="14">expected, ok := kubernetes.Scheme.AllKnownTypes()[gvk]
        if !ok </span><span class="cov1" title="1">{
                return errors.Wrapf(errors.ErrUnsupportedKind, "kind %s", gvk.String())
        }</span>

        <span class="cov9" title="13">objType := reflect.TypeOf(obj)
        if objType != expected &amp;&amp; objType != reflect.PointerTo(expected) </span><span class="cov1" title="1">{
                return errors.NewParseError("Kubernetes object", fmt.Sprintf("kind %s expected type %v but got %T", gvk.Kind, expected, obj), 0, 0, nil)
        }</span>

        <span class="cov8" title="12">return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package io

import (
        "fmt"
        "io"
        "sort"
        "strings"
        "text/tabwriter"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// TableColumn represents a column in table output
type TableColumn struct {
        Header   string
        Width    int
        Accessor func(client.Object) string
        Priority int  // Lower values are shown first, higher values in wide mode
        WideOnly bool // Only shown in wide output
}

// DefaultColumns returns the default column set for Kubernetes resources
func DefaultColumns() []TableColumn <span class="cov7" title="9">{
        return []TableColumn{
                {
                        Header:   "NAMESPACE",
                        Width:    12,
                        Priority: 0,
                        Accessor: func(obj client.Object) string </span><span class="cov6" title="6">{
                                ns := obj.GetNamespace()
                                if ns == "" </span><span class="cov0" title="0">{
                                        return "&lt;none&gt;"
                                }</span>
                                <span class="cov6" title="6">return ns</span>
                        },
                },
                {
                        Header:   "NAME",
                        Width:    20,
                        Priority: 1,
                        Accessor: func(obj client.Object) string <span class="cov6" title="6">{
                                return obj.GetName()
                        }</span>,
                },
                {
                        Header:   "READY",
                        Width:    8,
                        Priority: 2,
                        Accessor: func(obj client.Object) string <span class="cov6" title="6">{
                                return GetResourceStatus(obj)
                        }</span>,
                },
                {
                        Header:   "STATUS",
                        Width:    10,
                        Priority: 3,
                        WideOnly: true,
                        Accessor: func(obj client.Object) string <span class="cov1" title="1">{
                                // Additional status information for wide output
                                return GetDetailedStatus(obj)
                        }</span>,
                },
                {
                        Header:   "AGE",
                        Width:    8,
                        Priority: 10,
                        Accessor: func(obj client.Object) string <span class="cov6" title="6">{
                                return GetResourceAge(obj)
                        }</span>,
                },
        }
}

// KindSpecificColumns returns columns tailored for specific Kubernetes resource kinds
func KindSpecificColumns(gvk metav1.GroupVersionKind) []TableColumn <span class="cov4" title="3">{
        base := DefaultColumns()

        switch strings.ToLower(gvk.Kind) </span>{
        case "pod":<span class="cov1" title="1">
                return podColumns(base)</span>
        case "deployment":<span class="cov0" title="0">
                return deploymentColumns(base)</span>
        case "service":<span class="cov1" title="1">
                return serviceColumns(base)</span>
        case "configmap", "secret":<span class="cov1" title="1">
                return configColumns(base)</span>
        default:<span class="cov0" title="0">
                return base</span>
        }
}

// podColumns customizes columns for Pod resources
func podColumns(base []TableColumn) []TableColumn <span class="cov1" title="1">{
        // Insert pod-specific columns
        columns := make([]TableColumn, 0, len(base)+2)

        for _, col := range base </span><span class="cov5" title="5">{
                if col.Header == "READY" </span><span class="cov1" title="1">{
                        // Replace generic READY with pod-specific READY
                        col.Accessor = func(obj client.Object) string </span><span class="cov0" title="0">{
                                return getPodReadyStatus(obj)
                        }</span>
                        <span class="cov1" title="1">columns = append(columns, col)

                        // Add RESTARTS column after READY
                        columns = append(columns, TableColumn{
                                Header:   "RESTARTS",
                                Width:    8,
                                Priority: col.Priority + 1,
                                Accessor: func(obj client.Object) string </span><span class="cov0" title="0">{
                                        return getPodRestarts(obj)
                                }</span>,
                        })
                } else<span class="cov4" title="4"> {
                        if col.Priority &gt; 2 </span><span class="cov2" title="2">{
                                col.Priority++ // Shift priorities to make room for RESTARTS
                        }</span>
                        <span class="cov4" title="4">columns = append(columns, col)</span>
                }
        }

        // Add NODE column at the end for wide output
        <span class="cov1" title="1">columns = append(columns, TableColumn{
                Header:   "NODE",
                Width:    15,
                Priority: 20,
                WideOnly: true,
                Accessor: func(obj client.Object) string </span><span class="cov0" title="0">{
                        return getPodNode(obj)
                }</span>,
        })

        <span class="cov1" title="1">return columns</span>
}

// deploymentColumns customizes columns for Deployment resources
func deploymentColumns(base []TableColumn) []TableColumn <span class="cov0" title="0">{
        for i := range base </span><span class="cov0" title="0">{
                if base[i].Header == "READY" </span><span class="cov0" title="0">{
                        base[i].Accessor = func(obj client.Object) string </span><span class="cov0" title="0">{
                                return getDeploymentReadyStatus(obj)
                        }</span>
                }
        }

        // Add REPLICAS column for wide output
        <span class="cov0" title="0">base = append(base, TableColumn{
                Header:   "REPLICAS",
                Width:    12,
                Priority: 15,
                WideOnly: true,
                Accessor: func(obj client.Object) string </span><span class="cov0" title="0">{
                        return getDeploymentReplicas(obj)
                }</span>,
        })

        <span class="cov0" title="0">return base</span>
}

// serviceColumns customizes columns for Service resources
func serviceColumns(base []TableColumn) []TableColumn <span class="cov1" title="1">{
        // Insert service-specific columns
        columns := make([]TableColumn, 0, len(base)+2)

        for _, col := range base </span><span class="cov5" title="5">{
                if col.Header == "READY" </span><span class="cov1" title="1">{
                        // Replace READY with TYPE for services
                        columns = append(columns, TableColumn{
                                Header:   "TYPE",
                                Width:    12,
                                Priority: col.Priority,
                                Accessor: func(obj client.Object) string </span><span class="cov0" title="0">{
                                        return getServiceType(obj)
                                }</span>,
                        })

                        // Add CLUSTER-IP after TYPE
                        <span class="cov1" title="1">columns = append(columns, TableColumn{
                                Header:   "CLUSTER-IP",
                                Width:    15,
                                Priority: col.Priority + 1,
                                Accessor: func(obj client.Object) string </span><span class="cov0" title="0">{
                                        return getServiceClusterIP(obj)
                                }</span>,
                        })

                        // Add EXTERNAL-IP for wide output
                        <span class="cov1" title="1">columns = append(columns, TableColumn{
                                Header:   "EXTERNAL-IP",
                                Width:    15,
                                Priority: col.Priority + 2,
                                WideOnly: true,
                                Accessor: func(obj client.Object) string </span><span class="cov0" title="0">{
                                        return getServiceExternalIP(obj)
                                }</span>,
                        })
                } else<span class="cov4" title="4"> {
                        if col.Priority &gt; 2 </span><span class="cov2" title="2">{
                                col.Priority += 2 // Shift priorities to make room for new columns
                        }</span>
                        <span class="cov4" title="4">columns = append(columns, col)</span>
                }
        }

        <span class="cov1" title="1">return columns</span>
}

// configColumns customizes columns for ConfigMap and Secret resources
func configColumns(base []TableColumn) []TableColumn <span class="cov1" title="1">{
        for i := range base </span><span class="cov5" title="5">{
                if base[i].Header == "READY" </span><span class="cov1" title="1">{
                        // Replace READY with DATA for config resources
                        base[i].Header = "DATA"
                        base[i].Width = 8
                        base[i].Accessor = func(obj client.Object) string </span><span class="cov0" title="0">{
                                return getConfigDataCount(obj)
                        }</span>
                }
        }
        <span class="cov1" title="1">return base</span>
}

// SimpleTablePrinter provides a basic table printer implementation without k8s.io/cli-runtime dependency
type SimpleTablePrinter struct {
        columns   []TableColumn
        wide      bool
        noHeaders bool
}

// NewSimpleTablePrinter creates a simple table printer with default columns
func NewSimpleTablePrinter(wide, noHeaders bool) *SimpleTablePrinter <span class="cov5" title="5">{
        return &amp;SimpleTablePrinter{
                columns:   DefaultColumns(),
                wide:      wide,
                noHeaders: noHeaders,
        }
}</span>

// NewSimpleTablePrinterWithColumns creates a simple table printer with custom columns
func NewSimpleTablePrinterWithColumns(columns []TableColumn, wide, noHeaders bool) *SimpleTablePrinter <span class="cov0" title="0">{
        return &amp;SimpleTablePrinter{
                columns:   columns,
                wide:      wide,
                noHeaders: noHeaders,
        }
}</span>

// Print outputs resources in table format using the simple table printer
func (stp *SimpleTablePrinter) Print(resources []*client.Object, w io.Writer) error <span class="cov5" title="5">{
        if len(resources) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Filter columns based on wide mode
        <span class="cov4" title="4">visibleColumns := stp.getVisibleColumns()

        // Create tabwriter for aligned output
        tw := tabwriter.NewWriter(w, 0, 8, 2, ' ', 0)
        defer tw.Flush()

        // Print headers
        if !stp.noHeaders </span><span class="cov4" title="3">{
                headers := make([]string, len(visibleColumns))
                for i, col := range visibleColumns </span><span class="cov8" title="13">{
                        headers[i] = col.Header
                }</span>
                <span class="cov4" title="3">fmt.Fprintln(tw, strings.Join(headers, "\t"))</span>
        }

        // Sort resources by name for consistent output
        <span class="cov4" title="4">sortedResources := make([]*client.Object, len(resources))
        copy(sortedResources, resources)
        sort.Slice(sortedResources, func(i, j int) bool </span><span class="cov2" title="2">{
                if sortedResources[i] == nil || sortedResources[j] == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov2" title="2">iObj := *sortedResources[i]
                jObj := *sortedResources[j]

                // Sort by namespace first, then by name
                if iObj.GetNamespace() != jObj.GetNamespace() </span><span class="cov2" title="2">{
                        return iObj.GetNamespace() &lt; jObj.GetNamespace()
                }</span>
                <span class="cov0" title="0">return iObj.GetName() &lt; jObj.GetName()</span>
        })

        // Print each resource
        <span class="cov4" title="4">for _, resource := range sortedResources </span><span class="cov6" title="6">{
                if resource == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="6">obj := *resource
                row := make([]string, len(visibleColumns))

                for i, col := range visibleColumns </span><span class="cov10" title="25">{
                        row[i] = col.Accessor(obj)
                }</span>

                <span class="cov6" title="6">fmt.Fprintln(tw, strings.Join(row, "\t"))</span>
        }

        <span class="cov4" title="4">return nil</span>
}

// getVisibleColumns returns columns that should be displayed based on wide mode
func (stp *SimpleTablePrinter) getVisibleColumns() []TableColumn <span class="cov4" title="4">{
        var visible []TableColumn

        for _, col := range stp.columns </span><span class="cov9" title="20">{
                if !col.WideOnly || stp.wide </span><span class="cov8" title="17">{
                        visible = append(visible, col)
                }</span>
        }

        // Sort by priority
        <span class="cov4" title="4">sort.Slice(visible, func(i, j int) bool </span><span class="cov8" title="13">{
                return visible[i].Priority &lt; visible[j].Priority
        }</span>)

        <span class="cov4" title="4">return visible</span>
}

// GetDetailedStatus provides additional status information for wide output
func GetDetailedStatus(obj client.Object) string <span class="cov5" title="5">{
        if obj == nil </span><span class="cov1" title="1">{
                return "Unknown"
        }</span>

        // Try to get more detailed status information
        <span class="cov4" title="4">unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>

        <span class="cov4" title="4">statusVal, found := unstructured.UnstructuredContent()["status"]
        if !found </span><span class="cov2" title="2">{
                return "Unknown"
        }</span>

        <span class="cov2" title="2">statusMap, ok := statusVal.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>

        // Look for detailed status fields
        <span class="cov2" title="2">var details []string

        if message, ok := statusMap["message"].(string); ok &amp;&amp; message != "" </span><span class="cov1" title="1">{
                details = append(details, message)
        }</span>

        <span class="cov2" title="2">if reason, ok := statusMap["reason"].(string); ok &amp;&amp; reason != "" </span><span class="cov1" title="1">{
                details = append(details, reason)
        }</span>

        <span class="cov2" title="2">if len(details) &gt; 0 </span><span class="cov2" title="2">{
                return strings.Join(details, ", ")
        }</span>

        <span class="cov0" title="0">return GetResourceStatus(obj)</span>
}

// Helper functions for resource-specific column accessors

func getPodReadyStatus(obj client.Object) string <span class="cov0" title="0">{
        unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>

        <span class="cov0" title="0">statusVal, found := unstructured.UnstructuredContent()["status"]
        if !found </span><span class="cov0" title="0">{
                return "0/0"
        }</span>

        <span class="cov0" title="0">statusMap, ok := statusVal.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "0/0"
        }</span>

        // Check container statuses
        <span class="cov0" title="0">if containerStatuses, ok := statusMap["containerStatuses"].([]interface{}); ok </span><span class="cov0" title="0">{
                ready := 0
                total := len(containerStatuses)

                for _, cs := range containerStatuses </span><span class="cov0" title="0">{
                        if csMap, ok := cs.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if isReady, ok := csMap["ready"].(bool); ok &amp;&amp; isReady </span><span class="cov0" title="0">{
                                        ready++
                                }</span>
                        }
                }

                <span class="cov0" title="0">return fmt.Sprintf("%d/%d", ready, total)</span>
        }

        <span class="cov0" title="0">return "0/0"</span>
}

func getPodRestarts(obj client.Object) string <span class="cov0" title="0">{
        unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov0" title="0">statusVal, found := unstructured.UnstructuredContent()["status"]
        if !found </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov0" title="0">statusMap, ok := statusVal.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "0"
        }</span>

        // Sum restart counts from container statuses
        <span class="cov0" title="0">if containerStatuses, ok := statusMap["containerStatuses"].([]interface{}); ok </span><span class="cov0" title="0">{
                totalRestarts := 0

                for _, cs := range containerStatuses </span><span class="cov0" title="0">{
                        if csMap, ok := cs.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if restartCount, ok := csMap["restartCount"].(float64); ok </span><span class="cov0" title="0">{
                                        totalRestarts += int(restartCount)
                                }</span>
                        }
                }

                <span class="cov0" title="0">return fmt.Sprintf("%d", totalRestarts)</span>
        }

        <span class="cov0" title="0">return "0"</span>
}

func getPodNode(obj client.Object) string <span class="cov0" title="0">{
        unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "&lt;none&gt;"
        }</span>

        <span class="cov0" title="0">specVal, found := unstructured.UnstructuredContent()["spec"]
        if !found </span><span class="cov0" title="0">{
                return "&lt;none&gt;"
        }</span>

        <span class="cov0" title="0">specMap, ok := specVal.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "&lt;none&gt;"
        }</span>

        <span class="cov0" title="0">if nodeName, ok := specMap["nodeName"].(string); ok &amp;&amp; nodeName != "" </span><span class="cov0" title="0">{
                return nodeName
        }</span>

        <span class="cov0" title="0">return "&lt;none&gt;"</span>
}

func getDeploymentReadyStatus(obj client.Object) string <span class="cov0" title="0">{
        unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "0/0"
        }</span>

        <span class="cov0" title="0">statusVal, found := unstructured.UnstructuredContent()["status"]
        if !found </span><span class="cov0" title="0">{
                return "0/0"
        }</span>

        <span class="cov0" title="0">statusMap, ok := statusVal.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "0/0"
        }</span>

        <span class="cov0" title="0">ready := int64(0)
        if readyReplicas, ok := statusMap["readyReplicas"].(float64); ok </span><span class="cov0" title="0">{
                ready = int64(readyReplicas)
        }</span>

        <span class="cov0" title="0">desired := int64(0)
        if replicas, ok := statusMap["replicas"].(float64); ok </span><span class="cov0" title="0">{
                desired = int64(replicas)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%d/%d", ready, desired)</span>
}

func getDeploymentReplicas(obj client.Object) string <span class="cov0" title="0">{
        unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov0" title="0">specVal, found := unstructured.UnstructuredContent()["spec"]
        if !found </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov0" title="0">specMap, ok := specVal.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov0" title="0">if replicas, ok := specMap["replicas"].(float64); ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.0f", replicas)
        }</span>

        <span class="cov0" title="0">return "1"</span> // Default replica count
}

func getServiceType(obj client.Object) string <span class="cov0" title="0">{
        unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>

        <span class="cov0" title="0">specVal, found := unstructured.UnstructuredContent()["spec"]
        if !found </span><span class="cov0" title="0">{
                return "ClusterIP" // Default type
        }</span>

        <span class="cov0" title="0">specMap, ok := specVal.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "ClusterIP"
        }</span>

        <span class="cov0" title="0">if serviceType, ok := specMap["type"].(string); ok </span><span class="cov0" title="0">{
                return serviceType
        }</span>

        <span class="cov0" title="0">return "ClusterIP"</span>
}

func getServiceClusterIP(obj client.Object) string <span class="cov0" title="0">{
        unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "&lt;none&gt;"
        }</span>

        <span class="cov0" title="0">specVal, found := unstructured.UnstructuredContent()["spec"]
        if !found </span><span class="cov0" title="0">{
                return "&lt;none&gt;"
        }</span>

        <span class="cov0" title="0">specMap, ok := specVal.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "&lt;none&gt;"
        }</span>

        <span class="cov0" title="0">if clusterIP, ok := specMap["clusterIP"].(string); ok &amp;&amp; clusterIP != "" </span><span class="cov0" title="0">{
                return clusterIP
        }</span>

        <span class="cov0" title="0">return "&lt;none&gt;"</span>
}

func getServiceExternalIP(obj client.Object) string <span class="cov0" title="0">{
        unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "&lt;none&gt;"
        }</span>

        <span class="cov0" title="0">statusVal, found := unstructured.UnstructuredContent()["status"]
        if found </span><span class="cov0" title="0">{
                if statusMap, ok := statusVal.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if lb, ok := statusMap["loadBalancer"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if ingress, ok := lb["ingress"].([]interface{}); ok &amp;&amp; len(ingress) &gt; 0 </span><span class="cov0" title="0">{
                                        if ingressMap, ok := ingress[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if ip, ok := ingressMap["ip"].(string); ok &amp;&amp; ip != "" </span><span class="cov0" title="0">{
                                                        return ip
                                                }</span>
                                                <span class="cov0" title="0">if hostname, ok := ingressMap["hostname"].(string); ok &amp;&amp; hostname != "" </span><span class="cov0" title="0">{
                                                        return hostname
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Check spec for external IPs
        <span class="cov0" title="0">specVal, found := unstructured.UnstructuredContent()["spec"]
        if found </span><span class="cov0" title="0">{
                if specMap, ok := specVal.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if externalIPs, ok := specMap["externalIPs"].([]interface{}); ok &amp;&amp; len(externalIPs) &gt; 0 </span><span class="cov0" title="0">{
                                if ip, ok := externalIPs[0].(string); ok </span><span class="cov0" title="0">{
                                        return ip
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return "&lt;none&gt;"</span>
}

func getConfigDataCount(obj client.Object) string <span class="cov0" title="0">{
        unstructured, ok := obj.(runtime.Unstructured)
        if !ok </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov0" title="0">dataVal, found := unstructured.UnstructuredContent()["data"]
        if !found </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov0" title="0">if dataMap, ok := dataVal.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d", len(dataMap))
        }</span>

        <span class="cov0" title="0">return "0"</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package io

import (
        "bytes"
        "io"
        "os"

        kjson "k8s.io/apimachinery/pkg/runtime/serializer/json"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/yaml"

        "github.com/go-kure/kure/pkg/kubernetes"
)

// Buffer is a simple in-memory buffer that implements io.Reader and io.Writer
// and can marshal and unmarshal YAML representations of objects.
type Buffer struct {
        bytes.Buffer
}

// Marshal writes the YAML representation of obj to the buffer.
func (b *Buffer) Marshal(obj interface{}) error <span class="cov1" title="1">{
        b.Reset()
        data, err := yaml.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">_, err = b.Write(data)
        return err</span>
}

// Unmarshal parses the buffer contents as YAML into obj.
func (b *Buffer) Unmarshal(obj interface{}) error <span class="cov1" title="1">{
        return yaml.Unmarshal(b.Bytes(), obj)
}</span>

// Marshal writes the YAML representation of obj to w.
func Marshal(w io.Writer, obj interface{}) error <span class="cov1" title="1">{
        data, err := yaml.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">_, err = w.Write(data)
        return err</span>
}

// Unmarshal reads YAML from r into obj.
func Unmarshal(r io.Reader, obj interface{}) error <span class="cov1" title="1">{
        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return yaml.Unmarshal(data, obj)</span>
}

// SaveFile marshals obj as YAML and writes it to the given file path.
func SaveFile(path string, obj interface{}) error <span class="cov1" title="1">{
        f, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer func(f *os.File) </span><span class="cov1" title="1">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov1" title="1">return Marshal(f, obj)</span>
}

// LoadFile reads YAML from the given path and unmarshals it into obj.
func LoadFile(path string, obj interface{}) error <span class="cov1" title="1">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer func(f *os.File) </span><span class="cov1" title="1">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">

                }</span>
        }(f)
        <span class="cov1" title="1">return Unmarshal(f, obj)</span>
}

func EncodeObjectsTo(objects []*client.Object, yaml bool) ([]byte, error) <span class="cov10" title="4">{
        serializer := kjson.NewSerializerWithOptions(
                kjson.DefaultMetaFactory, kubernetes.Scheme, kubernetes.Scheme,
                kjson.SerializerOptions{Yaml: yaml, Pretty: false, Strict: false},
        )

        var buf bytes.Buffer
        for _, obj := range objects </span><span class="cov10" title="4">{
                if err := serializer.Encode(*obj, &amp;buf); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Add YAML document separator
                <span class="cov10" title="4">buf.WriteString("---\n")</span>
        }
        <span class="cov10" title="4">return buf.Bytes(), nil</span>
}

func EncodeObjectsToYAML(objects []*client.Object) ([]byte, error) <span class="cov5" title="2">{
        return EncodeObjectsTo(objects, true)
}</span>

func EncodeObjectsToJSON(objects []*client.Object) ([]byte, error) <span class="cov5" title="2">{
        return EncodeObjectsTo(objects, false)
}</span>

// PrintObjects prints objects using the specified output format and options
func PrintObjects(objects []*client.Object, format OutputFormat, options PrintOptions, w io.Writer) error <span class="cov1" title="1">{
        printer := NewResourcePrinter(PrintOptions{
                OutputFormat: format,
                NoHeaders:    options.NoHeaders,
                ShowLabels:   options.ShowLabels,
                ColumnLabels: options.ColumnLabels,
                SortBy:       options.SortBy,
        })
        return printer.Print(objects, w)
}</span>

// PrintObjectsAsTable prints objects in table format using the simple table printer
func PrintObjectsAsTable(objects []*client.Object, wide, noHeaders bool, w io.Writer) error <span class="cov1" title="1">{
        printer := NewSimpleTablePrinter(wide, noHeaders)
        return printer.Print(objects, w)
}</span>

// PrintObjectsAsYAML is a convenience function for YAML output
func PrintObjectsAsYAML(objects []*client.Object, w io.Writer) error <span class="cov1" title="1">{
        data, err := EncodeObjectsToYAML(objects)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">_, err = w.Write(data)
        return err</span>
}

// PrintObjectsAsJSON is a convenience function for JSON output
func PrintObjectsAsJSON(objects []*client.Object, w io.Writer) error <span class="cov1" title="1">{
        data, err := EncodeObjectsToJSON(objects)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">_, err = w.Write(data)
        return err</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package fluxcd

import (
        "time"

        intfluxcd "github.com/go-kure/kure/internal/fluxcd"

        helmv2 "github.com/fluxcd/helm-controller/api/v2"
        imagev1 "github.com/fluxcd/image-automation-controller/api/v1beta2"
        kustv1 "github.com/fluxcd/kustomize-controller/api/v1"
        notificationv1beta2 "github.com/fluxcd/notification-controller/api/v1beta2"
        "github.com/fluxcd/pkg/apis/meta"
        sourcev1 "github.com/fluxcd/source-controller/api/v1"
        sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"

        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// GitRepository converts the config to a GitRepository object.
func GitRepository(cfg *GitRepositoryConfig) *sourcev1.GitRepository <span class="cov5" title="5">{
        if cfg == nil </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov4" title="3">obj := intfluxcd.CreateGitRepository(cfg.Name, cfg.Namespace, sourcev1.GitRepositorySpec{})
        intfluxcd.SetGitRepositoryURL(obj, cfg.URL)
        intfluxcd.SetGitRepositoryInterval(obj, metav1.Duration{Duration: parseDurationOrDefault(cfg.Interval)})
        if cfg.Ref != "" </span><span class="cov1" title="1">{
                intfluxcd.SetGitRepositoryReference(obj, &amp;sourcev1.GitRepositoryRef{Branch: cfg.Ref})
        }</span>
        <span class="cov4" title="3">return obj</span>
}

// HelmRepository converts the config to a HelmRepository object.
func HelmRepository(cfg *HelmRepositoryConfig) *sourcev1.HelmRepository <span class="cov5" title="4">{
        if cfg == nil </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov3" title="2">obj := intfluxcd.CreateHelmRepository(cfg.Name, cfg.Namespace, sourcev1.HelmRepositorySpec{})
        intfluxcd.SetHelmRepositoryURL(obj, cfg.URL)
        return obj</span>
}

// Bucket converts the config to a Bucket object.
func Bucket(cfg *BucketConfig) *sourcev1.Bucket <span class="cov5" title="4">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="3">obj := intfluxcd.CreateBucket(cfg.Name, cfg.Namespace, sourcev1.BucketSpec{})
        intfluxcd.SetBucketName(obj, cfg.BucketName)
        intfluxcd.SetBucketEndpoint(obj, cfg.Endpoint)
        intfluxcd.SetBucketInterval(obj, metav1.Duration{Duration: parseDurationOrDefault(cfg.Interval)})
        if cfg.Provider != "" </span><span class="cov1" title="1">{
                intfluxcd.SetBucketProvider(obj, cfg.Provider)
        }</span>
        <span class="cov4" title="3">return obj</span>
}

// HelmChart converts the config to a HelmChart object.
func HelmChart(cfg *HelmChartConfig) *sourcev1.HelmChart <span class="cov3" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">obj := intfluxcd.CreateHelmChart(cfg.Name, cfg.Namespace, sourcev1.HelmChartSpec{})
        intfluxcd.SetHelmChartChart(obj, cfg.Chart)
        intfluxcd.SetHelmChartSourceRef(obj, cfg.SourceRef)
        intfluxcd.SetHelmChartInterval(obj, metav1.Duration{Duration: parseDurationOrDefault(cfg.Interval)})
        if cfg.Version != "" </span><span class="cov1" title="1">{
                intfluxcd.SetHelmChartVersion(obj, cfg.Version)
        }</span>
        <span class="cov1" title="1">return obj</span>
}

// OCIRepository converts the config to an OCIRepository object.
func OCIRepository(cfg *OCIRepositoryConfig) *sourcev1beta2.OCIRepository <span class="cov4" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="2">spec := sourcev1beta2.OCIRepositorySpec{
                URL:       cfg.URL,
                Reference: &amp;sourcev1beta2.OCIRepositoryRef{Tag: cfg.Ref},
                Interval:  metav1.Duration{Duration: parseDurationOrDefault(cfg.Interval)},
        }
        return intfluxcd.CreateOCIRepository(cfg.Name, cfg.Namespace, spec)</span>
}

// Kustomization converts the config to a Kustomization object.
func Kustomization(cfg *KustomizationConfig) *kustv1.Kustomization <span class="cov5" title="4">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="3">obj := intfluxcd.CreateKustomization(cfg.Name, cfg.Namespace, kustv1.KustomizationSpec{Prune: cfg.Prune})
        intfluxcd.SetKustomizationInterval(obj, metav1.Duration{Duration: parseDurationOrDefault(cfg.Interval)})
        intfluxcd.SetKustomizationSourceRef(obj, cfg.SourceRef)
        if cfg.Path != "" </span><span class="cov1" title="1">{
                intfluxcd.SetKustomizationPath(obj, cfg.Path)
        }</span>
        <span class="cov4" title="3">return obj</span>
}

// HelmRelease converts the config to a HelmRelease object.
func HelmRelease(cfg *HelmReleaseConfig) *helmv2.HelmRelease <span class="cov4" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="2">obj := intfluxcd.CreateHelmRelease(cfg.Name, cfg.Namespace, helmv2.HelmReleaseSpec{})
        chart := helmv2.HelmChartTemplate{
                Spec: helmv2.HelmChartTemplateSpec{
                        Chart:     cfg.Chart,
                        Version:   cfg.Version,
                        SourceRef: cfg.SourceRef,
                },
        }
        intfluxcd.SetHelmReleaseChart(obj, &amp;chart)
        intfluxcd.SetHelmReleaseInterval(obj, metav1.Duration{Duration: parseDurationOrDefault(cfg.Interval)})
        if cfg.ReleaseName != "" </span><span class="cov1" title="1">{
                intfluxcd.SetHelmReleaseReleaseName(obj, cfg.ReleaseName)
        }</span>
        <span class="cov3" title="2">return obj</span>
}

// Provider converts the config to a notification Provider object.
func Provider(cfg *ProviderConfig) *notificationv1beta2.Provider <span class="cov5" title="4">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="3">obj := intfluxcd.CreateProvider(cfg.Name, cfg.Namespace, notificationv1beta2.ProviderSpec{})
        intfluxcd.SetProviderType(obj, cfg.Type)
        if cfg.Channel != "" </span><span class="cov3" title="2">{
                intfluxcd.SetProviderChannel(obj, cfg.Channel)
        }</span>
        <span class="cov4" title="3">if cfg.Address != "" </span><span class="cov1" title="1">{
                intfluxcd.SetProviderAddress(obj, cfg.Address)
        }</span>
        <span class="cov4" title="3">return obj</span>
}

// Alert converts the config to an Alert object.
func Alert(cfg *AlertConfig) *notificationv1beta2.Alert <span class="cov4" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="2">obj := intfluxcd.CreateAlert(cfg.Name, cfg.Namespace, notificationv1beta2.AlertSpec{})
        intfluxcd.SetAlertProviderRef(obj, meta.LocalObjectReference{Name: cfg.ProviderRef})
        for _, es := range cfg.EventSources </span><span class="cov3" title="2">{
                intfluxcd.AddAlertEventSource(obj, es)
        }</span>
        <span class="cov3" title="2">if cfg.EventSeverity != "" </span><span class="cov1" title="1">{
                intfluxcd.SetAlertEventSeverity(obj, cfg.EventSeverity)
        }</span>
        <span class="cov3" title="2">return obj</span>
}

// Receiver converts the config to a Receiver object.
func Receiver(cfg *ReceiverConfig) *notificationv1beta2.Receiver <span class="cov4" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="2">obj := intfluxcd.CreateReceiver(cfg.Name, cfg.Namespace, notificationv1beta2.ReceiverSpec{})
        intfluxcd.SetReceiverType(obj, cfg.Type)
        intfluxcd.SetReceiverSecretRef(obj, meta.LocalObjectReference{Name: cfg.SecretName})
        for _, r := range cfg.Resources </span><span class="cov1" title="1">{
                intfluxcd.AddReceiverResource(obj, r)
        }</span>
        <span class="cov3" title="2">for _, e := range cfg.Events </span><span class="cov3" title="2">{
                intfluxcd.AddReceiverEvent(obj, e)
        }</span>
        <span class="cov3" title="2">return obj</span>
}

// ImageUpdateAutomation converts the config to an ImageUpdateAutomation object.
func ImageUpdateAutomation(cfg *ImageUpdateAutomationConfig) *imagev1.ImageUpdateAutomation <span class="cov4" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="2">obj := intfluxcd.CreateImageUpdateAutomation(cfg.Name, cfg.Namespace, imagev1.ImageUpdateAutomationSpec{})
        intfluxcd.SetImageUpdateAutomationSourceRef(obj, cfg.SourceRef)
        intfluxcd.SetImageUpdateAutomationInterval(obj, metav1.Duration{Duration: parseDurationOrDefault(cfg.Interval)})
        return obj</span>
}

// ResourceSet converts the config to a ResourceSet object.
func ResourceSet(cfg *ResourceSetConfig) *fluxv1.ResourceSet <span class="cov5" title="5">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov5" title="4">return intfluxcd.CreateResourceSet(cfg.Name, cfg.Namespace, fluxv1.ResourceSetSpec{})</span>
}

// ResourceSetInputProvider converts the config to a ResourceSetInputProvider object.
func ResourceSetInputProvider(cfg *ResourceSetInputProviderConfig) *fluxv1.ResourceSetInputProvider <span class="cov5" title="4">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="3">obj := intfluxcd.CreateResourceSetInputProvider(cfg.Name, cfg.Namespace, fluxv1.ResourceSetInputProviderSpec{})
        intfluxcd.SetResourceSetInputProviderType(obj, cfg.Type)
        if cfg.URL != "" </span><span class="cov1" title="1">{
                intfluxcd.SetResourceSetInputProviderURL(obj, cfg.URL)
        }</span>
        <span class="cov4" title="3">return obj</span>
}

// FluxInstance converts the config to a FluxInstance object.
func FluxInstance(cfg *FluxInstanceConfig) *fluxv1.FluxInstance <span class="cov5" title="4">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="3">spec := fluxv1.FluxInstanceSpec{Distribution: fluxv1.Distribution{Version: cfg.Version, Registry: cfg.Registry}}
        return intfluxcd.CreateFluxInstance(cfg.Name, cfg.Namespace, spec)</span>
}

// FluxReport converts the config to a FluxReport object.
func FluxReport(cfg *FluxReportConfig) *fluxv1.FluxReport <span class="cov5" title="4">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="3">spec := fluxv1.FluxReportSpec{Distribution: fluxv1.FluxDistributionStatus{Entitlement: cfg.Entitlement, Status: cfg.Status}}
        return intfluxcd.CreateFluxReport(cfg.Name, cfg.Namespace, spec)</span>
}

func parseDurationOrDefault(s string) time.Duration <span class="cov10" title="22">{
        d, err := time.ParseDuration(s)
        if err != nil </span><span class="cov4" title="3">{
                return 5 * time.Minute
        }</span>
        <span class="cov9" title="19">return d</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package fluxcd

import (
        intfluxcd "github.com/go-kure/kure/internal/fluxcd"

        helmv2 "github.com/fluxcd/helm-controller/api/v2"
        imagev1 "github.com/fluxcd/image-automation-controller/api/v1beta2"
        kustv1 "github.com/fluxcd/kustomize-controller/api/v1"
        notificationv1beta2 "github.com/fluxcd/notification-controller/api/v1beta2"
        sourcev1 "github.com/fluxcd/source-controller/api/v1"
        sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"

        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        meta "github.com/fluxcd/pkg/apis/meta"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// SetGitRepositorySpec replaces the spec on the GitRepository object.
func SetGitRepositorySpec(obj *sourcev1.GitRepository, spec sourcev1.GitRepositorySpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetHelmRepositorySpec replaces the spec on the HelmRepository object.
func SetHelmRepositorySpec(obj *sourcev1.HelmRepository, spec sourcev1.HelmRepositorySpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetBucketSpec replaces the spec on the Bucket object.
func SetBucketSpec(obj *sourcev1.Bucket, spec sourcev1.BucketSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetHelmChartSpec replaces the spec on the HelmChart object.
func SetHelmChartSpec(obj *sourcev1.HelmChart, spec sourcev1.HelmChartSpec) <span class="cov0" title="0">{
        obj.Spec = spec
}</span>

// SetOCIRepositorySpec replaces the spec on the OCIRepository object.
func SetOCIRepositorySpec(obj *sourcev1beta2.OCIRepository, spec sourcev1beta2.OCIRepositorySpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetKustomizationSpec replaces the spec on the Kustomization object.
func SetKustomizationSpec(obj *kustv1.Kustomization, spec kustv1.KustomizationSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetHelmReleaseSpec replaces the spec on the HelmRelease object.
func SetHelmReleaseSpec(obj *helmv2.HelmRelease, spec helmv2.HelmReleaseSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetProviderSpec replaces the spec on the Provider object.
func SetProviderSpec(obj *notificationv1beta2.Provider, spec notificationv1beta2.ProviderSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetAlertSpec replaces the spec on the Alert object.
func SetAlertSpec(obj *notificationv1beta2.Alert, spec notificationv1beta2.AlertSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetReceiverSpec replaces the spec on the Receiver object.
func SetReceiverSpec(obj *notificationv1beta2.Receiver, spec notificationv1beta2.ReceiverSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetImageUpdateAutomationSpec replaces the spec on the ImageUpdateAutomation object.
func SetImageUpdateAutomationSpec(obj *imagev1.ImageUpdateAutomation, spec imagev1.ImageUpdateAutomationSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetResourceSetSpec replaces the spec on the ResourceSet object.
func SetResourceSetSpec(obj *fluxv1.ResourceSet, spec fluxv1.ResourceSetSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetResourceSetInputProviderSpec replaces the spec on the ResourceSetInputProvider object.
func SetResourceSetInputProviderSpec(obj *fluxv1.ResourceSetInputProvider, spec fluxv1.ResourceSetInputProviderSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetFluxInstanceSpec replaces the spec on the FluxInstance object.
func SetFluxInstanceSpec(obj *fluxv1.FluxInstance, spec fluxv1.FluxInstanceSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// SetFluxReportSpec replaces the spec on the FluxReport object.
func SetFluxReportSpec(obj *fluxv1.FluxReport, spec fluxv1.FluxReportSpec) <span class="cov8" title="1">{
        obj.Spec = spec
}</span>

// Wrapper helpers for internal functions so they are exported from this package.

// AddFluxInstanceComponent delegates to the internal helper.
func AddFluxInstanceComponent(obj *fluxv1.FluxInstance, c fluxv1.Component) error <span class="cov8" title="1">{
        return intfluxcd.AddFluxInstanceComponent(obj, c)
}</span>

// SetFluxInstanceDistribution delegates to the internal helper.
func SetFluxInstanceDistribution(obj *fluxv1.FluxInstance, dist fluxv1.Distribution) error <span class="cov8" title="1">{
        return intfluxcd.SetFluxInstanceDistribution(obj, dist)
}</span>

// SetFluxInstanceCommonMetadata delegates to the internal helper.
func SetFluxInstanceCommonMetadata(obj *fluxv1.FluxInstance, cm *fluxv1.CommonMetadata) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxInstanceCommonMetadata(obj, cm)
}</span>

// SetFluxInstanceCluster delegates to the internal helper.
func SetFluxInstanceCluster(obj *fluxv1.FluxInstance, cluster *fluxv1.Cluster) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxInstanceCluster(obj, cluster)
}</span>

// SetFluxInstanceSharding delegates to the internal helper.
func SetFluxInstanceSharding(obj *fluxv1.FluxInstance, shard *fluxv1.Sharding) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxInstanceSharding(obj, shard)
}</span>

// SetFluxInstanceStorage delegates to the internal helper.
func SetFluxInstanceStorage(obj *fluxv1.FluxInstance, st *fluxv1.Storage) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxInstanceStorage(obj, st)
}</span>

// SetFluxInstanceKustomize delegates to the internal helper.
func SetFluxInstanceKustomize(obj *fluxv1.FluxInstance, k *fluxv1.Kustomize) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxInstanceKustomize(obj, k)
}</span>

// SetFluxInstanceWait delegates to the internal helper.
func SetFluxInstanceWait(obj *fluxv1.FluxInstance, wait bool) error <span class="cov8" title="1">{
        return intfluxcd.SetFluxInstanceWait(obj, wait)
}</span>

// SetFluxInstanceMigrateResources delegates to the internal helper.
func SetFluxInstanceMigrateResources(obj *fluxv1.FluxInstance, m bool) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxInstanceMigrateResources(obj, m)
}</span>

// SetFluxInstanceSync delegates to the internal helper.
func SetFluxInstanceSync(obj *fluxv1.FluxInstance, sync *fluxv1.Sync) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxInstanceSync(obj, sync)
}</span>

// AddFluxReportComponentStatus delegates to the internal helper.
func AddFluxReportComponentStatus(fr *fluxv1.FluxReport, cs fluxv1.FluxComponentStatus) error <span class="cov8" title="1">{
        return intfluxcd.AddFluxReportComponentStatus(fr, cs)
}</span>

// AddFluxReportReconcilerStatus delegates to the internal helper.
func AddFluxReportReconcilerStatus(fr *fluxv1.FluxReport, rs fluxv1.FluxReconcilerStatus) error <span class="cov0" title="0">{
        return intfluxcd.AddFluxReportReconcilerStatus(fr, rs)
}</span>

// SetFluxReportDistribution delegates to the internal helper.
func SetFluxReportDistribution(fr *fluxv1.FluxReport, dist fluxv1.FluxDistributionStatus) error <span class="cov8" title="1">{
        return intfluxcd.SetFluxReportDistribution(fr, dist)
}</span>

// SetFluxReportCluster delegates to the internal helper.
func SetFluxReportCluster(fr *fluxv1.FluxReport, c *fluxv1.ClusterInfo) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxReportCluster(fr, c)
}</span>

// SetFluxReportOperator delegates to the internal helper.
func SetFluxReportOperator(fr *fluxv1.FluxReport, op *fluxv1.OperatorInfo) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxReportOperator(fr, op)
}</span>

// SetFluxReportSyncStatus delegates to the internal helper.
func SetFluxReportSyncStatus(fr *fluxv1.FluxReport, s *fluxv1.FluxSyncStatus) error <span class="cov0" title="0">{
        return intfluxcd.SetFluxReportSyncStatus(fr, s)
}</span>

// AddResourceSetInput delegates to the internal helper.
func AddResourceSetInput(rs *fluxv1.ResourceSet, in fluxv1.ResourceSetInput) error <span class="cov8" title="1">{
        return intfluxcd.AddResourceSetInput(rs, in)
}</span>

// AddResourceSetInputFrom delegates to the internal helper.
func AddResourceSetInputFrom(rs *fluxv1.ResourceSet, ref fluxv1.InputProviderReference) error <span class="cov8" title="1">{
        return intfluxcd.AddResourceSetInputFrom(rs, ref)
}</span>

// AddResourceSetResource delegates to the internal helper.
func AddResourceSetResource(rs *fluxv1.ResourceSet, r *apiextensionsv1.JSON) error <span class="cov8" title="1">{
        return intfluxcd.AddResourceSetResource(rs, r)
}</span>

// SetResourceSetResourcesTemplate delegates to the internal helper.
func SetResourceSetResourcesTemplate(rs *fluxv1.ResourceSet, tpl string) error <span class="cov8" title="1">{
        return intfluxcd.SetResourceSetResourcesTemplate(rs, tpl)
}</span>

// AddResourceSetDependency delegates to the internal helper.
func AddResourceSetDependency(rs *fluxv1.ResourceSet, dep fluxv1.Dependency) error <span class="cov8" title="1">{
        return intfluxcd.AddResourceSetDependency(rs, dep)
}</span>

// SetResourceSetServiceAccountName delegates to the internal helper.
func SetResourceSetServiceAccountName(rs *fluxv1.ResourceSet, name string) error <span class="cov8" title="1">{
        return intfluxcd.SetResourceSetServiceAccountName(rs, name)
}</span>

// SetResourceSetWait delegates to the internal helper.
func SetResourceSetWait(rs *fluxv1.ResourceSet, wait bool) error <span class="cov8" title="1">{
        return intfluxcd.SetResourceSetWait(rs, wait)
}</span>

// SetResourceSetCommonMetadata delegates to the internal helper.
func SetResourceSetCommonMetadata(rs *fluxv1.ResourceSet, cm *fluxv1.CommonMetadata) error <span class="cov8" title="1">{
        return intfluxcd.SetResourceSetCommonMetadata(rs, cm)
}</span>

// SetResourceSetInputProviderType delegates to the internal helper.
func SetResourceSetInputProviderType(obj *fluxv1.ResourceSetInputProvider, typ string) error <span class="cov8" title="1">{
        return intfluxcd.SetResourceSetInputProviderType(obj, typ)
}</span>

// SetResourceSetInputProviderURL delegates to the internal helper.
func SetResourceSetInputProviderURL(obj *fluxv1.ResourceSetInputProvider, url string) error <span class="cov8" title="1">{
        return intfluxcd.SetResourceSetInputProviderURL(obj, url)
}</span>

// SetResourceSetInputProviderServiceAccountName delegates to the internal helper.
func SetResourceSetInputProviderServiceAccountName(obj *fluxv1.ResourceSetInputProvider, name string) error <span class="cov8" title="1">{
        return intfluxcd.SetResourceSetInputProviderServiceAccountName(obj, name)
}</span>

// SetResourceSetInputProviderSecretRef delegates to the internal helper.
func SetResourceSetInputProviderSecretRef(obj *fluxv1.ResourceSetInputProvider, ref *meta.LocalObjectReference) error <span class="cov8" title="1">{
        return intfluxcd.SetResourceSetInputProviderSecretRef(obj, ref)
}</span>

// SetResourceSetInputProviderCertSecretRef delegates to the internal helper.
func SetResourceSetInputProviderCertSecretRef(obj *fluxv1.ResourceSetInputProvider, ref *meta.LocalObjectReference) error <span class="cov8" title="1">{
        return intfluxcd.SetResourceSetInputProviderCertSecretRef(obj, ref)
}</span>

// AddResourceSetInputProviderSchedule delegates to the internal helper.
func AddResourceSetInputProviderSchedule(obj *fluxv1.ResourceSetInputProvider, s fluxv1.Schedule) error <span class="cov8" title="1">{
        return intfluxcd.AddResourceSetInputProviderSchedule(obj, s)
}</span>

// Additional helpers for notification resources.

// SetProviderType delegates to the internal helper.
func SetProviderType(provider *notificationv1beta2.Provider, t string) <span class="cov8" title="1">{
        intfluxcd.SetProviderType(provider, t)
}</span>

// SetProviderInterval delegates to the internal helper.
func SetProviderInterval(provider *notificationv1beta2.Provider, d metav1.Duration) <span class="cov8" title="1">{
        intfluxcd.SetProviderInterval(provider, d)
}</span>

// SetProviderChannel delegates to the internal helper.
func SetProviderChannel(provider *notificationv1beta2.Provider, channel string) <span class="cov8" title="1">{
        intfluxcd.SetProviderChannel(provider, channel)
}</span>

// SetProviderUsername delegates to the internal helper.
func SetProviderUsername(provider *notificationv1beta2.Provider, username string) <span class="cov8" title="1">{
        intfluxcd.SetProviderUsername(provider, username)
}</span>

// SetProviderAddress delegates to the internal helper.
func SetProviderAddress(provider *notificationv1beta2.Provider, address string) <span class="cov8" title="1">{
        intfluxcd.SetProviderAddress(provider, address)
}</span>

// SetProviderTimeout delegates to the internal helper.
func SetProviderTimeout(provider *notificationv1beta2.Provider, d metav1.Duration) <span class="cov8" title="1">{
        intfluxcd.SetProviderTimeout(provider, d)
}</span>

// SetProviderProxy delegates to the internal helper.
func SetProviderProxy(provider *notificationv1beta2.Provider, proxy string) <span class="cov8" title="1">{
        intfluxcd.SetProviderProxy(provider, proxy)
}</span>

// SetProviderSecretRef delegates to the internal helper.
func SetProviderSecretRef(provider *notificationv1beta2.Provider, ref *meta.LocalObjectReference) <span class="cov8" title="1">{
        intfluxcd.SetProviderSecretRef(provider, ref)
}</span>

// SetProviderCertSecretRef delegates to the internal helper.
func SetProviderCertSecretRef(provider *notificationv1beta2.Provider, ref *meta.LocalObjectReference) <span class="cov8" title="1">{
        intfluxcd.SetProviderCertSecretRef(provider, ref)
}</span>

// SetProviderSuspend delegates to the internal helper.
func SetProviderSuspend(provider *notificationv1beta2.Provider, suspend bool) <span class="cov8" title="1">{
        intfluxcd.SetProviderSuspend(provider, suspend)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package kubernetes

import (
        cmacme "github.com/cert-manager/cert-manager/pkg/apis/acme/v1"
        certv1 "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
        cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        esv1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1"
        helmv2 "github.com/fluxcd/helm-controller/api/v2"
        imagev1 "github.com/fluxcd/image-automation-controller/api/v1beta2"
        kustv1 "github.com/fluxcd/kustomize-controller/api/v1"
        notificationv1 "github.com/fluxcd/notification-controller/api/v1"
        notificationv1beta2 "github.com/fluxcd/notification-controller/api/v1beta2"
        sourcev1 "github.com/fluxcd/source-controller/api/v1"
        sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
        metallbv1beta1 "go.universe.tf/metallb/api/v1beta1"
        appsv1 "k8s.io/api/apps/v1"
        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        netv1 "k8s.io/api/networking/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        storv1 "k8s.io/api/storage/v1"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/serializer"
        "sync"
)

var (
        Scheme       = runtime.NewScheme()
        Codecs       = serializer.NewCodecFactory(Scheme)
        registerOnce sync.Once
        registerErr  error
)

// RegisterSchemes adds all Kubernetes and Flux custom resource schemes to Scheme.
// The registration is performed only once. The first non-nil error returned by
// any AddToScheme call is cached and returned on subsequent invocations.
func RegisterSchemes() error <span class="cov10" title="29">{
        registerOnce.Do(func() </span><span class="cov1" title="1">{
                if err := corev1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := appsv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := rbacv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := batchv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := netv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := storv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := apiextensionsv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := cmacme.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := certv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := cmmeta.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := fluxv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := helmv2.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := imagev1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := kustv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := notificationv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := notificationv1beta2.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := sourcev1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := sourcev1beta2.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := esv1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
                <span class="cov1" title="1">if err := metallbv1beta1.AddToScheme(Scheme); err != nil </span><span class="cov0" title="0">{
                        registerErr = err
                        return
                }</span>
        })
        <span class="cov10" title="29">return registerErr</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package kubernetes

import (
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/errors"
)

// GetGroupVersionKind returns the GroupVersionKind of the given Kubernetes runtime.Object.
func GetGroupVersionKind(obj runtime.Object) (schema.GroupVersionKind, error) <span class="cov6" title="7">{
        if obj == nil </span><span class="cov1" title="1">{
                return schema.GroupVersionKind{}, errors.ErrNilObject
        }</span>

        <span class="cov6" title="6">if err := RegisterSchemes(); err != nil </span><span class="cov0" title="0">{
                return schema.GroupVersionKind{}, err
        }</span>

        <span class="cov6" title="6">gvks, _, err := Scheme.ObjectKinds(obj)
        if err != nil </span><span class="cov1" title="1">{
                return schema.GroupVersionKind{}, err
        }</span>
        <span class="cov5" title="5">if len(gvks) == 0 </span><span class="cov0" title="0">{
                return schema.GroupVersionKind{}, errors.ErrGVKNotFound
        }</span>
        <span class="cov5" title="5">return gvks[0], nil</span>
}

// IsGVKAllowed checks if a given GVK is present in a user-defined allowed set.
func IsGVKAllowed(gvk schema.GroupVersionKind, allowed []schema.GroupVersionKind) bool <span class="cov8" title="14">{
        for _, allowedGVK := range allowed </span><span class="cov10" title="22">{
                if gvk == allowedGVK </span><span class="cov6" title="7">{
                        return true
                }</span>
        }
        <span class="cov6" title="7">return false</span>
}

// Helper function to convert to client.Object
func ToClientObject(obj client.Object) *client.Object <span class="cov6" title="6">{
        // iThis is not a Redundant type conversion
        clientObj := client.Object(obj)
        return &amp;clientObj
}</span>

func ValidatePackageRef(p *schema.GroupVersionKind) error <span class="cov7" title="9">{
        allowed := []schema.GroupVersionKind{
                {Group: "source.toolkit.fluxcd.io", Version: "v1beta1", Kind: "GitRepository"},
                {Group: "source.toolkit.fluxcd.io", Version: "v1beta1", Kind: "OCIRepository"},
        }
        if IsGVKAllowed(*p, allowed) </span><span class="cov5" title="4">{
                return nil
        }</span> else<span class="cov5" title="4"> {
                return errors.ErrGVKNotAllowed
        }</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package launcher

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/go-kure/kure/pkg/errors"
        kurei "github.com/go-kure/kure/pkg/io"
        "github.com/go-kure/kure/pkg/logger"
        "gopkg.in/yaml.v3"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// outputBuilder implements the Builder interface
type outputBuilder struct {
        logger       logger.Logger
        writer       FileWriter
        resolver     Resolver
        processor    PatchProcessor
        outputWriter io.Writer // configurable output writer
}

// NewBuilder creates a new output builder
func NewBuilder(log logger.Logger) Builder <span class="cov5" title="16">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.Default()
        }</span>
        <span class="cov5" title="16">return &amp;outputBuilder{
                logger:       log,
                writer:       &amp;defaultFileWriter{},
                resolver:     NewResolver(log),
                processor:    NewPatchProcessor(log, nil),
                outputWriter: os.Stdout, // default to stdout
        }</span>
}

// Build generates final manifests and writes them according to options
func (b *outputBuilder) Build(ctx context.Context, inst *PackageInstance, buildOpts BuildOptions, opts *LauncherOptions) error <span class="cov5" title="20">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return errors.Wrap(ctx.Err(), "context cancelled during build")</span>
        default:<span class="cov5" title="20"></span>
        }

        <span class="cov5" title="20">if inst == nil || inst.Definition == nil </span><span class="cov0" title="0">{
                return errors.New("package instance or definition is nil")
        }</span>

        <span class="cov5" title="20">if opts == nil </span><span class="cov2" title="2">{
                opts = DefaultOptions()
        }</span>

        <span class="cov5" title="20">b.logger.Info("Building package %s", inst.Definition.Metadata.Name)

        // Step 1: Resolve variables
        resolved, err := b.resolver.Resolve(ctx, inst.Definition.Parameters, inst.UserValues, opts)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to resolve variables")
        }</span>

        // Convert resolved parameters back to regular map for patch processing
        <span class="cov5" title="20">resolvedParams := make(ParameterMap)
        for k, v := range resolved </span><span class="cov8" title="112">{
                resolvedParams[k] = v.Value
        }</span>

        // Step 2: Apply patches
        <span class="cov5" title="20">patched, err := b.processor.ApplyPatches(ctx, inst.Definition, inst.EnabledPatches, resolvedParams)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to apply patches")
        }</span>

        // Step 3: Build final resources
        <span class="cov5" title="20">resources, err := b.buildResources(ctx, patched, resolvedParams, buildOpts)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to build resources")
        }</span>

        // Step 4: Write output
        <span class="cov5" title="20">if err := b.writeOutput(ctx, resources, buildOpts); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to write output")
        }</span>

        <span class="cov5" title="20">b.logger.Info("Successfully built %d resources", len(resources))
        return nil</span>
}

// SetOutputWriter sets the output writer for stdout output
func (b *outputBuilder) SetOutputWriter(w io.Writer) <span class="cov6" title="31">{
        b.outputWriter = w
}</span>

// buildResources converts package resources to final manifests
func (b *outputBuilder) buildResources(ctx context.Context, def *PackageDefinition, params ParameterMap, opts BuildOptions) ([]*unstructured.Unstructured, error) <span class="cov5" title="22">{
        var result []*unstructured.Unstructured

        for _, resource := range def.Resources </span><span class="cov6" title="43">{
                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, errors.Wrap(ctx.Err(), "context cancelled during resource building")</span>
                default:<span class="cov6" title="43"></span>
                }

                // Convert to unstructured
                <span class="cov6" title="43">obj := resource.Raw
                if obj == nil </span><span class="cov6" title="34">{
                        // Check if we have template data that needs variable resolution
                        if len(resource.TemplateData) &gt; 0 </span><span class="cov6" title="34">{
                                // Resolve variables in template data
                                resolvedTemplate, err := b.resolveTemplateVariables(string(resource.TemplateData), params)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, errors.Wrapf(err, "failed to resolve variables in template for %s/%s",
                                                resource.Kind, resource.Metadata.Name)
                                }</span>

                                // Parse the resolved template
                                <span class="cov6" title="34">objs, err := kurei.ParseYAML([]byte(resolvedTemplate))
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, errors.Wrapf(err, "failed to parse resolved template for %s/%s",
                                                resource.Kind, resource.Metadata.Name)
                                }</span>

                                // Use the first object (templates should contain single resources)
                                <span class="cov6" title="34">if len(objs) &gt; 0 </span><span class="cov6" title="34">{
                                        if clientObj, ok := objs[0].(client.Object); ok </span><span class="cov6" title="34">{
                                                // Convert client.Object to unstructured
                                                objMap, err := runtime.DefaultUnstructuredConverter.ToUnstructured(clientObj)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return nil, errors.Wrapf(err, "failed to convert object to unstructured for %s/%s",
                                                                resource.Kind, resource.Metadata.Name)
                                                }</span>
                                                <span class="cov6" title="34">obj = &amp;unstructured.Unstructured{Object: objMap}

                                                // Update resource metadata with resolved values for filtering
                                                resource.Metadata.Name = obj.GetName()
                                                resource.Metadata.Namespace = obj.GetNamespace()</span>
                                        }
                                }
                        }

                        // Fallback: create from metadata if still nil
                        <span class="cov6" title="34">if obj == nil </span><span class="cov0" title="0">{
                                obj = &amp;unstructured.Unstructured{
                                        Object: map[string]interface{}{
                                                "apiVersion": resource.APIVersion,
                                                "kind":       resource.Kind,
                                                "metadata": map[string]interface{}{
                                                        "name":        resource.Metadata.Name,
                                                        "namespace":   resource.Metadata.Namespace,
                                                        "labels":      resource.Metadata.Labels,
                                                        "annotations": resource.Metadata.Annotations,
                                                },
                                        },
                                }
                        }</span>
                }

                // Apply any final transformations
                <span class="cov6" title="43">if opts.AddLabels != nil </span><span class="cov3" title="6">{
                        labels := obj.GetLabels()
                        if labels == nil </span><span class="cov3" title="6">{
                                labels = make(map[string]string)
                        }</span>
                        <span class="cov3" title="6">for k, v := range opts.AddLabels </span><span class="cov4" title="12">{
                                labels[k] = v
                        }</span>
                        <span class="cov3" title="6">obj.SetLabels(labels)</span>
                }

                <span class="cov6" title="43">if opts.AddAnnotations != nil </span><span class="cov2" title="2">{
                        annotations := obj.GetAnnotations()
                        if annotations == nil </span><span class="cov2" title="2">{
                                annotations = make(map[string]string)
                        }</span>
                        <span class="cov2" title="2">for k, v := range opts.AddAnnotations </span><span class="cov2" title="2">{
                                annotations[k] = v
                        }</span>
                        <span class="cov2" title="2">obj.SetAnnotations(annotations)</span>
                }

                // Apply filtering after the resource is fully resolved
                <span class="cov6" title="43">if opts.FilterKind != "" &amp;&amp; obj.GetKind() != opts.FilterKind </span><span class="cov2" title="3">{
                        continue</span>
                }
                <span class="cov6" title="40">if opts.FilterName != "" &amp;&amp; obj.GetName() != opts.FilterName </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="40">if opts.FilterNamespace != "" &amp;&amp; obj.GetNamespace() != opts.FilterNamespace </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="40">result = append(result, obj)</span>
        }

        <span class="cov5" title="22">return result, nil</span>
}

// writeOutput writes resources to the specified destination
func (b *outputBuilder) writeOutput(ctx context.Context, resources []*unstructured.Unstructured, opts BuildOptions) error <span class="cov5" title="20">{
        // Determine output writer
        var writer io.Writer
        var closeFunc func() error

        switch opts.Output </span>{
        case OutputStdout:<span class="cov4" title="10">
                writer = b.outputWriter</span>
        case OutputFile:<span class="cov4" title="7">
                if opts.OutputPath == "" </span><span class="cov0" title="0">{
                        return errors.New("output path required for file output")
                }</span>

                // Create directory if needed
                <span class="cov4" title="7">dir := filepath.Dir(opts.OutputPath)
                if err := b.writer.MkdirAll(dir); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to create output directory")
                }</span>

                // Open file for writing
                <span class="cov4" title="7">file, err := os.Create(opts.OutputPath)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewFileError("create", opts.OutputPath, "failed to create output file", err)
                }</span>
                <span class="cov4" title="7">writer = file
                closeFunc = file.Close</span>
        case OutputDirectory:<span class="cov2" title="3">
                // Write each resource to a separate file
                return b.writeDirectory(ctx, resources, opts)</span>
        default:<span class="cov0" title="0">
                return errors.Errorf("unsupported output type: %s", opts.Output)</span>
        }

        // Ensure file is closed if needed
        <span class="cov5" title="17">if closeFunc != nil </span><span class="cov4" title="7">{
                defer closeFunc()
        }</span>

        // Write resources
        <span class="cov5" title="17">switch opts.Format </span>{
        case FormatYAML:<span class="cov5" title="14">
                return b.writeYAML(writer, resources, opts)</span>
        case FormatJSON:<span class="cov2" title="3">
                return b.writeJSON(writer, resources, opts)</span>
        default:<span class="cov0" title="0">
                return errors.Errorf("unsupported format: %s", opts.Format)</span>
        }
}

// writeYAML writes resources in YAML format
func (b *outputBuilder) writeYAML(w io.Writer, resources []*unstructured.Unstructured, opts BuildOptions) error <span class="cov5" title="20">{
        for i, resource := range resources </span><span class="cov6" title="33">{
                // Add document separator for multi-document YAML
                if i &gt; 0 &amp;&amp; !opts.SeparateFiles </span><span class="cov5" title="13">{
                        if _, err := fmt.Fprintln(w, "---"); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to write separator")
                        }</span>
                }

                // Convert to YAML
                <span class="cov6" title="33">data := resource.Object

                // Use a new encoder for each resource to avoid automatic document separators
                encoder := yaml.NewEncoder(w)
                encoder.SetIndent(2)
                if err := encoder.Encode(data); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to encode resource to YAML")
                }</span>
        }

        <span class="cov5" title="20">return nil</span>
}

// writeJSON writes resources in JSON format
func (b *outputBuilder) writeJSON(w io.Writer, resources []*unstructured.Unstructured, opts BuildOptions) error <span class="cov3" title="4">{
        encoder := json.NewEncoder(w)
        if opts.PrettyPrint </span><span class="cov2" title="2">{
                encoder.SetIndent("", "  ")
        }</span>

        // Wrap in array if multiple resources
        <span class="cov3" title="4">if len(resources) &gt; 1 &amp;&amp; !opts.SeparateFiles </span><span class="cov3" title="4">{
                var items []interface{}
                for _, resource := range resources </span><span class="cov4" title="8">{
                        items = append(items, resource.Object)
                }</span>
                <span class="cov3" title="4">return encoder.Encode(items)</span>
        }

        // Single resource or separate files
        <span class="cov0" title="0">for _, resource := range resources </span><span class="cov0" title="0">{
                if err := encoder.Encode(resource.Object); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to encode resource to JSON")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// writeDirectory writes each resource to a separate file
func (b *outputBuilder) writeDirectory(ctx context.Context, resources []*unstructured.Unstructured, opts BuildOptions) error <span class="cov2" title="3">{
        if opts.OutputPath == "" </span><span class="cov0" title="0">{
                return errors.New("output path required for directory output")
        }</span>

        // Create output directory
        <span class="cov2" title="3">if err := b.writer.MkdirAll(opts.OutputPath); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create output directory")
        }</span>

        <span class="cov2" title="3">for i, resource := range resources </span><span class="cov3" title="5">{
                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return errors.Wrap(ctx.Err(), "context cancelled during directory write")</span>
                default:<span class="cov3" title="5"></span>
                }

                // Generate filename
                <span class="cov3" title="5">filename := b.generateFilename(resource, i, opts)
                filepath := filepath.Join(opts.OutputPath, filename)

                // Write resource to file
                file, err := os.Create(filepath)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewFileError("create", filepath, "failed to create resource file", err)
                }</span>

                // Write content
                <span class="cov3" title="5">var writeErr error
                switch opts.Format </span>{
                case FormatYAML:<span class="cov3" title="5">
                        writeErr = b.writeYAML(file, []*unstructured.Unstructured{resource}, opts)</span>
                case FormatJSON:<span class="cov0" title="0">
                        writeErr = b.writeJSON(file, []*unstructured.Unstructured{resource}, opts)</span>
                default:<span class="cov0" title="0">
                        writeErr = errors.Errorf("unsupported format: %s", opts.Format)</span>
                }

                // Close file
                <span class="cov3" title="5">if err := file.Close(); err != nil &amp;&amp; writeErr == nil </span><span class="cov0" title="0">{
                        writeErr = err
                }</span>

                <span class="cov3" title="5">if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>

                <span class="cov3" title="5">b.logger.Debug("Wrote resource to %s", filepath)</span>
        }

        <span class="cov2" title="3">return nil</span>
}

// generateFilename generates a filename for a resource
func (b *outputBuilder) generateFilename(resource *unstructured.Unstructured, index int, opts BuildOptions) string <span class="cov4" title="9">{
        // Build filename components
        var parts []string

        // Add index for ordering
        if opts.IncludeIndex </span><span class="cov3" title="6">{
                parts = append(parts, fmt.Sprintf("%03d", index))
        }</span>

        // Add kind
        <span class="cov4" title="9">kind := strings.ToLower(resource.GetKind())
        if kind != "" </span><span class="cov4" title="9">{
                parts = append(parts, kind)
        }</span>

        // Add name
        <span class="cov4" title="9">name := resource.GetName()
        if name != "" </span><span class="cov4" title="9">{
                parts = append(parts, name)
        }</span>

        // Add namespace if present
        <span class="cov4" title="9">if ns := resource.GetNamespace(); ns != "" &amp;&amp; opts.IncludeNamespace </span><span class="cov1" title="1">{
                parts = append(parts, ns)
        }</span>

        // Join parts
        <span class="cov4" title="9">filename := strings.Join(parts, "-")
        if filename == "" </span><span class="cov0" title="0">{
                filename = fmt.Sprintf("resource-%d", index)
        }</span>

        // Add extension
        <span class="cov4" title="9">switch opts.Format </span>{
        case FormatYAML:<span class="cov4" title="8">
                filename += ".yaml"</span>
        case FormatJSON:<span class="cov1" title="1">
                filename += ".json"</span>
        }

        <span class="cov4" title="9">return filename</span>
}

// defaultFileWriter implements FileWriter using os package
type defaultFileWriter struct{}

func (w *defaultFileWriter) WriteFile(path string, data []byte) error <span class="cov0" title="0">{
        return os.WriteFile(path, data, 0644)
}</span>

func (w *defaultFileWriter) MkdirAll(path string) error <span class="cov4" title="10">{
        return os.MkdirAll(path, 0755)
}</span>

// resolveTemplateVariables replaces ${variable} patterns in template content
func (b *outputBuilder) resolveTemplateVariables(template string, params ParameterMap) (string, error) <span class="cov6" title="34">{
        // Use the same variable resolution pattern as the resolver
        variablePattern := regexp.MustCompile(`\$\{([^}]+)\}`)

        result := template
        matches := variablePattern.FindAllStringSubmatch(template, -1)

        for _, match := range matches </span><span class="cov9" title="226">{
                if len(match) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov9" title="226">fullMatch := match[0] // ${var.name}
                varPath := match[1]   // var.name

                // Resolve the variable using the same logic as the resolver
                value, err := b.resolveVariablePath(varPath, params)
                if err != nil </span><span class="cov1" title="1">{
                        b.logger.Debug("Failed to resolve variable %s: %v", varPath, err)
                        continue</span> // Skip unresolvable variables for now
                }

                // Convert value to string
                <span class="cov9" title="225">valueStr := b.convertToString(value)

                // Replace in result
                result = strings.ReplaceAll(result, fullMatch, valueStr)</span>
        }

        <span class="cov6" title="34">return result, nil</span>
}

// resolveVariablePath resolves a dot-notation variable path in parameters
func (b *outputBuilder) resolveVariablePath(path string, params ParameterMap) (interface{}, error) <span class="cov9" title="226">{
        parts := strings.Split(path, ".")
        var current interface{} = params

        for _, part := range parts </span><span class="cov10" title="310">{
                switch v := current.(type) </span>{
                case ParameterMap:<span class="cov10" title="310">
                        if val, exists := v[part]; exists </span><span class="cov9" title="309">{
                                current = val
                        }</span> else<span class="cov1" title="1"> {
                                return nil, errors.Errorf("parameter %s not found", path)
                        }</span>
                case map[string]interface{}:<span class="cov0" title="0">
                        if val, exists := v[part]; exists </span><span class="cov0" title="0">{
                                current = val
                        }</span> else<span class="cov0" title="0"> {
                                return nil, errors.Errorf("parameter %s not found", path)
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, errors.Errorf("cannot traverse %s in non-map value", path)</span>
                }
        }

        <span class="cov9" title="225">return current, nil</span>
}

// convertToString converts a parameter value to its string representation
func (b *outputBuilder) convertToString(value interface{}) string <span class="cov9" title="225">{
        switch v := value.(type) </span>{
        case string:<span class="cov9" title="175">
                return v</span>
        case int, int8, int16, int32, int64:<span class="cov7" title="50">
                return fmt.Sprintf("%d", v)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v)</span>
        case float32, float64:<span class="cov0" title="0">
                return fmt.Sprintf("%g", v)</span>
        case bool:<span class="cov0" title="0">
                return fmt.Sprintf("%t", v)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v)</span>
        }
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package launcher

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/logger"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

// CLI provides command-line interface for the launcher
type CLI struct {
        logger       logger.Logger
        loader       PackageLoader
        resolver     Resolver
        processor    PatchProcessor
        validator    Validator
        builder      Builder
        extension    ExtensionLoader
        schema       SchemaGenerator
        outputWriter io.Writer // configurable output writer
}

// NewCLI creates a new CLI instance
func NewCLI(log logger.Logger) *CLI <span class="cov7" title="10">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.Default()
        }</span>
        <span class="cov7" title="10">resolver := NewResolver(log)
        return &amp;CLI{
                logger:       log,
                loader:       NewPackageLoader(log),
                resolver:     resolver,
                processor:    NewPatchProcessor(log, resolver),
                validator:    NewValidator(log),
                builder:      NewBuilder(log),
                extension:    NewExtensionLoader(log),
                schema:       NewSchemaGenerator(log),
                outputWriter: os.Stdout, // default to stdout
        }</span>
}

// SetOutputWriter sets the output writer for CLI commands
func (c *CLI) SetOutputWriter(w io.Writer) <span class="cov10" title="29">{
        c.outputWriter = w
        c.builder.SetOutputWriter(w)
}</span>

// RootCommand creates the root command for kurel
func (c *CLI) RootCommand() *cobra.Command <span class="cov10" title="29">{
        var opts LauncherOptions

        cmd := &amp;cobra.Command{
                Use:   "kurel",
                Short: "Kurel package system for Kubernetes manifest generation",
                Long: `Kurel is a declarative package system for generating Kubernetes manifests.
It provides strongly-typed builders, variable substitution, patching, and validation.`,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        // Global flags
        cmd.PersistentFlags().BoolVarP(&amp;opts.Verbose, "verbose", "v", false, "Enable verbose output")
        cmd.PersistentFlags().BoolVar(&amp;opts.Debug, "debug", false, "Enable debug output")
        cmd.PersistentFlags().BoolVar(&amp;opts.StrictMode, "strict", false, "Treat warnings as errors")
        cmd.PersistentFlags().IntVar(&amp;opts.MaxDepth, "max-depth", 10, "Maximum variable substitution depth")
        cmd.PersistentFlags().DurationVar(&amp;opts.Timeout, "timeout", 30*time.Second, "Operation timeout")

        // Add subcommands
        cmd.AddCommand(c.BuildCommand(&amp;opts))
        cmd.AddCommand(c.ValidateCommand(&amp;opts))
        cmd.AddCommand(c.InfoCommand(&amp;opts))
        cmd.AddCommand(c.SchemaCommand(&amp;opts))
        cmd.AddCommand(c.DebugCommand(&amp;opts))

        return cmd
}</span>

// BuildCommand creates the build command
func (c *CLI) BuildCommand(opts *LauncherOptions) *cobra.Command <span class="cov10" title="29">{
        var (
                buildOpts    BuildOptions
                valuesFile   string
                patches      []string
                localPath    string
                noExtensions bool
                formatStr    string
        )

        cmd := &amp;cobra.Command{
                Use:   "build [package-path]",
                Short: "Build manifests from a kurel package",
                Long: `Build generates Kubernetes manifests from a kurel package.
It resolves variables, applies patches, and outputs the final manifests.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="14">{
                        // Set CLI output writer from command
                        c.SetOutputWriter(cmd.OutOrStdout())

                        // Determine package path
                        packagePath := "."
                        if len(args) &gt; 0 </span><span class="cov7" title="13">{
                                packagePath = args[0]
                        }</span>

                        // Setup logger based on flags
                        <span class="cov8" title="14">if opts.Verbose </span><span class="cov0" title="0">{
                                opts.Logger = logger.Default()
                        }</span> else<span class="cov8" title="14"> {
                                opts.Logger = logger.Noop()
                        }</span>

                        // Set format from string
                        <span class="cov8" title="14">switch strings.ToLower(formatStr) </span>{
                        case "json":<span class="cov2" title="2">
                                buildOpts.Format = FormatJSON</span>
                        default:<span class="cov7" title="12">
                                buildOpts.Format = FormatYAML</span>
                        }

                        <span class="cov8" title="14">ctx := context.Background()
                        return c.runBuild(ctx, packagePath, valuesFile, patches, localPath, !noExtensions, buildOpts, opts)</span>
                },
        }

        // Build-specific flags
        <span class="cov10" title="29">cmd.Flags().StringVarP(&amp;buildOpts.OutputPath, "output", "o", "", "Output path (default: stdout)")
        cmd.Flags().StringVar(&amp;valuesFile, "values", "", "Values file for parameter overrides")
        cmd.Flags().StringSliceVarP(&amp;patches, "patch", "p", nil, "Enable specific patches")
        cmd.Flags().StringVar(&amp;localPath, "local", "", "Path to local extensions")
        cmd.Flags().BoolVar(&amp;noExtensions, "no-extensions", false, "Disable local extensions")

        // Output format flags
        cmd.Flags().StringVar(&amp;formatStr, "format", "yaml", "Output format (yaml, json)")
        cmd.Flags().BoolVar(&amp;buildOpts.PrettyPrint, "pretty", false, "Pretty print JSON output")
        cmd.Flags().BoolVar(&amp;buildOpts.SeparateFiles, "separate", false, "Write each resource to separate file")
        cmd.Flags().BoolVar(&amp;buildOpts.IncludeIndex, "index", false, "Include index prefix in filenames")

        // Filter flags
        cmd.Flags().StringVar(&amp;buildOpts.FilterKind, "kind", "", "Filter by resource kind")
        cmd.Flags().StringVar(&amp;buildOpts.FilterName, "name", "", "Filter by resource name")
        cmd.Flags().StringVar(&amp;buildOpts.FilterNamespace, "namespace", "", "Filter by namespace")

        // Transform flags
        cmd.Flags().StringToStringVar(&amp;buildOpts.AddLabels, "add-label", nil, "Add labels to all resources")
        cmd.Flags().StringToStringVar(&amp;buildOpts.AddAnnotations, "add-annotation", nil, "Add annotations to all resources")

        return cmd</span>
}

// ValidateCommand creates the validate command
func (c *CLI) ValidateCommand(opts *LauncherOptions) *cobra.Command <span class="cov10" title="29">{
        var (
                valuesFile string
                schemaFile string
                outputJSON bool
        )

        cmd := &amp;cobra.Command{
                Use:   "validate [package-path]",
                Short: "Validate a kurel package",
                Long:  `Validate checks a kurel package for errors and warnings.`,
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov5" title="5">{
                        // Set CLI output writer from command
                        c.SetOutputWriter(cmd.OutOrStdout())

                        packagePath := "."
                        if len(args) &gt; 0 </span><span class="cov5" title="5">{
                                packagePath = args[0]
                        }</span>

                        <span class="cov5" title="5">if opts.Verbose </span><span class="cov0" title="0">{
                                opts.Logger = logger.Default()
                        }</span> else<span class="cov5" title="5"> {
                                opts.Logger = logger.Noop()
                        }</span>

                        <span class="cov5" title="5">ctx := context.Background()
                        return c.runValidate(ctx, packagePath, valuesFile, schemaFile, outputJSON, opts)</span>
                },
        }

        <span class="cov10" title="29">cmd.Flags().StringVar(&amp;valuesFile, "values", "", "Values file for validation")
        cmd.Flags().StringVar(&amp;schemaFile, "schema", "", "Custom schema file")
        cmd.Flags().BoolVar(&amp;outputJSON, "json", false, "Output validation results as JSON")

        return cmd</span>
}

// InfoCommand creates the info command
func (c *CLI) InfoCommand(opts *LauncherOptions) *cobra.Command <span class="cov10" title="29">{
        var (
                outputFormat string
                showAll      bool
        )

        cmd := &amp;cobra.Command{
                Use:   "info [package-path]",
                Short: "Display information about a kurel package",
                Long:  `Info displays metadata, parameters, resources, and patches in a package.`,
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov5" title="5">{
                        // Set CLI output writer from command
                        c.SetOutputWriter(cmd.OutOrStdout())

                        packagePath := "."
                        if len(args) &gt; 0 </span><span class="cov5" title="5">{
                                packagePath = args[0]
                        }</span>

                        <span class="cov5" title="5">if opts.Verbose </span><span class="cov0" title="0">{
                                opts.Logger = logger.Default()
                        }</span> else<span class="cov5" title="5"> {
                                opts.Logger = logger.Noop()
                        }</span>

                        <span class="cov5" title="5">ctx := context.Background()
                        return c.runInfo(ctx, packagePath, outputFormat, showAll, opts)</span>
                },
        }

        <span class="cov10" title="29">cmd.Flags().StringVarP(&amp;outputFormat, "output", "o", "text", "Output format (text, yaml, json)")
        cmd.Flags().BoolVar(&amp;showAll, "all", false, "Show all details including resource content")

        return cmd</span>
}

// SchemaCommand creates the schema command
func (c *CLI) SchemaCommand(opts *LauncherOptions) *cobra.Command <span class="cov10" title="29">{
        var (
                outputPath  string
                includeK8s  bool
                prettyPrint bool
        )

        cmd := &amp;cobra.Command{
                Use:   "schema [package-path]",
                Short: "Generate JSON schema for a kurel package",
                Long:  `Schema generates a JSON schema that can be used for validation and IDE support.`,
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov2" title="2">{
                        // Set CLI output writer from command
                        c.SetOutputWriter(cmd.OutOrStdout())

                        packagePath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                packagePath = args[0]
                        }</span>

                        <span class="cov2" title="2">if opts.Verbose </span><span class="cov0" title="0">{
                                opts.Logger = logger.Default()
                        }</span> else<span class="cov2" title="2"> {
                                opts.Logger = logger.Noop()
                        }</span>

                        <span class="cov2" title="2">ctx := context.Background()
                        return c.runSchema(ctx, packagePath, outputPath, includeK8s, prettyPrint, opts)</span>
                },
        }

        <span class="cov10" title="29">cmd.Flags().StringVarP(&amp;outputPath, "output", "o", "", "Output path (default: stdout)")
        cmd.Flags().BoolVar(&amp;includeK8s, "k8s", false, "Include Kubernetes resource schemas")
        cmd.Flags().BoolVar(&amp;prettyPrint, "pretty", true, "Pretty print JSON output")

        return cmd</span>
}

// DebugCommand creates the debug command with subcommands
func (c *CLI) DebugCommand(opts *LauncherOptions) *cobra.Command <span class="cov10" title="29">{
        cmd := &amp;cobra.Command{
                Use:   "debug",
                Short: "Debug commands for troubleshooting",
                Long:  `Debug provides various troubleshooting commands for packages.`,
        }

        // Add debug subcommands
        cmd.AddCommand(c.debugVariablesCommand(opts))
        cmd.AddCommand(c.debugPatchesCommand(opts))
        cmd.AddCommand(c.debugResourcesCommand(opts))

        return cmd
}</span>

// debugVariablesCommand shows variable resolution details
func (c *CLI) debugVariablesCommand(opts *LauncherOptions) *cobra.Command <span class="cov10" title="29">{
        return &amp;cobra.Command{
                Use:   "variables [package-path]",
                Short: "Show variable resolution graph",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        // Set CLI output writer from command
                        c.SetOutputWriter(cmd.OutOrStdout())

                        packagePath := "."
                        if len(args) &gt; 0 </span><span class="cov1" title="1">{
                                packagePath = args[0]
                        }</span>

                        <span class="cov1" title="1">opts.Logger = logger.Default() // Always verbose for debug
                        ctx := context.Background()

                        // Load package
                        def, err := c.loader.LoadDefinition(ctx, packagePath, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to load package")
                        }</span>

                        // Show variable graph
                        <span class="cov1" title="1">resolver := c.resolver.(*variableResolver)
                        graph := resolver.DebugVariableGraph(def.Parameters)
                        fmt.Fprintln(c.outputWriter, graph)

                        return nil</span>
                },
        }
}

// debugPatchesCommand shows patch dependencies
func (c *CLI) debugPatchesCommand(opts *LauncherOptions) *cobra.Command <span class="cov10" title="29">{
        return &amp;cobra.Command{
                Use:   "patches [package-path]",
                Short: "Show patch dependency graph",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        // Set CLI output writer from command
                        c.SetOutputWriter(cmd.OutOrStdout())

                        packagePath := "."
                        if len(args) &gt; 0 </span><span class="cov1" title="1">{
                                packagePath = args[0]
                        }</span>

                        <span class="cov1" title="1">opts.Logger = logger.Default()
                        ctx := context.Background()

                        // Load package
                        def, err := c.loader.LoadDefinition(ctx, packagePath, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to load package")
                        }</span>

                        // Show patch graph
                        <span class="cov1" title="1">processor := c.processor.(*patchProcessor)
                        graph := processor.DebugPatchGraph(def.Patches)
                        fmt.Fprintln(c.outputWriter, graph)

                        return nil</span>
                },
        }
}

// debugResourcesCommand shows resource details
func (c *CLI) debugResourcesCommand(opts *LauncherOptions) *cobra.Command <span class="cov10" title="29">{
        return &amp;cobra.Command{
                Use:   "resources [package-path]",
                Short: "Show detailed resource information",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        // Set CLI output writer from command
                        c.SetOutputWriter(cmd.OutOrStdout())

                        packagePath := "."
                        if len(args) &gt; 0 </span><span class="cov1" title="1">{
                                packagePath = args[0]
                        }</span>

                        <span class="cov1" title="1">opts.Logger = logger.Default()
                        ctx := context.Background()

                        // Load package
                        def, err := c.loader.LoadDefinition(ctx, packagePath, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to load package")
                        }</span>

                        // Show resource details
                        <span class="cov1" title="1">fmt.Fprintf(c.outputWriter, "Package: %s\n", def.Metadata.Name)
                        fmt.Fprintf(c.outputWriter, "Resources: %d\n\n", len(def.Resources))

                        for i, resource := range def.Resources </span><span class="cov2" title="2">{
                                fmt.Fprintf(c.outputWriter, "[%d] %s/%s\n", i+1, resource.Kind, resource.GetName())
                                fmt.Fprintf(c.outputWriter, "    Namespace: %s\n", resource.GetNamespace())
                                if len(resource.Metadata.Labels) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(c.outputWriter, "    Labels:\n")
                                        for k, v := range resource.Metadata.Labels </span><span class="cov0" title="0">{
                                                fmt.Fprintf(c.outputWriter, "      %s: %s\n", k, v)
                                        }</span>
                                }
                                <span class="cov2" title="2">fmt.Fprintln(c.outputWriter)</span>
                        }

                        <span class="cov1" title="1">return nil</span>
                },
        }
}

// Implementation methods

func (c *CLI) runBuild(ctx context.Context, packagePath, valuesFile string, patches []string, localPath string, useExtensions bool, buildOpts BuildOptions, opts *LauncherOptions) error <span class="cov8" title="14">{
        // Load package
        c.logger.Info("Loading package from %s", packagePath)
        def, err := c.loader.LoadDefinition(ctx, packagePath, opts)
        if err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, "failed to load package")
        }</span>

        // Validate package before building
        <span class="cov7" title="13">result, err := c.validator.ValidatePackage(ctx, def)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "validation failed")
        }</span>
        <span class="cov7" title="13">if !result.IsValid() </span><span class="cov2" title="2">{
                return errors.Errorf("package has validation errors: %d errors found", len(result.Errors))
        }</span>

        // Load values file if provided
        <span class="cov7" title="11">userValues := make(ParameterMap)
        if valuesFile != "" </span><span class="cov1" title="1">{
                data, err := os.ReadFile(valuesFile)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewFileError("read", valuesFile, "failed to read values file", err)
                }</span>
                <span class="cov1" title="1">if err := yaml.Unmarshal(data, &amp;userValues); err != nil </span><span class="cov0" title="0">{
                        return errors.NewParseError(valuesFile, "invalid YAML", 0, 0, err)
                }</span>
        }

        // Apply extensions if enabled
        <span class="cov7" title="11">if useExtensions </span><span class="cov7" title="10">{
                def, err = c.extension.LoadWithExtensions(ctx, def, localPath, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to load extensions")
                }</span>
        }

        // Filter patches if specified
        <span class="cov7" title="11">enabledPatches := def.Patches
        if len(patches) &gt; 0 </span><span class="cov0" title="0">{
                enabledPatches = c.filterPatches(def.Patches, patches)
        }</span>

        // Resolve patch dependencies
        <span class="cov7" title="11">enabledPatches, err = c.processor.ResolveDependencies(ctx, enabledPatches, def.Parameters)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to resolve patch dependencies")
        }</span>

        // Create package instance
        <span class="cov7" title="11">instance := &amp;PackageInstance{
                Definition:     def,
                UserValues:     userValues,
                EnabledPatches: enabledPatches,
                LocalPath:      localPath,
        }

        // Determine output destination
        if buildOpts.OutputPath != "" </span><span class="cov3" title="3">{
                if info, err := os.Stat(buildOpts.OutputPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov1" title="1">{
                        buildOpts.Output = OutputDirectory
                }</span> else<span class="cov2" title="2"> {
                        buildOpts.Output = OutputFile
                }</span>
        } else<span class="cov6" title="8"> {
                buildOpts.Output = OutputStdout
        }</span>

        // Format is already set from the command flags

        // Build manifests
        <span class="cov7" title="11">return c.builder.Build(ctx, instance, buildOpts, opts)</span>
}

func (c *CLI) runValidate(ctx context.Context, packagePath, valuesFile, schemaFile string, outputJSON bool, opts *LauncherOptions) error <span class="cov5" title="5">{
        // Load package
        def, err := c.loader.LoadDefinition(ctx, packagePath, opts)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to load package")
        }</span>

        // Validate package
        <span class="cov5" title="5">result, err := c.validator.ValidatePackage(ctx, def)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "validation failed")
        }</span>

        // Output results
        <span class="cov5" title="5">if outputJSON </span><span class="cov1" title="1">{
                encoder := json.NewEncoder(c.outputWriter)
                encoder.SetIndent("", "  ")
                return encoder.Encode(result)
        }</span>

        // Text output
        <span class="cov4" title="4">if len(result.Errors) &gt; 0 </span><span class="cov1" title="1">{
                fmt.Fprintf(c.outputWriter, "Errors (%d):\n", len(result.Errors))
                for _, e := range result.Errors </span><span class="cov6" title="8">{
                        fmt.Fprintf(c.outputWriter, "  ✗ %s\n", e.Error())
                }</span>
                <span class="cov1" title="1">fmt.Fprintln(c.outputWriter)</span>
        }

        <span class="cov4" title="4">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(c.outputWriter, "Warnings (%d):\n", len(result.Warnings))
                for _, w := range result.Warnings </span><span class="cov0" title="0">{
                        fmt.Fprintf(c.outputWriter, "  ⚠ %s\n", w.String())
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(c.outputWriter)</span>
        }

        <span class="cov4" title="4">if result.IsValid() </span><span class="cov3" title="3">{
                fmt.Fprintln(c.outputWriter, "✓ Package is valid")
        }</span> else<span class="cov1" title="1"> {
                fmt.Fprintln(c.outputWriter, "✗ Package has errors")
                if opts.StrictMode </span><span class="cov0" title="0">{
                        return errors.New("validation failed")
                }</span>
        }

        <span class="cov4" title="4">return nil</span>
}

func (c *CLI) runInfo(ctx context.Context, packagePath, outputFormat string, showAll bool, opts *LauncherOptions) error <span class="cov5" title="5">{
        // Load package
        def, err := c.loader.LoadDefinition(ctx, packagePath, opts)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to load package")
        }</span>

        <span class="cov5" title="5">switch outputFormat </span>{
        case "json":<span class="cov1" title="1">
                encoder := json.NewEncoder(c.outputWriter)
                encoder.SetIndent("", "  ")
                return encoder.Encode(def)</span>

        case "yaml":<span class="cov1" title="1">
                encoder := yaml.NewEncoder(c.outputWriter)
                encoder.SetIndent(2)
                return encoder.Encode(def)</span>

        default:<span class="cov3" title="3"> // text
                fmt.Fprintf(c.outputWriter, "Package: %s\n", def.Metadata.Name)
                fmt.Fprintf(c.outputWriter, "Version: %s\n", def.Metadata.Version)
                if def.Metadata.Description != "" </span><span class="cov3" title="3">{
                        fmt.Fprintf(c.outputWriter, "Description: %s\n", def.Metadata.Description)
                }</span>
                <span class="cov3" title="3">fmt.Fprintln(c.outputWriter)

                if len(def.Parameters) &gt; 0 </span><span class="cov3" title="3">{
                        fmt.Fprintf(c.outputWriter, "Parameters (%d):\n", len(def.Parameters))
                        for k, v := range def.Parameters </span><span class="cov9" title="22">{
                                fmt.Fprintf(c.outputWriter, "  %s: %v\n", k, formatValue(v))
                        }</span>
                        <span class="cov3" title="3">fmt.Fprintln(c.outputWriter)</span>
                }

                <span class="cov3" title="3">fmt.Fprintf(c.outputWriter, "Resources (%d):\n", len(def.Resources))
                for _, r := range def.Resources </span><span class="cov6" title="9">{
                        fmt.Fprintf(c.outputWriter, "  - %s/%s", r.Kind, r.GetName())
                        if ns := r.GetNamespace(); ns != "" </span><span class="cov6" title="8">{
                                fmt.Fprintf(c.outputWriter, " (namespace: %s)", ns)
                        }</span>
                        <span class="cov6" title="9">fmt.Fprintln(c.outputWriter)</span>
                }

                <span class="cov3" title="3">if len(def.Patches) &gt; 0 </span><span class="cov3" title="3">{
                        fmt.Fprintf(c.outputWriter, "\nPatches (%d):\n", len(def.Patches))
                        for _, p := range def.Patches </span><span class="cov5" title="6">{
                                fmt.Fprintf(c.outputWriter, "  - %s", p.Name)
                                if p.Metadata != nil &amp;&amp; p.Metadata.Description != "" </span><span class="cov0" title="0">{
                                        fmt.Fprintf(c.outputWriter, ": %s", p.Metadata.Description)
                                }</span>
                                <span class="cov5" title="6">fmt.Fprintln(c.outputWriter)</span>
                        }
                }
        }

        <span class="cov3" title="3">return nil</span>
}

func (c *CLI) runSchema(ctx context.Context, packagePath, outputPath string, includeK8s, prettyPrint bool, opts *LauncherOptions) error <span class="cov2" title="2">{
        // Generate schema
        schema, err := c.schema.GeneratePackageSchema(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to generate schema")
        }</span>

        // Export to JSON
        <span class="cov2" title="2">data, err := c.schema.ExportSchema(schema)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to export schema")
        }</span>

        // Pretty print if requested
        <span class="cov2" title="2">if prettyPrint </span><span class="cov2" title="2">{
                var obj interface{}
                if err := json.Unmarshal(data, &amp;obj); err == nil </span><span class="cov2" title="2">{
                        if pretty, err := json.MarshalIndent(obj, "", "  "); err == nil </span><span class="cov2" title="2">{
                                data = pretty
                        }</span>
                }
        }

        // Write output
        <span class="cov2" title="2">if outputPath != "" </span><span class="cov0" title="0">{
                dir := filepath.Dir(outputPath)
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to create output directory")
                }</span>
                <span class="cov0" title="0">return os.WriteFile(outputPath, data, 0644)</span>
        }

        <span class="cov2" title="2">_, err = c.outputWriter.Write(data)
        return err</span>
}

func (c *CLI) filterPatches(patches []Patch, names []string) []Patch <span class="cov0" title="0">{
        nameSet := make(map[string]bool)
        for _, name := range names </span><span class="cov0" title="0">{
                nameSet[name] = true
        }</span>

        <span class="cov0" title="0">var filtered []Patch
        for _, patch := range patches </span><span class="cov0" title="0">{
                if nameSet[patch.Name] </span><span class="cov0" title="0">{
                        filtered = append(filtered, patch)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

func formatValue(v interface{}) string <span class="cov9" title="22">{
        switch val := v.(type) </span>{
        case string:<span class="cov6" title="9">
                if strings.Contains(val, "\n") </span><span class="cov0" title="0">{
                        return "(multiline)"
                }</span>
                <span class="cov6" title="9">return val</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return fmt.Sprintf("(map with %d keys)", len(val))</span>
        case []interface{}:<span class="cov0" title="0">
                return fmt.Sprintf("(array with %d items)", len(val))</span>
        default:<span class="cov7" title="13">
                return fmt.Sprintf("%v", val)</span>
        }
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package launcher

import "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

// deepCopyResources creates a deep copy of a resource slice
func deepCopyResources(resources []Resource) []Resource <span class="cov0" title="0">{
        if resources == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]Resource, len(resources))
        for i, r := range resources </span><span class="cov0" title="0">{
                result[i] = r.DeepCopy()
        }</span>
        <span class="cov0" title="0">return result</span>
}

// deepCopyPatches creates a deep copy of a patch slice
func deepCopyPatches(patches []Patch) []Patch <span class="cov0" title="0">{
        if patches == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]Patch, len(patches))
        for i, p := range patches </span><span class="cov0" title="0">{
                result[i] = Patch{
                        Name:     p.Name,
                        Path:     p.Path,
                        Content:  p.Content,
                        Metadata: deepCopyPatchMetadata(p.Metadata),
                }
        }</span>
        <span class="cov0" title="0">return result</span>
}

// deepCopyParameterMapWithSource creates a deep copy of a parameter map with sources
func deepCopyParameterMapWithSource(m ParameterMapWithSource) ParameterMapWithSource <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make(ParameterMapWithSource)
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = ParameterSource{
                        Value:    deepCopyValue(v.Value),
                        Location: v.Location,
                        File:     v.File,
                        Line:     v.Line,
                }
        }</span>
        <span class="cov0" title="0">return result</span>
}

// deepCopyUnstructured creates a deep copy of an unstructured object
func deepCopyUnstructured(u *unstructured.Unstructured) *unstructured.Unstructured <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return u.DeepCopy()</span>
}

// deepCopyStringSlice creates a deep copy of a string slice
func deepCopyStringSlice(s []string) []string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]string, len(s))
        copy(result, s)
        return result</span>
}

// deepCopyInterfaceSlice creates a deep copy of an interface slice
func deepCopyInterfaceSlice(s []interface{}) []interface{} <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]interface{}, len(s))
        for i, v := range s </span><span class="cov0" title="0">{
                result[i] = deepCopyValue(v)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// deepCopyMap creates a deep copy of a map[string]interface{}
func deepCopyMap(m map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make(map[string]interface{})
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = deepCopyValue(v)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package launcher

import (
        stderrors "errors"
        "fmt"
        "strings"

        "github.com/go-kure/kure/pkg/errors"
)

// LoadErrors represents errors during package loading with partial results
// It implements the KureError interface for structured error handling
type LoadErrors struct {
        *errors.BaseError
        PartialDefinition *PackageDefinition
        Issues            []error
}

// NewLoadErrors creates a new LoadErrors with partial results
func NewLoadErrors(partial *PackageDefinition, issues []error) *LoadErrors <span class="cov10" title="36">{
        message := "package loaded with issues"
        if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                messages := make([]string, len(issues))
                for i, err := range issues </span><span class="cov0" title="0">{
                        messages[i] = err.Error()
                }</span>
                <span class="cov0" title="0">message = fmt.Sprintf("package loaded with %d issues: %s",
                        len(issues), strings.Join(messages, "; "))</span>
        }

        <span class="cov10" title="36">return &amp;LoadErrors{
                BaseError: &amp;errors.BaseError{
                        ErrType: errors.ErrorTypeParse,
                        Message: message,
                        Help:    "Fix the reported issues to fully load the package",
                        ErrContext: map[string]interface{}{
                                "issueCount": len(issues),
                        },
                },
                PartialDefinition: partial,
                Issues:            issues,
        }</span>
}

// Unwrap returns the underlying errors
func (e *LoadErrors) Unwrap() []error <span class="cov0" title="0">{
        return e.Issues
}</span>

// HasCriticalErrors returns true if any critical errors prevent usage
func (e *LoadErrors) HasCriticalErrors() bool <span class="cov0" title="0">{
        for _, err := range e.Issues </span><span class="cov0" title="0">{
                if IsCriticalError(err) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// PatchError represents an error during patch processing
// Uses the existing PatchError from pkg/errors but adds launcher-specific fields
type PatchError struct {
        *errors.PatchError
        PatchName    string
        ResourceKind string
        ResourceName string
        TargetPath   string
        Reason       string
}

// NewPatchError creates a patch processing error
func NewPatchError(patchName, resourceKind, resourceName, targetPath, reason string) *PatchError <span class="cov0" title="0">{
        resourceFull := resourceKind
        if resourceName != "" </span><span class="cov0" title="0">{
                resourceFull = fmt.Sprintf("%s/%s", resourceKind, resourceName)
        }</span>

        <span class="cov0" title="0">return &amp;PatchError{
                PatchError: errors.NewPatchError(
                        "apply",
                        targetPath,
                        resourceFull,
                        reason,
                        nil,
                ),
                PatchName:    patchName,
                ResourceKind: resourceKind,
                ResourceName: resourceName,
                TargetPath:   targetPath,
                Reason:       reason,
        }</span>
}

// DependencyError represents a dependency resolution error
type DependencyError struct {
        *errors.ConfigError
        DepType string   // "circular", "missing", "conflict"
        Source  string   // Source of the dependency
        Target  string   // Target of the dependency
        Chain   []string // Dependency chain for circular dependencies
}

// NewDependencyError creates a dependency resolution error
func NewDependencyError(depType, source, target string, chain []string) *DependencyError <span class="cov3" title="3">{
        var message string
        var help string

        switch depType </span>{
        case "circular":<span class="cov0" title="0">
                message = fmt.Sprintf("circular dependency: %s", strings.Join(chain, " -&gt; "))
                help = "Remove or reorganize dependencies to break the cycle"</span>
        case "missing":<span class="cov1" title="1">
                message = fmt.Sprintf("%s requires non-existent %s", source, target)
                help = "Ensure all required dependencies are available"</span>
        case "conflict":<span class="cov2" title="2">
                message = fmt.Sprintf("%s conflicts with %s", source, target)
                help = "Resolve conflicting dependencies or use patch ordering"</span>
        default:<span class="cov0" title="0">
                message = fmt.Sprintf("dependency error: %s -&gt; %s", source, target)
                help = "Check dependency configuration"</span>
        }

        <span class="cov3" title="3">return &amp;DependencyError{
                ConfigError: &amp;errors.ConfigError{
                        BaseError: &amp;errors.BaseError{
                                ErrType: errors.ErrorTypeConfiguration,
                                Message: message,
                                Help:    help,
                                ErrContext: map[string]interface{}{
                                        "type":   depType,
                                        "source": source,
                                        "target": target,
                                        "chain":  chain,
                                },
                        },
                        Source: "dependencies",
                        Field:  source,
                },
                DepType: depType,
                Source:  source,
                Target:  target,
                Chain:   chain,
        }</span>
}

// VariableError represents a variable resolution error
type VariableError struct {
        *errors.ValidationError
        Variable   string
        Expression string
        Reason     string
}

// NewVariableError creates a variable resolution error
func NewVariableError(variable, expression, reason string) *VariableError <span class="cov3" title="3">{
        message := fmt.Sprintf("variable %s: %s", variable, reason)
        if expression != "" </span><span class="cov3" title="3">{
                message = fmt.Sprintf("variable %s: failed to resolve '%s': %s",
                        variable, expression, reason)
        }</span>

        <span class="cov3" title="3">return &amp;VariableError{
                ValidationError: &amp;errors.ValidationError{
                        BaseError: &amp;errors.BaseError{
                                ErrType: errors.ErrorTypeValidation,
                                Message: message,
                                Help:    "Check variable definition and expression syntax",
                                ErrContext: map[string]interface{}{
                                        "variable":   variable,
                                        "expression": expression,
                                        "reason":     reason,
                                },
                        },
                        Field:     variable,
                        Value:     expression,
                        Component: "launcher",
                },
                Variable:   variable,
                Expression: expression,
                Reason:     reason,
        }</span>
}

// SchemaError represents a schema validation error
type SchemaError struct {
        *errors.ValidationError
        Path     string      // JSON path to the field
        Value    interface{} // Actual value
        Expected string      // Expected type or constraint
        Message  string      // Error message
}

// NewSchemaError creates a schema validation error
func NewSchemaError(path string, value interface{}, expected, message string) *SchemaError <span class="cov0" title="0">{
        fullMessage := fmt.Sprintf("schema validation: %s", message)
        if path != "" </span><span class="cov0" title="0">{
                fullMessage = fmt.Sprintf("schema validation at %s: %s (got %v, expected %s)",
                        path, message, value, expected)
        }</span>

        <span class="cov0" title="0">return &amp;SchemaError{
                ValidationError: &amp;errors.ValidationError{
                        BaseError: &amp;errors.BaseError{
                                ErrType: errors.ErrorTypeValidation,
                                Message: fullMessage,
                                Help:    fmt.Sprintf("Expected %s", expected),
                                ErrContext: map[string]interface{}{
                                        "path":     path,
                                        "value":    value,
                                        "expected": expected,
                                },
                        },
                        Field:     path,
                        Value:     fmt.Sprintf("%v", value),
                        Component: "launcher-schema",
                },
                Path:     path,
                Value:    value,
                Expected: expected,
                Message:  message,
        }</span>
}

// SizeError represents a package size violation
type SizeError struct {
        *errors.ValidationError
        ActualSize int64
        MaxSize    int64
        SizeType   string // "package", "resource", "patch"
}

// NewSizeError creates a size validation error
func NewSizeError(sizeType string, actualSize, maxSize int64) *SizeError <span class="cov0" title="0">{
        return &amp;SizeError{
                ValidationError: &amp;errors.ValidationError{
                        BaseError: &amp;errors.BaseError{
                                ErrType: errors.ErrorTypeValidation,
                                Message: fmt.Sprintf("%s size %d exceeds maximum %d bytes",
                                        sizeType, actualSize, maxSize),
                                Help: fmt.Sprintf("Reduce %s size below %d bytes", sizeType, maxSize),
                                ErrContext: map[string]interface{}{
                                        "type":       sizeType,
                                        "actualSize": actualSize,
                                        "maxSize":    maxSize,
                                },
                        },
                        Field:     "size",
                        Value:     fmt.Sprintf("%d", actualSize),
                        Component: "launcher",
                },
                ActualSize: actualSize,
                MaxSize:    maxSize,
                SizeType:   sizeType,
        }
}</span>

// IsCriticalError determines if an error is critical (prevents package usage)
func IsCriticalError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if it's a KureError with specific types
        <span class="cov0" title="0">if kErr := errors.GetKureError(err); kErr != nil </span><span class="cov0" title="0">{
                // File and parse errors are usually critical
                if errors.IsType(err, errors.ErrorTypeFile) ||
                        errors.IsType(err, errors.ErrorTypeParse) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check for critical error types
        <span class="cov0" title="0">var sizeErr *SizeError
        if As(err, &amp;sizeErr) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for specific critical error patterns
        <span class="cov0" title="0">if fileErr, ok := err.(*errors.FileError); ok </span><span class="cov0" title="0">{
                if fileErr.Operation == "read" || fileErr.Operation == "load" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// IsWarning determines if an error should be treated as a warning
func IsWarning(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Configuration errors are often warnings
        <span class="cov0" title="0">if errors.IsType(err, errors.ErrorTypeConfiguration) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Non-critical errors are warnings
        <span class="cov0" title="0">return !IsCriticalError(err)</span>
}

// Helper function to wrap standard errors.As for local use
func As(err error, target interface{}) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Use standard errors.As
        <span class="cov0" title="0">return stderrors.As(err, target)</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package launcher

import (
        "context"
        "os"
        "path/filepath"
        "strings"

        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/logger"
        "gopkg.in/yaml.v3"
)

// extensionLoader implements the ExtensionLoader interface
type extensionLoader struct {
        logger logger.Logger
        loader PackageLoader
}

// NewExtensionLoader creates a new extension loader
func NewExtensionLoader(log logger.Logger) ExtensionLoader <span class="cov6" title="12">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.Default()
        }</span>
        <span class="cov6" title="12">return &amp;extensionLoader{
                logger: log,
                loader: NewPackageLoader(log),
        }</span>
}

// LoadWithExtensions loads a package with local extensions
func (e *extensionLoader) LoadWithExtensions(ctx context.Context, def *PackageDefinition, localPath string, opts *LauncherOptions) (*PackageDefinition, error) <span class="cov6" title="12">{
        if def == nil </span><span class="cov0" title="0">{
                return nil, errors.New("package definition is nil")
        }</span>

        <span class="cov6" title="12">if opts == nil </span><span class="cov1" title="1">{
                opts = DefaultOptions()
        }</span>

        // Look for local extension files
        <span class="cov6" title="12">extensions, err := e.findExtensions(def.Path, localPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to find extensions")
        }</span>

        <span class="cov6" title="12">if len(extensions) == 0 </span><span class="cov6" title="10">{
                e.logger.Debug("No local extensions found")
                return def, nil
        }</span>

        <span class="cov2" title="2">e.logger.Info("Found %d local extensions", len(extensions))

        // Apply each extension
        result := def.DeepCopy()
        for _, ext := range extensions </span><span class="cov2" title="2">{
                if err := e.applyExtension(ctx, result, ext, opts); err != nil </span><span class="cov0" title="0">{
                        if opts.StrictMode </span><span class="cov0" title="0">{
                                return nil, errors.Wrap(err, "failed to apply extension")
                        }</span>
                        <span class="cov0" title="0">e.logger.Warn("Failed to apply extension %s: %v", ext.Path, err)</span>
                }
        }

        <span class="cov2" title="2">return result, nil</span>
}

// LocalExtension represents a local customization file
type LocalExtension struct {
        Path       string                  `yaml:"-"`
        Type       ExtensionType           `yaml:"type,omitempty"`
        Metadata   KurelMetadata           `yaml:"metadata,omitempty"`
        Parameters ParameterMap            `yaml:"parameters,omitempty"`
        Patches    []LocalPatch            `yaml:"patches,omitempty"`
        Resources  []LocalResourceOverride `yaml:"resources,omitempty"`
        Remove     []ResourceSelector      `yaml:"remove,omitempty"`
}

// ExtensionType defines the type of extension
type ExtensionType string

const (
        ExtensionTypeOverride ExtensionType = "override" // Override existing values
        ExtensionTypeMerge    ExtensionType = "merge"    // Merge with existing values
        ExtensionTypeReplace  ExtensionType = "replace"  // Replace entirely
)

// LocalPatch represents a patch definition in local extension
type LocalPatch struct {
        Name        string         `yaml:"name"`
        Description string         `yaml:"description,omitempty"`
        Enabled     string         `yaml:"enabled,omitempty"`
        Content     string         `yaml:"content"`
        Metadata    *PatchMetadata `yaml:"metadata,omitempty"`
}

// LocalResourceOverride represents resource modifications
type LocalResourceOverride struct {
        Selector ResourceSelector       `yaml:"selector"`
        Override map[string]interface{} `yaml:"override,omitempty"`
        Merge    map[string]interface{} `yaml:"merge,omitempty"`
        Remove   []string               `yaml:"remove,omitempty"`
}

// ResourceSelector identifies resources to modify
type ResourceSelector struct {
        Kind      string            `yaml:"kind,omitempty"`
        Name      string            `yaml:"name,omitempty"`
        Namespace string            `yaml:"namespace,omitempty"`
        Labels    map[string]string `yaml:"labels,omitempty"`
}

// findExtensions locates all local extension files
func (e *extensionLoader) findExtensions(packagePath, localPath string, opts *LauncherOptions) ([]LocalExtension, error) <span class="cov6" title="13">{
        var extensions []LocalExtension

        // Determine search paths
        searchPaths := e.getSearchPaths(packagePath, localPath, opts)

        for _, searchPath := range searchPaths </span><span class="cov9" title="52">{
                // Look for .local.kurel files
                pattern := filepath.Join(searchPath, "*.local.kurel")
                matches, err := filepath.Glob(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        e.logger.Warn("Failed to search for extensions in %s: %v", searchPath, err)
                        continue</span>
                }

                // Also check for .local.yaml files
                <span class="cov9" title="52">yamlPattern := filepath.Join(searchPath, "*.local.yaml")
                yamlMatches, err := filepath.Glob(yamlPattern)
                if err != nil </span><span class="cov0" title="0">{
                        e.logger.Warn("Failed to search for yaml extensions in %s: %v", searchPath, err)
                }</span> else<span class="cov9" title="52"> {
                        matches = append(matches, yamlMatches...)
                }</span>

                // Load each extension file
                <span class="cov9" title="52">for _, match := range matches </span><span class="cov4" title="4">{
                        ext, err := e.loadExtension(match)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Warn("Failed to load extension %s: %v", match, err)
                                continue</span>
                        }
                        <span class="cov4" title="4">extensions = append(extensions, *ext)</span>
                }
        }

        // Sort by priority (alphabetical by filename)
        <span class="cov6" title="13">e.sortExtensions(extensions)

        return extensions, nil</span>
}

// getSearchPaths returns paths to search for extensions
func (e *extensionLoader) getSearchPaths(packagePath, localPath string, opts *LauncherOptions) []string <span class="cov6" title="14">{
        var paths []string

        // Priority 1: Explicit local path
        if localPath != "" </span><span class="cov2" title="2">{
                paths = append(paths, localPath)
        }</span>

        // Priority 2: Package directory
        <span class="cov6" title="14">if packagePath != "" </span><span class="cov6" title="14">{
                paths = append(paths, packagePath)

                // Also check parent directory for workspace-level extensions
                parent := filepath.Dir(packagePath)
                if parent != "." &amp;&amp; parent != "/" </span><span class="cov6" title="14">{
                        paths = append(paths, parent)
                }</span>
        }

        // Priority 3: Current working directory
        <span class="cov6" title="14">if cwd, err := os.Getwd(); err == nil </span><span class="cov6" title="14">{
                paths = append(paths, cwd)
        }</span>

        // Priority 4: Home directory .kurel folder
        <span class="cov6" title="14">if home, err := os.UserHomeDir(); err == nil </span><span class="cov6" title="14">{
                kurelDir := filepath.Join(home, ".kurel", "extensions")
                paths = append(paths, kurelDir)
        }</span>

        // Remove duplicates
        <span class="cov6" title="14">seen := make(map[string]bool)
        var unique []string
        for _, p := range paths </span><span class="cov10" title="58">{
                abs, err := filepath.Abs(p)
                if err != nil </span><span class="cov0" title="0">{
                        abs = p
                }</span>
                <span class="cov10" title="58">if !seen[abs] </span><span class="cov9" title="57">{
                        seen[abs] = true
                        unique = append(unique, abs)
                }</span>
        }

        <span class="cov6" title="14">return unique</span>
}

// loadExtension loads a single extension file
func (e *extensionLoader) loadExtension(path string) (*LocalExtension, error) <span class="cov4" title="5">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewFileError("read", path, "failed to read extension file", err)
        }</span>

        <span class="cov4" title="5">var ext LocalExtension
        if err := yaml.Unmarshal(data, &amp;ext); err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewParseError(path, "invalid YAML syntax", 0, 0, err)
        }</span>

        <span class="cov4" title="5">ext.Path = path

        // Set default type if not specified
        if ext.Type == "" </span><span class="cov0" title="0">{
                ext.Type = ExtensionTypeMerge
        }</span>

        <span class="cov4" title="5">return &amp;ext, nil</span>
}

// applyExtension applies a single extension to the package
func (e *extensionLoader) applyExtension(ctx context.Context, def *PackageDefinition, ext LocalExtension, opts *LauncherOptions) error <span class="cov5" title="7">{
        e.logger.Debug("Applying extension from %s (type: %s)", ext.Path, ext.Type)

        // Apply parameter extensions
        if len(ext.Parameters) &gt; 0 </span><span class="cov4" title="4">{
                e.applyParameterExtension(def, ext.Parameters, ext.Type)
        }</span>

        // Apply patch extensions
        <span class="cov5" title="7">if len(ext.Patches) &gt; 0 </span><span class="cov1" title="1">{
                e.applyPatchExtension(def, ext.Patches, ext.Type)
        }</span>

        // Apply resource modifications
        <span class="cov5" title="7">if len(ext.Resources) &gt; 0 </span><span class="cov3" title="3">{
                if err := e.applyResourceExtension(ctx, def, ext.Resources); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to apply resource extensions")
                }</span>
        }

        // Remove resources if specified
        <span class="cov5" title="7">if len(ext.Remove) &gt; 0 </span><span class="cov1" title="1">{
                e.removeResources(def, ext.Remove)
        }</span>

        <span class="cov5" title="7">return nil</span>
}

// applyParameterExtension applies parameter modifications
func (e *extensionLoader) applyParameterExtension(def *PackageDefinition, params ParameterMap, extType ExtensionType) <span class="cov4" title="4">{
        switch extType </span>{
        case ExtensionTypeReplace:<span class="cov0" title="0">
                def.Parameters = params</span>
        case ExtensionTypeOverride:<span class="cov1" title="1">
                // Override only specified keys
                for k, v := range params </span><span class="cov2" title="2">{
                        def.Parameters[k] = v
                }</span>
        case ExtensionTypeMerge:<span class="cov3" title="3">
                // Deep merge parameters
                def.Parameters = e.mergeParameters(def.Parameters, params)</span>
        }
}

// applyPatchExtension applies patch modifications
func (e *extensionLoader) applyPatchExtension(def *PackageDefinition, patches []LocalPatch, extType ExtensionType) <span class="cov1" title="1">{
        switch extType </span>{
        case ExtensionTypeReplace:<span class="cov0" title="0">
                // Replace all patches
                def.Patches = []Patch{}
                for _, p := range patches </span><span class="cov0" title="0">{
                        def.Patches = append(def.Patches, Patch{
                                Name:     p.Name,
                                Content:  p.Content,
                                Metadata: p.Metadata,
                        })
                }</span>
        case ExtensionTypeOverride, ExtensionTypeMerge:<span class="cov1" title="1">
                // Add or update patches
                patchMap := make(map[string]int) // Map name to index
                for i := range def.Patches </span><span class="cov1" title="1">{
                        patchMap[def.Patches[i].Name] = i
                }</span>

                <span class="cov1" title="1">for _, p := range patches </span><span class="cov2" title="2">{
                        if idx, ok := patchMap[p.Name]; ok </span><span class="cov1" title="1">{
                                // Update existing patch in place
                                def.Patches[idx].Content = p.Content
                                if p.Metadata != nil </span><span class="cov0" title="0">{
                                        def.Patches[idx].Metadata = p.Metadata
                                }</span>
                        } else<span class="cov1" title="1"> {
                                // Add new patch
                                def.Patches = append(def.Patches, Patch{
                                        Name:     p.Name,
                                        Content:  p.Content,
                                        Metadata: p.Metadata,
                                })
                        }</span>
                }
        }
}

// applyResourceExtension applies resource modifications
func (e *extensionLoader) applyResourceExtension(ctx context.Context, def *PackageDefinition, overrides []LocalResourceOverride) error <span class="cov3" title="3">{
        for _, override := range overrides </span><span class="cov3" title="3">{
                // Find matching resources
                for i := range def.Resources </span><span class="cov4" title="5">{
                        if e.matchesSelector(&amp;def.Resources[i], override.Selector) </span><span class="cov1" title="1">{
                                // Apply override
                                if err := e.applyResourceOverride(&amp;def.Resources[i], override); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "failed to apply resource override")
                                }</span>
                        }
                }
        }
        <span class="cov3" title="3">return nil</span>
}

// matchesSelector checks if a resource matches a selector
func (e *extensionLoader) matchesSelector(resource *Resource, selector ResourceSelector) bool <span class="cov7" title="15">{
        // Check kind
        if selector.Kind != "" &amp;&amp; selector.Kind != resource.Kind </span><span class="cov4" title="5">{
                return false
        }</span>

        // Check name (supports wildcards)
        <span class="cov6" title="10">if selector.Name != "" </span><span class="cov4" title="4">{
                if !e.matchesPattern(resource.Metadata.Name, selector.Name) </span><span class="cov2" title="2">{
                        return false
                }</span>
        }

        // Check namespace
        <span class="cov5" title="8">if selector.Namespace != "" &amp;&amp; selector.Namespace != resource.Metadata.Namespace </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check labels
        <span class="cov5" title="8">if len(selector.Labels) &gt; 0 </span><span class="cov2" title="2">{
                resourceLabels := resource.Metadata.Labels
                for k, v := range selector.Labels </span><span class="cov2" title="2">{
                        if resourceLabels[k] != v </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
        }

        <span class="cov5" title="7">return true</span>
}

// matchesPattern checks if a string matches a pattern (supports * wildcard)
func (e *extensionLoader) matchesPattern(s, pattern string) bool <span class="cov4" title="4">{
        if pattern == "*" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov4" title="4">if strings.Contains(pattern, "*") </span><span class="cov1" title="1">{
                // Simple wildcard matching
                parts := strings.Split(pattern, "*")
                if len(parts) == 2 </span><span class="cov1" title="1">{
                        return strings.HasPrefix(s, parts[0]) &amp;&amp; strings.HasSuffix(s, parts[1])
                }</span>
        }
        <span class="cov3" title="3">return s == pattern</span>
}

// applyResourceOverride applies override to a resource
func (e *extensionLoader) applyResourceOverride(resource *Resource, override LocalResourceOverride) error <span class="cov1" title="1">{
        if resource.Raw == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">obj := resource.Raw.Object

        // Apply overrides (replace values)
        if override.Override != nil </span><span class="cov1" title="1">{
                for path, value := range override.Override </span><span class="cov1" title="1">{
                        if err := setNestedField(obj, value, strings.Split(path, ".")...); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to override field")
                        }</span>
                }
        }

        // Apply merges (deep merge)
        <span class="cov1" title="1">if override.Merge != nil </span><span class="cov1" title="1">{
                for path, value := range override.Merge </span><span class="cov1" title="1">{
                        if err := mergeNestedField(obj, value, strings.Split(path, ".")...); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to merge field")
                        }</span>
                }
        }

        // Remove fields
        <span class="cov1" title="1">for _, path := range override.Remove </span><span class="cov0" title="0">{
                removeNestedField(obj, strings.Split(path, ".")...)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// removeResources removes resources matching selectors
func (e *extensionLoader) removeResources(def *PackageDefinition, selectors []ResourceSelector) <span class="cov1" title="1">{
        var filtered []Resource

        for _, resource := range def.Resources </span><span class="cov3" title="3">{
                remove := false
                for _, selector := range selectors </span><span class="cov3" title="3">{
                        if e.matchesSelector(&amp;resource, selector) </span><span class="cov1" title="1">{
                                remove = true
                                e.logger.Debug("Removing resource %s/%s", resource.Kind, resource.Metadata.Name)
                                break</span>
                        }
                }
                <span class="cov3" title="3">if !remove </span><span class="cov2" title="2">{
                        filtered = append(filtered, resource)
                }</span>
        }

        <span class="cov1" title="1">def.Resources = filtered</span>
}

// mergeParameters performs deep merge of parameter maps
func (e *extensionLoader) mergeParameters(base, overlay ParameterMap) ParameterMap <span class="cov3" title="3">{
        result := make(ParameterMap)

        // Copy base
        for k, v := range base </span><span class="cov7" title="15">{
                result[k] = e.deepCopyValue(v)
        }</span>

        // Merge overlay
        <span class="cov3" title="3">for k, v := range overlay </span><span class="cov5" title="9">{
                if existing, ok := result[k]; ok </span><span class="cov5" title="9">{
                        // Merge if both are maps
                        if baseMap, ok1 := existing.(map[string]interface{}); ok1 </span><span class="cov1" title="1">{
                                if overlayMap, ok2 := v.(map[string]interface{}); ok2 </span><span class="cov1" title="1">{
                                        result[k] = e.mergeMaps(baseMap, overlayMap)
                                        continue</span>
                                }
                        }
                }
                // Otherwise replace
                <span class="cov5" title="8">result[k] = e.deepCopyValue(v)</span>
        }

        <span class="cov3" title="3">return result</span>
}

// mergeMaps performs deep merge of two maps
func (e *extensionLoader) mergeMaps(base, overlay map[string]interface{}) map[string]interface{} <span class="cov1" title="1">{
        result := make(map[string]interface{})

        // Copy base
        for k, v := range base </span><span class="cov1" title="1">{
                result[k] = e.deepCopyValue(v)
        }</span>

        // Merge overlay
        <span class="cov1" title="1">for k, v := range overlay </span><span class="cov2" title="2">{
                if existing, ok := result[k]; ok </span><span class="cov1" title="1">{
                        // Recursively merge if both are maps
                        if baseMap, ok1 := existing.(map[string]interface{}); ok1 </span><span class="cov0" title="0">{
                                if overlayMap, ok2 := v.(map[string]interface{}); ok2 </span><span class="cov0" title="0">{
                                        result[k] = e.mergeMaps(baseMap, overlayMap)
                                        continue</span>
                                }
                        }
                }
                <span class="cov2" title="2">result[k] = e.deepCopyValue(v)</span>
        }

        <span class="cov1" title="1">return result</span>
}

// deepCopyValue creates a deep copy of a value
func (e *extensionLoader) deepCopyValue(value interface{}) interface{} <span class="cov8" title="27">{
        switch v := value.(type) </span>{
        case map[string]interface{}:<span class="cov1" title="1">
                result := make(map[string]interface{})
                for k, val := range v </span><span class="cov1" title="1">{
                        result[k] = e.deepCopyValue(val)
                }</span>
                <span class="cov1" title="1">return result</span>
        case []interface{}:<span class="cov0" title="0">
                result := make([]interface{}, len(v))
                for i, val := range v </span><span class="cov0" title="0">{
                        result[i] = e.deepCopyValue(val)
                }</span>
                <span class="cov0" title="0">return result</span>
        default:<span class="cov8" title="26">
                return v</span>
        }
}

// sortExtensions sorts extensions by priority (alphabetical)
func (e *extensionLoader) sortExtensions(extensions []LocalExtension) <span class="cov6" title="13">{
        // Sort by filename for consistent ordering
        for i := 0; i &lt; len(extensions)-1; i++ </span><span class="cov1" title="1">{
                for j := i + 1; j &lt; len(extensions); j++ </span><span class="cov1" title="1">{
                        if filepath.Base(extensions[i].Path) &gt; filepath.Base(extensions[j].Path) </span><span class="cov0" title="0">{
                                extensions[i], extensions[j] = extensions[j], extensions[i]
                        }</span>
                }
        }
}

// Helper functions for nested field operations

func setNestedField(obj map[string]interface{}, value interface{}, path ...string) error <span class="cov2" title="2">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                return errors.New("empty path")
        }</span>

        <span class="cov2" title="2">current := obj
        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov3" title="3">{
                if next, ok := current[path[i]].(map[string]interface{}); ok </span><span class="cov2" title="2">{
                        current = next
                }</span> else<span class="cov1" title="1"> {
                        // Create intermediate maps if needed
                        next := make(map[string]interface{})
                        current[path[i]] = next
                        current = next
                }</span>
        }

        <span class="cov2" title="2">current[path[len(path)-1]] = value
        return nil</span>
}

func mergeNestedField(obj map[string]interface{}, value interface{}, path ...string) error <span class="cov2" title="2">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                return errors.New("empty path")
        }</span>

        <span class="cov2" title="2">current := obj
        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov5" title="7">{
                if next, ok := current[path[i]].(map[string]interface{}); ok </span><span class="cov4" title="4">{
                        current = next
                }</span> else<span class="cov3" title="3"> {
                        // Create intermediate maps if needed
                        next := make(map[string]interface{})
                        current[path[i]] = next
                        current = next
                }</span>
        }

        <span class="cov2" title="2">key := path[len(path)-1]
        if existing, ok := current[key]; ok </span><span class="cov0" title="0">{
                // Merge if both are maps
                if existingMap, ok1 := existing.(map[string]interface{}); ok1 </span><span class="cov0" title="0">{
                        if valueMap, ok2 := value.(map[string]interface{}); ok2 </span><span class="cov0" title="0">{
                                for k, v := range valueMap </span><span class="cov0" title="0">{
                                        existingMap[k] = v
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }
                }
        }

        // Otherwise set value
        <span class="cov2" title="2">current[key] = value
        return nil</span>
}

func removeNestedField(obj map[string]interface{}, path ...string) <span class="cov1" title="1">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">current := obj
        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov2" title="2">{
                if next, ok := current[path[i]].(map[string]interface{}); ok </span><span class="cov2" title="2">{
                        current = next
                }</span> else<span class="cov0" title="0"> {
                        return // Path doesn't exist
                }</span>
        }

        <span class="cov1" title="1">delete(current, path[len(path)-1])</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package launcher

import (
        "context"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "sync"

        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/io"
        "github.com/go-kure/kure/pkg/logger"
        "gopkg.in/yaml.v3"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// packageLoader implements the PackageLoader interface
type packageLoader struct {
        logger logger.Logger
        mu     sync.RWMutex
}

// NewPackageLoader creates a new package loader
func NewPackageLoader(log logger.Logger) PackageLoader <span class="cov6" title="31">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.Default()
        }</span>
        <span class="cov6" title="31">return &amp;packageLoader{
                logger: log,
        }</span>
}

// LoadDefinition loads a package definition from the specified path
func (l *packageLoader) LoadDefinition(ctx context.Context, path string, opts *LauncherOptions) (*PackageDefinition, error) <span class="cov6" title="38">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = DefaultOptions()
        }</span>
        <span class="cov6" title="38">if opts.Logger == nil </span><span class="cov0" title="0">{
                opts.Logger = logger.Default()
        }</span>

        <span class="cov6" title="38">l.logger.Debug("Loading package definition from %s", path)

        // Check if path exists
        info, err := os.Stat(path)
        if err != nil </span><span class="cov2" title="2">{
                return nil, errors.NewFileError("stat", path, "path not found", err)
        }</span>

        // Determine package root
        <span class="cov6" title="36">var pkgRoot string
        if info.IsDir() </span><span class="cov6" title="36">{
                pkgRoot = path
        }</span> else<span class="cov0" title="0"> {
                pkgRoot = filepath.Dir(path)
        }</span>

        // Create partial definition
        <span class="cov6" title="36">def := &amp;PackageDefinition{
                Path:       pkgRoot,
                Parameters: make(ParameterMap),
                Resources:  []Resource{},
                Patches:    []Patch{},
        }

        // Collect errors for hybrid error handling
        loadErrors := NewLoadErrors(def, nil)

        // Load kurel.yaml metadata
        if err := l.loadMetadata(ctx, def, pkgRoot, opts); err != nil </span><span class="cov0" title="0">{
                if !IsCriticalError(err) </span><span class="cov0" title="0">{
                        loadErrors.Issues = append(loadErrors.Issues, err)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        // Load parameters.yaml (non-critical - package can work without parameters)
        <span class="cov6" title="36">if err := l.loadParameters(ctx, def, pkgRoot, opts); err != nil </span><span class="cov1" title="1">{
                loadErrors.Issues = append(loadErrors.Issues, err)
                // Continue even if parameters fail to load
        }</span>

        // Load resources
        <span class="cov6" title="36">resources, err := l.LoadResources(ctx, pkgRoot, opts)
        if err != nil </span><span class="cov0" title="0">{
                if !IsCriticalError(err) </span><span class="cov0" title="0">{
                        loadErrors.Issues = append(loadErrors.Issues, err)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov6" title="36">def.Resources = resources

        // Load patches
        patches, err := l.LoadPatches(ctx, pkgRoot, opts)
        if err != nil </span><span class="cov0" title="0">{
                if !IsCriticalError(err) </span><span class="cov0" title="0">{
                        loadErrors.Issues = append(loadErrors.Issues, err)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov6" title="36">def.Patches = patches

        // Enforce patch name uniqueness
        if err := l.validatePatchUniqueness(patches); err != nil </span><span class="cov0" title="0">{
                loadErrors.Issues = append(loadErrors.Issues, err)
        }</span>

        // Return with any non-critical errors
        <span class="cov6" title="36">if len(loadErrors.Issues) &gt; 0 </span><span class="cov1" title="1">{
                l.logger.Warn("Package loaded with %d issues", len(loadErrors.Issues))
                return def, loadErrors
        }</span>

        <span class="cov6" title="35">l.logger.Info("Successfully loaded package %s", def.Metadata.Name)
        return def, nil</span>
}

// loadMetadata loads the kurel.yaml file
func (l *packageLoader) loadMetadata(ctx context.Context, def *PackageDefinition, pkgRoot string, opts *LauncherOptions) error <span class="cov6" title="36">{
        metaPath := filepath.Join(pkgRoot, "kurel.yaml")

        // Check if file exists
        if _, err := os.Stat(metaPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                // Metadata is optional, use defaults
                def.Metadata = KurelMetadata{
                        Name:    filepath.Base(pkgRoot),
                        Version: "0.0.0",
                }
                l.logger.Debug("No kurel.yaml found, using defaults")
                return nil
        }</span>

        // Load the metadata file
        <span class="cov6" title="35">data, err := os.ReadFile(metaPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewFileError("read", metaPath, "failed to read metadata", err)
        }</span>

        // Parse YAML
        <span class="cov6" title="35">var meta KurelMetadata
        if err := yaml.Unmarshal(data, &amp;meta); err != nil </span><span class="cov0" title="0">{
                return errors.NewParseError(metaPath, "invalid YAML syntax", 0, 0, err)
        }</span>

        <span class="cov6" title="35">def.Metadata = meta
        return nil</span>
}

// loadParameters loads the parameters.yaml file
func (l *packageLoader) loadParameters(ctx context.Context, def *PackageDefinition, pkgRoot string, opts *LauncherOptions) error <span class="cov6" title="36">{
        paramPath := filepath.Join(pkgRoot, "parameters.yaml")

        // Check if file exists
        if _, err := os.Stat(paramPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                // Parameters are optional
                l.logger.Debug("No parameters.yaml found")
                return nil
        }</span>

        // Load the parameters file
        <span class="cov6" title="35">data, err := os.ReadFile(paramPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewFileError("read", paramPath, "failed to read parameters", err)
        }</span>

        // Parse YAML into ParameterMap
        <span class="cov6" title="35">var params ParameterMap
        if err := yaml.Unmarshal(data, &amp;params); err != nil </span><span class="cov1" title="1">{
                return errors.NewParseError(paramPath, "invalid YAML syntax", 0, 0, err)
        }</span>

        <span class="cov6" title="34">def.Parameters = params
        return nil</span>
}

// LoadResources loads Kubernetes resources from the package
func (l *packageLoader) LoadResources(ctx context.Context, path string, opts *LauncherOptions) ([]Resource, error) <span class="cov6" title="38">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = DefaultOptions()
        }</span>

        <span class="cov6" title="38">l.logger.Debug("Loading resources from %s", path)

        // Determine resource directory
        resourceDir := path
        if info, err := os.Stat(path); err == nil &amp;&amp; !info.IsDir() </span><span class="cov0" title="0">{
                resourceDir = filepath.Dir(path)
        }</span>

        // Look for resources in standard locations
        <span class="cov6" title="38">var resources []Resource
        seenResources := make(map[string]bool) // Track processed files to avoid duplicates
        locations := []string{
                filepath.Join(resourceDir, "resources"),
                filepath.Join(resourceDir, "manifests"),
                resourceDir, // Also check root directory
        }

        for _, loc := range locations </span><span class="cov7" title="114">{
                if _, err := os.Stat(loc); err != nil </span><span class="cov6" title="40">{
                        continue</span>
                }

                // Find all YAML files
                <span class="cov7" title="74">err := filepath.Walk(loc, func(path string, info os.FileInfo, err error) error </span><span class="cov10" title="479">{
                        if err != nil </span><span class="cov0" title="0">{
                                return nil // Skip files with errors
                        }</span>

                        // Skip directories and non-YAML files
                        <span class="cov10" title="479">if info.IsDir() || !isYAMLFile(path) </span><span class="cov9" title="243">{
                                return nil
                        }</span>

                        // Skip patch files
                        <span class="cov8" title="236">if strings.Contains(path, "patches/") || strings.HasSuffix(path, ".kpatch") </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // Skip package metadata and parameter files
                        <span class="cov8" title="236">filename := filepath.Base(path)
                        if filename == "kurel.yaml" || filename == "parameters.yaml" </span><span class="cov7" title="78">{
                                return nil
                        }</span>

                        // Skip files we've already processed
                        <span class="cov8" title="158">if seenResources[path] </span><span class="cov7" title="73">{
                                return nil
                        }</span>
                        <span class="cov7" title="85">seenResources[path] = true

                        // Read raw file content first (may contain templates)
                        rawData, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                l.logger.Warn("Failed to read %s: %v", path, err)
                                return nil
                        }</span>

                        // Try to parse as Kubernetes objects
                        // If it contains variables, this will fail and we'll store as template
                        <span class="cov7" title="85">objs, parseErr := io.ParseYAML(rawData)
                        if parseErr != nil </span><span class="cov6" title="58">{
                                // File likely contains template variables, store as template data
                                l.logger.Debug("File %s contains templates, deferring parsing: %v", path, parseErr)

                                // Create a placeholder resource with template data
                                // We'll need basic metadata to identify it later
                                if err := l.loadTemplateResource(path, rawData, &amp;resources); err != nil </span><span class="cov0" title="0">{
                                        l.logger.Warn("Failed to load template resource %s: %v", path, err)
                                }</span>
                                <span class="cov6" title="58">return nil</span>
                        }

                        // Successfully parsed - convert to launcher Resources
                        <span class="cov5" title="27">for _, obj := range objs </span><span class="cov5" title="27">{
                                res, err := l.clientObjectToResource(obj)
                                if err != nil </span><span class="cov0" title="0">{
                                        l.logger.Warn("Failed to convert object from %s: %v", path, err)
                                        continue</span>
                                }
                                // Also store the raw template data for later processing
                                <span class="cov5" title="27">res.TemplateData = rawData
                                resources = append(resources, res)</span>
                        }

                        <span class="cov5" title="27">return nil</span>
                })

                <span class="cov7" title="74">if err != nil </span><span class="cov0" title="0">{
                        l.logger.Warn("Error walking directory %s: %v", loc, err)
                }</span>
        }

        <span class="cov6" title="38">l.logger.Info("Loaded %d resources", len(resources))
        return resources, nil</span>
}

// loadTemplateResource creates a placeholder resource for template files
func (l *packageLoader) loadTemplateResource(path string, rawData []byte, resources *[]Resource) error <span class="cov6" title="58">{
        // Extract basic resource info from the template by looking for YAML structure
        // This is a heuristic approach - we'll look for apiVersion, kind, metadata patterns
        content := string(rawData)

        // Try to extract apiVersion and kind even with variable substitution
        var apiVersion, kind, name, namespace string

        // Look for apiVersion (may contain variables)
        if matches := regexp.MustCompile(`apiVersion:\s*(.+)`).FindStringSubmatch(content); len(matches) &gt; 1 </span><span class="cov6" title="56">{
                apiVersion = strings.TrimSpace(matches[1])
        }</span>

        // Look for kind (may contain variables)
        <span class="cov6" title="58">if matches := regexp.MustCompile(`kind:\s*(.+)`).FindStringSubmatch(content); len(matches) &gt; 1 </span><span class="cov6" title="56">{
                kind = strings.TrimSpace(matches[1])
        }</span>

        // Look for metadata.name (may contain variables)
        <span class="cov6" title="58">if matches := regexp.MustCompile(`name:\s*(.+)`).FindStringSubmatch(content); len(matches) &gt; 1 </span><span class="cov6" title="56">{
                name = strings.TrimSpace(matches[1])
        }</span>

        // Look for metadata.namespace (may contain variables)
        <span class="cov6" title="58">if matches := regexp.MustCompile(`namespace:\s*(.+)`).FindStringSubmatch(content); len(matches) &gt; 1 </span><span class="cov6" title="56">{
                namespace = strings.TrimSpace(matches[1])
        }</span>

        // Create a placeholder resource
        <span class="cov6" title="58">resource := Resource{
                APIVersion:   apiVersion,
                Kind:         kind,
                TemplateData: rawData,
                Metadata: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
        }

        *resources = append(*resources, resource)
        l.logger.Debug("Loaded template resource: %s/%s from %s", kind, name, path)
        return nil</span>
}

// LoadPatches loads patch files from the package
func (l *packageLoader) LoadPatches(ctx context.Context, path string, opts *LauncherOptions) ([]Patch, error) <span class="cov6" title="38">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = DefaultOptions()
        }</span>

        <span class="cov6" title="38">l.logger.Debug("Loading patches from %s", path)

        // Determine patch directory
        patchDir := filepath.Join(path, "patches")
        if info, err := os.Stat(path); err == nil &amp;&amp; !info.IsDir() </span><span class="cov0" title="0">{
                patchDir = filepath.Join(filepath.Dir(path), "patches")
        }</span>

        // Check if patches directory exists
        <span class="cov6" title="38">if _, err := os.Stat(patchDir); os.IsNotExist(err) </span><span class="cov4" title="10">{
                l.logger.Debug("No patches directory found")
                return nil, nil
        }</span>

        <span class="cov5" title="28">var patches []Patch

        // Find all patch files
        err := filepath.Walk(patchDir, func(path string, info os.FileInfo, err error) error </span><span class="cov7" title="83">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip files with errors
                }</span>

                // Skip directories and non-patch files
                <span class="cov7" title="83">if info.IsDir() || !isPatchFile(path) </span><span class="cov5" title="28">{
                        return nil
                }</span>

                // Load patch file
                <span class="cov6" title="55">patch, err := l.loadPatchFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        l.logger.Warn("Failed to load patch %s: %v", path, err)
                        return nil // Continue with other patches
                }</span>

                <span class="cov6" title="55">patches = append(patches, patch)
                return nil</span>
        })

        <span class="cov5" title="28">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewFileError("walk", patchDir, "failed to scan patches", err)
        }</span>

        <span class="cov5" title="28">l.logger.Info("Loaded %d patches", len(patches))
        return patches, nil</span>
}

// loadPatchFile loads a single patch file
func (l *packageLoader) loadPatchFile(path string) (Patch, error) <span class="cov6" title="55">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return Patch{}, errors.NewFileError("read", path, "failed to read patch", err)
        }</span>

        // Extract patch name from filename
        <span class="cov6" title="55">name := strings.TrimSuffix(filepath.Base(path), filepath.Ext(path))

        patch := Patch{
                Name:    name,
                Path:    path,
                Content: string(data),
        }

        // Check for metadata header in the patch file
        if strings.HasPrefix(string(data), "# kurel:") </span><span class="cov1" title="1">{
                patch.Metadata = l.parsePatchMetadata(string(data))
        }</span>

        <span class="cov6" title="55">return patch, nil</span>
}

// parsePatchMetadata extracts metadata from patch file comments
func (l *packageLoader) parsePatchMetadata(content string) *PatchMetadata <span class="cov1" title="1">{
        lines := strings.Split(content, "\n")
        meta := &amp;PatchMetadata{}

        for _, line := range lines </span><span class="cov3" title="4">{
                line = strings.TrimSpace(line)
                if !strings.HasPrefix(line, "# kurel:") </span><span class="cov1" title="1">{
                        break</span> // Stop at first non-metadata line
                }

                // Parse metadata directives
                <span class="cov2" title="3">directive := strings.TrimPrefix(line, "# kurel:")
                parts := strings.SplitN(directive, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="3">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                switch key </span>{
                case "enabled":<span class="cov1" title="1">
                        meta.Enabled = value</span>
                case "description":<span class="cov1" title="1">
                        meta.Description = value</span>
                case "requires":<span class="cov1" title="1">
                        meta.Requires = strings.Fields(value)</span>
                case "conflicts":<span class="cov0" title="0">
                        meta.Conflicts = strings.Fields(value)</span>
                }
        }

        <span class="cov1" title="1">return meta</span>
}

// clientObjectToResource converts a client.Object to a launcher Resource
func (l *packageLoader) clientObjectToResource(obj client.Object) (Resource, error) <span class="cov5" title="27">{
        // Convert to unstructured
        u, ok := obj.(*unstructured.Unstructured)
        if !ok </span><span class="cov5" title="27">{
                // Try to convert through runtime
                data, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return Resource{}, errors.Wrap(err, "failed to convert to unstructured")
                }</span>
                <span class="cov5" title="27">u = &amp;unstructured.Unstructured{Object: data}</span>
        }

        <span class="cov5" title="27">gvk := u.GetObjectKind().GroupVersionKind()

        // Extract metadata
        meta := metav1.ObjectMeta{
                Name:        u.GetName(),
                Namespace:   u.GetNamespace(),
                Labels:      u.GetLabels(),
                Annotations: u.GetAnnotations(),
        }

        return Resource{
                APIVersion: gvk.GroupVersion().String(),
                Kind:       gvk.Kind,
                Metadata:   meta,
                Raw:        u.DeepCopy(),
        }, nil</span>
}

// validatePatchUniqueness ensures all patch names are unique
func (l *packageLoader) validatePatchUniqueness(patches []Patch) error <span class="cov6" title="37">{
        seen := make(map[string]bool)
        var duplicates []string

        for _, patch := range patches </span><span class="cov6" title="57">{
                if seen[patch.Name] </span><span class="cov1" title="1">{
                        duplicates = append(duplicates, patch.Name)
                }</span>
                <span class="cov6" title="57">seen[patch.Name] = true</span>
        }

        <span class="cov6" title="37">if len(duplicates) &gt; 0 </span><span class="cov1" title="1">{
                return NewDependencyError("conflict", "patches", strings.Join(duplicates, ", "), nil)
        }</span>

        <span class="cov6" title="36">return nil</span>
}

// isYAMLFile checks if a file is a YAML file
func isYAMLFile(path string) bool <span class="cov9" title="337">{
        ext := strings.ToLower(filepath.Ext(path))
        return ext == ".yaml" || ext == ".yml"
}</span>

// isPatchFile checks if a file is a patch file
func isPatchFile(path string) bool <span class="cov6" title="60">{
        ext := strings.ToLower(filepath.Ext(path))
        return ext == ".kpatch" || ext == ".patch" || ext == ".toml" ||
                (isYAMLFile(path) &amp;&amp; strings.Contains(path, "patches/"))
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package launcher

import (
        "runtime"
        "time"

        "github.com/go-kure/kure/pkg/logger"
)

// LauncherOptions centralizes common configuration for all launcher components
type LauncherOptions struct {
        Logger       logger.Logger // Logger instance
        MaxDepth     int           // Maximum variable resolution depth
        Timeout      time.Duration // Operation timeout
        MaxWorkers   int           // Number of concurrent workers
        CacheDir     string        // Directory for caching schemas
        Debug        bool          // Enable debug output
        Verbose      bool          // Enable verbose logging
        StrictMode   bool          // Treat warnings as errors
        ProgressFunc func(string)  // Progress callback function
}

// DefaultOptions returns sensible default options
func DefaultOptions() *LauncherOptions <span class="cov7" title="32">{
        return &amp;LauncherOptions{
                Logger:     logger.Default(),
                MaxDepth:   10,
                Timeout:    30 * time.Second,
                MaxWorkers: runtime.NumCPU(),
                CacheDir:   "/tmp/kurel-cache",
                Debug:      false,
                Verbose:    false,
        }
}</span>

// WithLogger sets the logger
func (o *LauncherOptions) WithLogger(l logger.Logger) *LauncherOptions <span class="cov0" title="0">{
        o.Logger = l
        return o
}</span>

// WithTimeout sets the timeout
func (o *LauncherOptions) WithTimeout(timeout time.Duration) *LauncherOptions <span class="cov0" title="0">{
        o.Timeout = timeout
        return o
}</span>

// WithDebug enables debug mode
func (o *LauncherOptions) WithDebug(debug bool) *LauncherOptions <span class="cov0" title="0">{
        o.Debug = debug
        return o
}</span>

// WithVerbose enables verbose mode
func (o *LauncherOptions) WithVerbose(verbose bool) *LauncherOptions <span class="cov0" title="0">{
        o.Verbose = verbose
        return o
}</span>

// BuildOptions configures the build process
type BuildOptions struct {
        // Output configuration
        Output       OutputDest   // Where to write (stdout, file, directory)
        OutputPath   string       // Output path for file/directory
        OutputFormat OutputFormat // How to organize files

        // Serialization
        Format      SerializationFormat // YAML or JSON
        PrettyPrint bool                // Pretty print JSON

        // File organization
        SeparateFiles    bool // Write each resource to its own file
        IncludeIndex     bool // Add numeric prefix to filenames
        IncludeNamespace bool // Add namespace to filenames

        // Filtering
        FilterKind      string // Only output resources of this kind
        FilterName      string // Only output resources with this name
        FilterNamespace string // Only output resources in this namespace

        // Transformations
        AddLabels      map[string]string // Add these labels to all resources
        AddAnnotations map[string]string // Add these annotations to all resources
}

// OutputDest defines where to write output
type OutputDest string

const (
        OutputStdout    OutputDest = "stdout"    // Write to stdout
        OutputFile      OutputDest = "file"      // Write to single file
        OutputDirectory OutputDest = "directory" // Write to directory
)

// OutputFormat defines how to organize output files
type OutputFormat string

const (
        OutputFormatSingle     OutputFormat = "single"      // Single file
        OutputFormatByKind     OutputFormat = "by-kind"     // Group by resource kind
        OutputFormatByResource OutputFormat = "by-resource" // Separate file per resource
)

// SerializationFormat defines the output serialization format
type SerializationFormat string

const (
        FormatYAML SerializationFormat = "yaml" // YAML format
        FormatJSON SerializationFormat = "json" // JSON format
)

// OutputType is deprecated, use SerializationFormat instead
type OutputType = SerializationFormat

const (
        OutputTypeYAML OutputType = FormatYAML // Deprecated: use FormatYAML
        OutputTypeJSON OutputType = FormatJSON // Deprecated: use FormatJSON
)

// ValidationResult contains validation errors and warnings
type ValidationResult struct {
        Errors   []ValidationError   `json:"errors,omitempty"`
        Warnings []ValidationWarning `json:"warnings,omitempty"`
}

// HasErrors returns true if there are any errors
func (r ValidationResult) HasErrors() bool <span class="cov10" title="142">{
        return len(r.Errors) &gt; 0
}</span>

// HasWarnings returns true if there are any warnings
func (r ValidationResult) HasWarnings() bool <span class="cov2" title="2">{
        return len(r.Warnings) &gt; 0
}</span>

// IsValid returns true if there are no errors
func (r ValidationResult) IsValid() bool <span class="cov9" title="140">{
        return !r.HasErrors()
}</span>

// ValidationError represents a validation error that blocks processing
type ValidationError struct {
        Resource string `json:"resource,omitempty"`
        Field    string `json:"field,omitempty"`
        Path     string `json:"path,omitempty"` // JSON path to the field
        Message  string `json:"message"`
        Severity string `json:"severity,omitempty"` // "error" or "warning"
}

// Error implements the error interface
func (e ValidationError) Error() string <span class="cov6" title="20">{
        if e.Resource != "" &amp;&amp; e.Field != "" </span><span class="cov1" title="1">{
                return e.Resource + "." + e.Field + ": " + e.Message
        }</span>
        <span class="cov6" title="19">if e.Resource != "" </span><span class="cov1" title="1">{
                return e.Resource + ": " + e.Message
        }</span>
        <span class="cov6" title="18">if e.Field != "" </span><span class="cov4" title="9">{
                return e.Field + ": " + e.Message
        }</span>
        <span class="cov4" title="9">return e.Message</span>
}

// ValidationWarning represents a non-blocking validation issue
type ValidationWarning struct {
        Resource string `json:"resource,omitempty"`
        Field    string `json:"field,omitempty"`
        Message  string `json:"message"`
}

// String returns the warning message
func (w ValidationWarning) String() string <span class="cov0" title="0">{
        if w.Resource != "" &amp;&amp; w.Field != "" </span><span class="cov0" title="0">{
                return w.Resource + "." + w.Field + ": " + w.Message
        }</span>
        <span class="cov0" title="0">if w.Resource != "" </span><span class="cov0" title="0">{
                return w.Resource + ": " + w.Message
        }</span>
        <span class="cov0" title="0">if w.Field != "" </span><span class="cov0" title="0">{
                return w.Field + ": " + w.Message
        }</span>
        <span class="cov0" title="0">return w.Message</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package launcher

import (
        "context"
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/logger"
        "github.com/go-kure/kure/pkg/patch"
)

// patchProcessor implements the PatchProcessor interface
type patchProcessor struct {
        logger   logger.Logger
        resolver Resolver
        verbose  bool
}

// NewPatchProcessor creates a new patch processor
func NewPatchProcessor(log logger.Logger, resolver Resolver) PatchProcessor <span class="cov8" title="33">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.Default()
        }</span>
        <span class="cov8" title="33">if resolver == nil </span><span class="cov6" title="16">{
                resolver = NewResolver(log)
        }</span>
        <span class="cov8" title="33">return &amp;patchProcessor{
                logger:   log,
                resolver: resolver,
        }</span>
}

// ResolveDependencies determines which patches to enable based on conditions and dependencies
func (p *patchProcessor) ResolveDependencies(ctx context.Context, patches []Patch, params ParameterMap) ([]Patch, error) <span class="cov7" title="18">{
        p.logger.Debug("Resolving patch dependencies for %d patches", len(patches))

        // Build patch map for quick lookup
        patchMap := make(map[string]*Patch)
        for i := range patches </span><span class="cov8" title="33">{
                patchMap[patches[i].Name] = &amp;patches[i]
        }</span>

        // Track enabled patches
        <span class="cov7" title="18">enabled := make(map[string]bool)
        resolved := []Patch{}

        // First pass: evaluate conditions
        for _, patch := range patches </span><span class="cov8" title="33">{
                if p.shouldEnablePatch(patch, params) </span><span class="cov8" title="32">{
                        enabled[patch.Name] = true
                        p.logger.Debug("Patch %s enabled by condition", patch.Name)
                }</span> else<span class="cov1" title="1"> {
                        p.logger.Debug("Patch %s disabled by condition", patch.Name)
                }</span>
        }

        // Second pass: resolve dependencies
        <span class="cov7" title="18">for name := range enabled </span><span class="cov8" title="32">{
                if err := p.checkDependencies(name, patchMap, enabled); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }

        // Third pass: check conflicts
        <span class="cov7" title="17">for name := range enabled </span><span class="cov8" title="31">{
                if err := p.checkConflicts(name, patchMap, enabled); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }

        // Build final list of enabled patches in dependency order
        <span class="cov6" title="16">ordered := p.orderByDependencies(enabled, patchMap)
        for _, name := range ordered </span><span class="cov8" title="29">{
                if patch, ok := patchMap[name]; ok </span><span class="cov8" title="29">{
                        resolved = append(resolved, *patch)
                }</span>
        }

        <span class="cov6" title="16">p.logger.Info("Resolved %d patches from %d total", len(resolved), len(patches))
        return resolved, nil</span>
}

// ApplyPatches applies patches to a package definition (returns deep copy)
func (p *patchProcessor) ApplyPatches(ctx context.Context, def *PackageDefinition, patches []Patch, params ParameterMap) (*PackageDefinition, error) <span class="cov7" title="23">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, errors.Wrap(ctx.Err(), "context cancelled during patch application")</span>
        default:<span class="cov7" title="23"></span>
        }

        <span class="cov7" title="23">if def == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("package definition is nil")
        }</span>

        <span class="cov7" title="23">if len(patches) == 0 </span><span class="cov5" title="10">{
                p.logger.Debug("No patches to apply")
                return def.DeepCopy(), nil
        }</span>

        <span class="cov6" title="13">p.logger.Info("Applying %d patches to package", len(patches))

        // Create deep copy to maintain immutability
        result := def.DeepCopy()

        // Resolve variables in parameters first
        resolvedParams, err := p.resolver.Resolve(ctx, params, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("failed to resolve parameters: %w", err)
        }</span>

        // Convert resolved params to VariableContext for patch engine
        <span class="cov6" title="13">varCtx := p.createVariableContext(resolvedParams)

        // Apply each patch
        for _, patch := range patches </span><span class="cov7" title="23">{
                p.logger.Debug("Applying patch %s", patch.Name)

                if p.verbose </span><span class="cov0" title="0">{
                        p.logger.Info("Patch %s:\n%s", patch.Name, patch.Content)
                }</span>

                // Parse patch content
                <span class="cov7" title="23">patchSpecs, err := p.parsePatch(patch, varCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, NewPatchError(patch.Name, "", "", "", fmt.Sprintf("failed to parse patch: %v", err))
                }</span>

                // Apply patch to resources
                <span class="cov7" title="23">for i, resource := range result.Resources </span><span class="cov9" title="44">{
                        applied, err := p.applyPatchToResource(&amp;resource, patchSpecs, patch.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, NewPatchError(patch.Name, resource.Kind, resource.GetName(), "", fmt.Sprintf("patch application failed: %v", err))
                        }</span>
                        <span class="cov9" title="44">if applied </span><span class="cov3" title="3">{
                                result.Resources[i] = resource
                                p.logger.Debug("Applied patch %s to resource %s", patch.Name, resource.GetName())
                        }</span>
                }
        }

        <span class="cov6" title="13">p.logger.Info("Successfully applied all patches")
        return result, nil</span>
}

// shouldEnablePatch evaluates if a patch should be enabled based on its condition
func (p *patchProcessor) shouldEnablePatch(patch Patch, params ParameterMap) bool <span class="cov8" title="33">{
        if patch.Metadata == nil || patch.Metadata.Enabled == "" </span><span class="cov8" title="29">{
                // No condition, patch is enabled by default
                return true
        }</span>

        // Evaluate the enabled expression
        <span class="cov3" title="4">enabled := p.evaluateExpression(patch.Metadata.Enabled, params)
        return enabled</span>
}

// evaluateExpression evaluates a simple boolean expression
func (p *patchProcessor) evaluateExpression(expr string, params ParameterMap) bool <span class="cov6" title="11">{
        // Handle variable references like ${feature.enabled}
        if strings.HasPrefix(expr, "${") &amp;&amp; strings.HasSuffix(expr, "}") </span><span class="cov5" title="7">{
                varPath := expr[2 : len(expr)-1]
                value := p.lookupVariable(varPath, params)
                return p.toBool(value)
        }</span>

        // Handle literal values
        <span class="cov3" title="4">return p.toBool(expr)</span>
}

// lookupVariable looks up a variable by path
func (p *patchProcessor) lookupVariable(path string, params ParameterMap) interface{} <span class="cov5" title="7">{
        parts := strings.Split(path, ".")
        current := params

        for i, part := range parts </span><span class="cov5" title="8">{
                val, ok := current[part]
                if !ok </span><span class="cov1" title="1">{
                        return nil
                }</span>

                <span class="cov5" title="7">if i == len(parts)-1 </span><span class="cov4" title="6">{
                        return val
                }</span>

                <span class="cov1" title="1">if m, ok := val.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        current = m
                }</span> else<span class="cov0" title="0"> if m, ok := val.(ParameterMap); ok </span><span class="cov0" title="0">{
                        current = m
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// toBool converts a value to boolean
func (p *patchProcessor) toBool(value interface{}) bool <span class="cov7" title="24">{
        switch v := value.(type) </span>{
        case bool:<span class="cov4" title="5">
                return v</span>
        case string:<span class="cov6" title="12">
                // Empty string is false, any non-empty string (except explicit false values) is true
                if v == "" || v == "false" || v == "no" || v == "0" || v == "disabled" </span><span class="cov3" title="4">{
                        return false
                }</span>
                <span class="cov5" title="8">return true</span>
        case int:<span class="cov3" title="3">
                return v != 0</span>
        case int32:<span class="cov0" title="0">
                return v != 0</span>
        case int64:<span class="cov0" title="0">
                return v != 0</span>
        case float32:<span class="cov0" title="0">
                return v != 0</span>
        case float64:<span class="cov2" title="2">
                return v != 0</span>
        default:<span class="cov2" title="2">
                return value != nil</span>
        }
}

// checkDependencies verifies all required dependencies are enabled
func (p *patchProcessor) checkDependencies(name string, patchMap map[string]*Patch, enabled map[string]bool) error <span class="cov8" title="32">{
        patch, ok := patchMap[name]
        if !ok </span><span class="cov0" title="0">{
                return errors.Errorf("patch %s not found", name)
        }</span>

        <span class="cov8" title="32">if patch.Metadata == nil </span><span class="cov7" title="25">{
                return nil
        }</span>

        <span class="cov5" title="7">for _, dep := range patch.Metadata.Requires </span><span class="cov3" title="3">{
                if !enabled[dep] </span><span class="cov1" title="1">{
                        return NewDependencyError("missing", name, dep, nil)
                }</span>
        }

        <span class="cov4" title="6">return nil</span>
}

// checkConflicts verifies no conflicting patches are enabled
func (p *patchProcessor) checkConflicts(name string, patchMap map[string]*Patch, enabled map[string]bool) error <span class="cov8" title="31">{
        patch, ok := patchMap[name]
        if !ok </span><span class="cov0" title="0">{
                return errors.Errorf("patch %s not found", name)
        }</span>

        <span class="cov8" title="31">if patch.Metadata == nil </span><span class="cov7" title="25">{
                return nil
        }</span>

        <span class="cov4" title="6">for _, conflict := range patch.Metadata.Conflicts </span><span class="cov1" title="1">{
                if enabled[conflict] </span><span class="cov1" title="1">{
                        return NewDependencyError("conflict", name, conflict, nil)
                }</span>
        }

        <span class="cov4" title="5">return nil</span>
}

// orderByDependencies returns patches in dependency order
func (p *patchProcessor) orderByDependencies(enabled map[string]bool, patchMap map[string]*Patch) []string <span class="cov7" title="19">{
        // Build dependency graph
        graph := make(map[string][]string)
        indegree := make(map[string]int)

        for name := range enabled </span><span class="cov8" title="38">{
                if _, ok := indegree[name]; !ok </span><span class="cov8" title="38">{
                        indegree[name] = 0
                }</span>

                <span class="cov8" title="38">if patch, ok := patchMap[name]; ok &amp;&amp; patch.Metadata != nil </span><span class="cov5" title="9">{
                        for _, dep := range patch.Metadata.Requires </span><span class="cov4" title="6">{
                                if enabled[dep] </span><span class="cov4" title="6">{
                                        graph[dep] = append(graph[dep], name)
                                        indegree[name]++
                                }</span>
                        }
                }
        }

        // Topological sort
        <span class="cov7" title="19">var result []string
        queue := []string{}

        for name, degree := range indegree </span><span class="cov8" title="38">{
                if degree == 0 </span><span class="cov8" title="32">{
                        queue = append(queue, name)
                }</span>
        }

        <span class="cov7" title="19">for len(queue) &gt; 0 </span><span class="cov8" title="38">{
                current := queue[0]
                queue = queue[1:]
                result = append(result, current)

                for _, next := range graph[current] </span><span class="cov4" title="6">{
                        indegree[next]--
                        if indegree[next] == 0 </span><span class="cov4" title="6">{
                                queue = append(queue, next)
                        }</span>
                }
        }

        // If we couldn't order all patches, there's a cycle (shouldn't happen after dependency check)
        <span class="cov7" title="19">if len(result) != len(enabled) </span><span class="cov0" title="0">{
                // Fall back to alphabetical order
                for name := range enabled </span><span class="cov0" title="0">{
                        found := false
                        for _, r := range result </span><span class="cov0" title="0">{
                                if r == name </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                result = append(result, name)
                        }</span>
                }
                <span class="cov0" title="0">sort.Strings(result)</span>
        }

        <span class="cov7" title="19">return result</span>
}

// createVariableContext converts resolved parameters to patch.VariableContext
func (p *patchProcessor) createVariableContext(params ParameterMapWithSource) *patch.VariableContext <span class="cov6" title="14">{
        // The patch engine expects variables under "values" namespace
        values := make(map[string]interface{})
        features := make(map[string]bool)

        for key, source := range params </span><span class="cov9" title="67">{
                // Add to values map (flattened)
                p.addToValues(key, source.Value, values)

                // If it's a boolean and starts with "feature", also add to features map
                if b, ok := source.Value.(bool); ok &amp;&amp; strings.HasPrefix(key, "feature") </span><span class="cov0" title="0">{
                        // Remove "feature." prefix if present
                        featureKey := strings.TrimPrefix(key, "feature.")
                        features[featureKey] = b
                }</span>
        }

        <span class="cov6" title="14">return &amp;patch.VariableContext{
                Values:   values,
                Features: features,
        }</span>
}

// addToValues recursively adds parameters to values map
func (p *patchProcessor) addToValues(prefix string, value interface{}, values map[string]interface{}) <span class="cov10" title="70">{
        switch v := value.(type) </span>{
        case map[string]interface{}:<span class="cov2" title="2">
                // Add the map itself
                values[prefix] = v
                // Also add flattened keys
                for k, val := range v </span><span class="cov3" title="3">{
                        key := prefix + "." + k
                        p.addToValues(key, val, values)
                }</span>
        case []interface{}:<span class="cov1" title="1">
                // Add the array itself
                values[prefix] = v
                // Also add individual elements
                for i, val := range v </span><span class="cov3" title="3">{
                        key := fmt.Sprintf("%s[%d]", prefix, i)
                        values[key] = val
                }</span>
        default:<span class="cov9" title="67">
                // Add simple values directly
                values[prefix] = value</span>
        }
}

// addToVariables recursively adds parameters to variable map
func (p *patchProcessor) addToVariables(prefix string, value interface{}, vars map[string]string) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                vars[prefix] = v</span>
        case bool:<span class="cov0" title="0">
                vars[prefix] = strconv.FormatBool(v)</span>
        case int, int32, int64:<span class="cov0" title="0">
                vars[prefix] = fmt.Sprintf("%d", v)</span>
        case float32, float64:<span class="cov0" title="0">
                vars[prefix] = fmt.Sprintf("%v", v)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                for k, val := range v </span><span class="cov0" title="0">{
                        key := prefix + "." + k
                        p.addToVariables(key, val, vars)
                }</span>
        case []interface{}:<span class="cov0" title="0">
                for i, val := range v </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%s[%d]", prefix, i)
                        p.addToVariables(key, val, vars)
                }</span>
        }
}

// parsePatch parses patch content into PatchSpecs
func (p *patchProcessor) parsePatch(patchDef Patch, varCtx *patch.VariableContext) ([]patch.PatchSpec, error) <span class="cov7" title="23">{
        reader := strings.NewReader(patchDef.Content)
        return patch.LoadPatchFileWithVariables(reader, varCtx)
}</span>

// applyPatchToResource applies patch specs to a resource
func (p *patchProcessor) applyPatchToResource(resource *Resource, specs []patch.PatchSpec, patchName string) (bool, error) <span class="cov9" title="44">{
        if resource.Raw == nil </span><span class="cov8" title="40">{
                return false, nil
        }</span>

        <span class="cov3" title="4">applied := false

        for _, spec := range specs </span><span class="cov4" title="5">{
                // Check if this patch targets this resource
                if !p.matchesTarget(resource, spec.Target) </span><span class="cov1" title="1">{
                        continue</span>
                }

                // Apply the patch operation directly
                <span class="cov3" title="4">if err := applyPatchOp(resource.Raw.Object, spec.Patch); err != nil </span><span class="cov0" title="0">{
                        if p.verbose </span><span class="cov0" title="0">{
                                p.logger.Warn("Failed to apply patch %s to %s: %v", patchName, resource.GetName(), err)
                        }</span>
                        // Continue with other patches
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov3" title="4">applied = true</span>
        }

        <span class="cov3" title="4">return applied, nil</span>
}

// matchesTarget checks if a resource matches a patch target
func (p *patchProcessor) matchesTarget(resource *Resource, target string) bool <span class="cov6" title="14">{
        if target == "" </span><span class="cov3" title="4">{
                // No target specified, applies to all resources
                return true
        }</span>

        // Parse target format: kind.name or kind/name
        <span class="cov5" title="10">parts := strings.Split(target, ".")
        if len(parts) == 1 </span><span class="cov4" title="5">{
                parts = strings.Split(target, "/")
        }</span>

        <span class="cov5" title="10">if len(parts) == 1 </span><span class="cov3" title="3">{
                // Just kind specified
                return strings.EqualFold(resource.Kind, parts[0])
        }</span>

        <span class="cov5" title="7">if len(parts) == 2 </span><span class="cov5" title="7">{
                // Kind and name specified
                return strings.EqualFold(resource.Kind, parts[0]) &amp;&amp; resource.GetName() == parts[1]
        }</span>

        <span class="cov0" title="0">return false</span>
}

// DebugPatchGraph generates a patch dependency graph for debugging
func (p *patchProcessor) DebugPatchGraph(patches []Patch) string <span class="cov3" title="3">{
        graph := &amp;strings.Builder{}
        graph.WriteString("Patch Dependency Graph:\n")
        graph.WriteString("======================\n\n")

        // Build patch map
        patchMap := make(map[string]*Patch)
        for i := range patches </span><span class="cov5" title="8">{
                patchMap[patches[i].Name] = &amp;patches[i]
        }</span>

        // Sort patch names for consistent output
        <span class="cov3" title="3">var names []string
        for name := range patchMap </span><span class="cov5" title="8">{
                names = append(names, name)
        }</span>
        <span class="cov3" title="3">sort.Strings(names)

        // Print each patch and its relationships
        for _, name := range names </span><span class="cov5" title="8">{
                patch := patchMap[name]
                graph.WriteString(fmt.Sprintf("%s:\n", name))

                if patch.Metadata != nil </span><span class="cov4" title="6">{
                        if patch.Metadata.Enabled != "" </span><span class="cov2" title="2">{
                                graph.WriteString(fmt.Sprintf("  Condition: %s\n", patch.Metadata.Enabled))
                        }</span>

                        <span class="cov4" title="6">if len(patch.Metadata.Requires) &gt; 0 </span><span class="cov4" title="5">{
                                graph.WriteString("  Requires:\n")
                                for _, req := range patch.Metadata.Requires </span><span class="cov4" title="5">{
                                        graph.WriteString(fmt.Sprintf("    -&gt; %s\n", req))
                                }</span>
                        }

                        <span class="cov4" title="6">if len(patch.Metadata.Conflicts) &gt; 0 </span><span class="cov1" title="1">{
                                graph.WriteString("  Conflicts:\n")
                                for _, conf := range patch.Metadata.Conflicts </span><span class="cov1" title="1">{
                                        graph.WriteString(fmt.Sprintf("    x %s\n", conf))
                                }</span>
                        }

                        <span class="cov4" title="6">if patch.Metadata.Description != "" </span><span class="cov3" title="3">{
                                graph.WriteString(fmt.Sprintf("  Description: %s\n", patch.Metadata.Description))
                        }</span>
                } else<span class="cov2" title="2"> {
                        graph.WriteString("  (no metadata)\n")
                }</span>

                <span class="cov5" title="8">graph.WriteString("\n")</span>
        }

        // Check for issues
        <span class="cov3" title="3">issues := p.findPatchIssues(patchMap)
        if len(issues) &gt; 0 </span><span class="cov2" title="2">{
                graph.WriteString("Issues Detected:\n")
                graph.WriteString("===============\n")
                for _, issue := range issues </span><span class="cov3" title="4">{
                        graph.WriteString(fmt.Sprintf("  - %s\n", issue))
                }</span>
        }

        <span class="cov3" title="3">return graph.String()</span>
}

// findPatchIssues detects potential problems in patch configuration
func (p *patchProcessor) findPatchIssues(patchMap map[string]*Patch) []string <span class="cov4" title="6">{
        var issues []string

        for name, patch := range patchMap </span><span class="cov6" title="13">{
                if patch.Metadata == nil </span><span class="cov3" title="3">{
                        continue</span>
                }

                // Check for missing dependencies
                <span class="cov5" title="10">for _, req := range patch.Metadata.Requires </span><span class="cov5" title="7">{
                        if _, ok := patchMap[req]; !ok </span><span class="cov1" title="1">{
                                issues = append(issues, fmt.Sprintf("Patch %s requires non-existent patch %s", name, req))
                        }</span>
                }

                // Check for mutual conflicts
                <span class="cov5" title="10">for _, conf := range patch.Metadata.Conflicts </span><span class="cov2" title="2">{
                        if conflictPatch, ok := patchMap[conf]; ok &amp;&amp; conflictPatch.Metadata != nil </span><span class="cov2" title="2">{
                                // Check if the conflict is mutual
                                mutual := false
                                for _, c := range conflictPatch.Metadata.Conflicts </span><span class="cov0" title="0">{
                                        if c == name </span><span class="cov0" title="0">{
                                                mutual = true
                                                break</span>
                                        }
                                }
                                <span class="cov2" title="2">if !mutual </span><span class="cov2" title="2">{
                                        issues = append(issues, fmt.Sprintf("Patch %s conflicts with %s, but not vice versa", name, conf))
                                }</span>
                        }
                }

                // Check for circular dependencies
                <span class="cov5" title="10">if p.hasCircularDependency(name, patchMap, make(map[string]bool)) </span><span class="cov3" title="3">{
                        issues = append(issues, fmt.Sprintf("Patch %s has circular dependencies", name))
                }</span>
        }

        <span class="cov4" title="6">return issues</span>
}

// hasCircularDependency checks if a patch has circular dependencies
func (p *patchProcessor) hasCircularDependency(name string, patchMap map[string]*Patch, visited map[string]bool) bool <span class="cov7" title="23">{
        if visited[name] </span><span class="cov3" title="3">{
                return true
        }</span>

        <span class="cov7" title="20">visited[name] = true
        defer delete(visited, name)

        patch, ok := patchMap[name]
        if !ok || patch.Metadata == nil </span><span class="cov2" title="2">{
                return false
        }</span>

        <span class="cov7" title="18">for _, req := range patch.Metadata.Requires </span><span class="cov6" title="13">{
                if p.hasCircularDependency(req, patchMap, visited) </span><span class="cov5" title="9">{
                        return true
                }</span>
        }

        <span class="cov5" title="9">return false</span>
}

// SetVerbose enables verbose mode for debugging
func (p *patchProcessor) SetVerbose(verbose bool) <span class="cov0" title="0">{
        p.verbose = verbose
}</span>

// applyPatchOp applies a patch operation to an object
func applyPatchOp(obj map[string]interface{}, op patch.PatchOp) error <span class="cov3" title="4">{
        // Use the parsed path to navigate and apply the patch
        if len(op.ParsedPath) == 0 &amp;&amp; op.Path != "" </span><span class="cov3" title="3">{
                // Parse the path if not already parsed
                parsed, err := parsePath(op.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="3">op.ParsedPath = parsed</span>
        }

        <span class="cov3" title="4">return applyOperation(obj, op.ParsedPath, op.Value, op.Op)</span>
}

// parsePath parses a dot-notation path into PathPart components
func parsePath(path string) ([]patch.PathPart, error) <span class="cov3" title="3">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov3" title="3">parts := strings.Split(path, ".")
        var result []patch.PathPart

        for _, part := range parts </span><span class="cov4" title="6">{
                // Check for array selector
                if idx := strings.Index(part, "["); idx &gt; 0 </span><span class="cov0" title="0">{
                        fieldName := part[:idx]
                        selectorStr := part[idx+1 : len(part)-1]

                        // Try to parse as index
                        if _, err := strconv.Atoi(selectorStr); err == nil </span><span class="cov0" title="0">{
                                result = append(result, patch.PathPart{
                                        Field:      fieldName,
                                        MatchType:  "index",
                                        MatchValue: selectorStr,
                                })
                        }</span> else<span class="cov0" title="0"> {
                                // It's a selector like [name=value]
                                result = append(result, patch.PathPart{
                                        Field:      fieldName,
                                        MatchType:  "key",
                                        MatchValue: selectorStr,
                                })
                        }</span>
                } else<span class="cov4" title="6"> {
                        result = append(result, patch.PathPart{
                                Field: part,
                        })
                }</span>
        }

        <span class="cov3" title="3">return result, nil</span>
}

// applyOperation applies a patch operation at the specified path
func applyOperation(obj map[string]interface{}, path []patch.PathPart, value interface{}, op string) error <span class="cov3" title="4">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                return errors.Errorf("empty path")
        }</span>

        // Navigate to the target location
        <span class="cov3" title="4">current := obj
        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov3" title="4">{
                part := path[i]

                if part.MatchType == "index" </span><span class="cov0" title="0">{
                        // Array access by index
                        arr, ok := current[part.Field].([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return errors.Errorf("field %s is not an array", part.Field)
                        }</span>
                        <span class="cov0" title="0">index, _ := strconv.Atoi(part.MatchValue)
                        if index &gt;= len(arr) </span><span class="cov0" title="0">{
                                return errors.Errorf("index %d out of bounds for field %s", index, part.Field)
                        }</span>
                        <span class="cov0" title="0">if m, ok := arr[index].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                current = m
                        }</span> else<span class="cov0" title="0"> {
                                return errors.Errorf("array element at %s[%d] is not an object", part.Field, index)
                        }</span>
                } else<span class="cov3" title="4"> if part.MatchType == "key" </span><span class="cov0" title="0">{
                        // Selector-based array access
                        arr, ok := current[part.Field].([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return errors.Errorf("field %s is not an array", part.Field)
                        }</span>

                        // Find matching element
                        <span class="cov0" title="0">found := false
                        for _, elem := range arr </span><span class="cov0" title="0">{
                                if m, ok := elem.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if matchesSelector(m, part.MatchValue) </span><span class="cov0" title="0">{
                                                current = m
                                                found = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                return errors.Errorf("no element matching selector %s in field %s", part.MatchValue, part.Field)
                        }</span>
                } else<span class="cov3" title="4"> {
                        // Regular field access
                        if next, ok := current[part.Field].(map[string]interface{}); ok </span><span class="cov3" title="4">{
                                current = next
                        }</span> else<span class="cov0" title="0"> {
                                // Create intermediate objects if needed
                                if current[part.Field] == nil </span><span class="cov0" title="0">{
                                        current[part.Field] = make(map[string]interface{})
                                        current = current[part.Field].(map[string]interface{})
                                }</span> else<span class="cov0" title="0"> {
                                        return errors.Errorf("field %s is not an object", part.Field)
                                }</span>
                        }
                }
        }

        // Apply the operation at the final location
        <span class="cov3" title="4">lastPart := path[len(path)-1]

        switch op </span>{
        case "replace", "":<span class="cov3" title="4">
                current[lastPart.Field] = value</span>
        case "delete":<span class="cov0" title="0">
                delete(current, lastPart.Field)</span>
        case "add":<span class="cov0" title="0">
                if arr, ok := current[lastPart.Field].([]interface{}); ok </span><span class="cov0" title="0">{
                        current[lastPart.Field] = append(arr, value)
                }</span> else<span class="cov0" title="0"> {
                        current[lastPart.Field] = value
                }</span>
        default:<span class="cov0" title="0">
                return errors.Errorf("unsupported operation: %s", op)</span>
        }

        <span class="cov3" title="4">return nil</span>
}

// matchesSelector checks if an object matches a selector string
func matchesSelector(obj map[string]interface{}, selector string) bool <span class="cov0" title="0">{
        // Parse selector like "name=value"
        parts := strings.SplitN(selector, "=", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">key := parts[0]
        expectedValue := parts[1]

        actualValue, ok := obj[key]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%v", actualValue) == expectedValue</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package launcher

import (
        "context"
        "fmt"
        "regexp"
        "sort"
        "strings"

        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/logger"
)

// variableResolver implements the Resolver interface
type variableResolver struct {
        logger   logger.Logger
        maxDepth int

        // Memoization for resolved values
        cache map[string]interface{}

        // Track variables being resolved to detect cycles
        resolving map[string]bool
}

// NewResolver creates a new variable resolver
func NewResolver(log logger.Logger) Resolver <span class="cov7" title="55">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.Default()
        }</span>
        <span class="cov7" title="55">return &amp;variableResolver{
                logger:    log,
                maxDepth:  10,
                cache:     make(map[string]interface{}),
                resolving: make(map[string]bool),
        }</span>
}

// Variable reference pattern: ${var.name} or ${var.nested.path}
var varPattern = regexp.MustCompile(`\$\{([^}]+)\}`)

// Resolve substitutes variable references in parameters
func (r *variableResolver) Resolve(ctx context.Context, base, overrides ParameterMap, opts *LauncherOptions) (ParameterMapWithSource, error) <span class="cov6" title="44">{
        if opts == nil </span><span class="cov4" title="13">{
                opts = DefaultOptions()
        }</span>

        // Set max depth from options
        <span class="cov6" title="44">if opts.MaxDepth &gt; 0 </span><span class="cov6" title="44">{
                r.maxDepth = opts.MaxDepth
        }</span>

        // Clear cache for new resolution
        <span class="cov6" title="44">r.cache = make(map[string]interface{})
        r.resolving = make(map[string]bool)

        r.logger.Debug("Starting variable resolution with max depth %d", r.maxDepth)

        // Merge parameters (overrides take precedence)
        merged := r.mergeParameters(base, overrides)

        // Create result with source tracking
        result := make(ParameterMapWithSource)

        // Resolve each parameter
        for key, value := range merged </span><span class="cov9" title="202">{
                source := r.determineSource(key, base, overrides)

                // Clear resolution tracking for each top-level parameter
                r.resolving = make(map[string]bool)

                resolved, err := r.resolveValue(ctx, key, value, merged, 0)
                if err != nil </span><span class="cov2" title="3">{
                        r.logger.Error("Failed to resolve parameter %s: %v", key, err)
                        return nil, NewVariableError(key, fmt.Sprintf("%v", value), err.Error())
                }</span>

                <span class="cov9" title="199">result[key] = ParameterSource{
                        Value:    resolved,
                        Location: source,
                        File:     r.getSourceFile(source),
                }</span>
        }

        <span class="cov6" title="41">r.logger.Info("Resolved %d parameters", len(result))
        return result, nil</span>
}

// resolveValue recursively resolves a single value
func (r *variableResolver) resolveValue(ctx context.Context, path string, value interface{}, params ParameterMap, depth int) (interface{}, error) <span class="cov9" title="243">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, errors.Wrap(ctx.Err(), "context cancelled during resolution")</span>
        default:<span class="cov9" title="243"></span>
        }

        // Check depth limit
        <span class="cov9" title="243">if depth &gt; r.maxDepth </span><span class="cov1" title="1">{
                return nil, errors.Errorf("maximum substitution depth %d exceeded", r.maxDepth)
        }</span>

        // Check if we're already resolving this variable (cycle detection)
        <span class="cov9" title="242">if r.resolving[path] </span><span class="cov1" title="1">{
                return nil, errors.Errorf("cyclic reference detected for %s", path)
        }</span>

        // Check cache
        <span class="cov9" title="241">if cached, ok := r.cache[path]; ok </span><span class="cov5" title="14">{
                return cached, nil
        }</span>

        // Mark as resolving
        <span class="cov9" title="227">r.resolving[path] = true
        defer func() </span><span class="cov9" title="227">{ delete(r.resolving, path) }</span>()

        // Handle different value types
        <span class="cov9" title="227">switch v := value.(type) </span>{
        case string:<span class="cov8" title="124">
                resolved, err := r.resolveString(ctx, v, params, depth)
                if err != nil </span><span class="cov4" title="10">{
                        return nil, err
                }</span>
                <span class="cov8" title="114">r.cache[path] = resolved
                return resolved, nil</span>

        case map[string]interface{}:<span class="cov3" title="6">
                // Recursively resolve map values
                resolved := make(map[string]interface{})
                for k, val := range v </span><span class="cov4" title="9">{
                        childPath := fmt.Sprintf("%s.%s", path, k)
                        resolvedVal, err := r.resolveValue(ctx, childPath, val, params, depth)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov4" title="9">resolved[k] = resolvedVal</span>
                }
                <span class="cov3" title="6">r.cache[path] = resolved
                return resolved, nil</span>

        case []interface{}:<span class="cov2" title="2">
                // Recursively resolve array values
                resolved := make([]interface{}, len(v))
                for i, val := range v </span><span class="cov3" title="6">{
                        childPath := fmt.Sprintf("%s[%d]", path, i)
                        resolvedVal, err := r.resolveValue(ctx, childPath, val, params, depth)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="6">resolved[i] = resolvedVal</span>
                }
                <span class="cov2" title="2">r.cache[path] = resolved
                return resolved, nil</span>

        default:<span class="cov7" title="95">
                // Primitive values don't need resolution
                r.cache[path] = value
                return value, nil</span>
        }
}

// resolveString resolves variable references in a string
func (r *variableResolver) resolveString(ctx context.Context, s string, params ParameterMap, depth int) (interface{}, error) <span class="cov8" title="124">{
        // Find all variable references
        matches := varPattern.FindAllStringSubmatch(s, -1)
        if len(matches) == 0 </span><span class="cov8" title="100">{
                return s, nil // No variables to resolve
        }</span>

        // If the string is exactly one variable reference, return the resolved value directly
        <span class="cov5" title="24">if len(matches) == 1 &amp;&amp; s == matches[0][0] </span><span class="cov5" title="16">{
                varPath := matches[0][1]
                value := r.lookupVariable(varPath, params)
                if value == nil </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("undefined variable: %s", varPath)
                }</span>

                // Recursively resolve the value
                <span class="cov5" title="16">return r.resolveValue(ctx, varPath, value, params, depth+1)</span>
        }

        // Multiple variables or mixed content - perform string substitution
        <span class="cov4" title="8">result := s
        for _, match := range matches </span><span class="cov4" title="11">{
                fullMatch := match[0] // ${var.name}
                varPath := match[1]   // var.name

                value := r.lookupVariable(varPath, params)
                if value == nil </span><span class="cov1" title="1">{
                        return nil, errors.Errorf("undefined variable: %s", varPath)
                }</span>

                // Recursively resolve the value
                <span class="cov4" title="10">resolved, err := r.resolveValue(ctx, varPath, value, params, depth+1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Convert to string for substitution
                <span class="cov4" title="10">strValue := r.valueToString(resolved)
                result = strings.Replace(result, fullMatch, strValue, 1)</span>
        }

        <span class="cov3" title="7">return result, nil</span>
}

// lookupVariable looks up a variable by path (e.g., "app.name" or "feature.enabled")
func (r *variableResolver) lookupVariable(path string, params ParameterMap) interface{} <span class="cov6" title="33">{
        parts := strings.Split(path, ".")
        current := params

        for i, part := range parts </span><span class="cov6" title="38">{
                // Handle array index notation (e.g., items[0])
                if idx := strings.Index(part, "["); idx &gt; 0 </span><span class="cov2" title="2">{
                        arrayName := part[:idx]
                        indexStr := part[idx+1 : len(part)-1]

                        // Get the array
                        val, ok := current[arrayName]
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // Convert to array
                        <span class="cov2" title="2">arr, ok := val.([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // Parse index
                        <span class="cov2" title="2">var index int
                        if _, err := fmt.Sscanf(indexStr, "%d", &amp;index); err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // Check bounds
                        <span class="cov2" title="2">if index &lt; 0 || index &gt;= len(arr) </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // If this is the last part, return the array element
                        <span class="cov2" title="2">if i == len(parts)-1 </span><span class="cov2" title="2">{
                                return arr[index]
                        }</span>

                        // Otherwise, continue traversing
                        <span class="cov0" title="0">if m, ok := arr[index].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                current = m
                        }</span> else<span class="cov0" title="0"> {
                                return nil
                        }</span>
                } else<span class="cov6" title="36"> {
                        // Regular map lookup
                        val, ok := current[part]
                        if !ok </span><span class="cov2" title="3">{
                                return nil
                        }</span>

                        // If this is the last part, return the value
                        <span class="cov6" title="33">if i == len(parts)-1 </span><span class="cov6" title="28">{
                                return val
                        }</span>

                        // Otherwise, continue traversing
                        <span class="cov3" title="5">if m, ok := val.(map[string]interface{}); ok </span><span class="cov3" title="5">{
                                current = m
                        }</span> else<span class="cov0" title="0"> if m, ok := val.(ParameterMap); ok </span><span class="cov0" title="0">{
                                current = m
                        }</span> else<span class="cov0" title="0"> {
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// valueToString converts a value to string for substitution
func (r *variableResolver) valueToString(value interface{}) string <span class="cov5" title="15">{
        switch v := value.(type) </span>{
        case string:<span class="cov4" title="8">
                return v</span>
        case bool:<span class="cov2" title="3">
                return fmt.Sprintf("%t", v)</span>
        case int, int32, int64, float32, float64:<span class="cov3" title="4">
                return fmt.Sprintf("%v", v)</span>
        default:<span class="cov0" title="0">
                // For complex types, use JSON-like representation
                return fmt.Sprintf("%v", v)</span>
        }
}

// mergeParameters merges base and override parameters
func (r *variableResolver) mergeParameters(base, overrides ParameterMap) ParameterMap <span class="cov6" title="44">{
        result := make(ParameterMap)

        // Copy base parameters
        for k, v := range base </span><span class="cov9" title="209">{
                result[k] = r.deepCopyValue(v)
        }</span>

        // Apply overrides
        <span class="cov6" title="44">for k, v := range overrides </span><span class="cov3" title="7">{
                result[k] = r.deepCopyValue(v)
        }</span>

        <span class="cov6" title="44">return result</span>
}

// deepCopyValue creates a deep copy of a value
func (r *variableResolver) deepCopyValue(value interface{}) interface{} <span class="cov10" title="364">{
        switch v := value.(type) </span>{
        case map[string]interface{}:<span class="cov4" title="9">
                result := make(map[string]interface{})
                for k, val := range v </span><span class="cov5" title="15">{
                        result[k] = r.deepCopyValue(val)
                }</span>
                <span class="cov4" title="9">return result</span>
        case ParameterMap:<span class="cov7" title="61">
                result := make(ParameterMap)
                for k, val := range v </span><span class="cov8" title="123">{
                        result[k] = r.deepCopyValue(val)
                }</span>
                <span class="cov7" title="61">return result</span>
        case []interface{}:<span class="cov2" title="3">
                result := make([]interface{}, len(v))
                for i, val := range v </span><span class="cov4" title="9">{
                        result[i] = r.deepCopyValue(val)
                }</span>
                <span class="cov2" title="3">return result</span>
        default:<span class="cov9" title="291">
                return v</span>
        }
}

// determineSource determines where a parameter came from
func (r *variableResolver) determineSource(key string, base, overrides ParameterMap) string <span class="cov9" title="202">{
        if _, ok := overrides[key]; ok </span><span class="cov3" title="7">{
                return "local"
        }</span>
        <span class="cov9" title="195">if _, ok := base[key]; ok </span><span class="cov9" title="195">{
                return "package"
        }</span>
        <span class="cov0" title="0">return "default"</span>
}

// getSourceFile returns the file path for a source location
func (r *variableResolver) getSourceFile(source string) string <span class="cov9" title="199">{
        switch source </span>{
        case "package":<span class="cov9" title="192">
                return "parameters.yaml"</span>
        case "local":<span class="cov3" title="7">
                return "parameters.local.yaml"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// DebugVariableGraph generates a dependency graph for debugging
func (r *variableResolver) DebugVariableGraph(params ParameterMap) string <span class="cov3" title="5">{
        graph := &amp;strings.Builder{}
        graph.WriteString("Variable Dependency Graph:\n")
        graph.WriteString("==========================\n\n")

        // Find all variables and their dependencies
        deps := r.findDependencies(params)

        // Sort keys for consistent output
        var keys []string
        for k := range deps </span><span class="cov5" title="24">{
                keys = append(keys, k)
        }</span>
        <span class="cov3" title="5">sort.Strings(keys)

        // Print each variable and its dependencies
        for _, key := range keys </span><span class="cov5" title="24">{
                graph.WriteString(fmt.Sprintf("%s:\n", key))
                if len(deps[key]) == 0 </span><span class="cov5" title="17">{
                        graph.WriteString("  (no dependencies)\n")
                }</span> else<span class="cov3" title="7"> {
                        for _, dep := range deps[key] </span><span class="cov4" title="8">{
                                graph.WriteString(fmt.Sprintf("  -&gt; %s\n", dep))
                        }</span>
                }
        }

        // Check for cycles
        <span class="cov3" title="5">cycles := r.findCycles(deps)
        if len(cycles) &gt; 0 </span><span class="cov1" title="1">{
                graph.WriteString("\nCycles Detected:\n")
                graph.WriteString("================\n")
                for _, cycle := range cycles </span><span class="cov1" title="1">{
                        graph.WriteString(fmt.Sprintf("  %s\n", strings.Join(cycle, " -&gt; ")))
                }</span>
        }

        <span class="cov3" title="5">return graph.String()</span>
}

// findDependencies finds variable dependencies in parameters
func (r *variableResolver) findDependencies(params ParameterMap) map[string][]string <span class="cov3" title="5">{
        deps := make(map[string][]string)

        var findDepsInValue func(path string, value interface{})
        findDepsInValue = func(path string, value interface{}) </span><span class="cov5" title="24">{
                // Initialize the path in deps map even if no dependencies
                if path != "" &amp;&amp; deps[path] == nil </span><span class="cov5" title="24">{
                        deps[path] = []string{}
                }</span>

                <span class="cov5" title="24">switch v := value.(type) </span>{
                case string:<span class="cov5" title="16">
                        // Find variable references
                        matches := varPattern.FindAllStringSubmatch(v, -1)
                        for _, match := range matches </span><span class="cov4" title="8">{
                                varPath := match[1]
                                if path != "" </span><span class="cov4" title="8">{
                                        deps[path] = append(deps[path], varPath)
                                }</span>
                        }
                case map[string]interface{}:<span class="cov1" title="1">
                        for k, val := range v </span><span class="cov2" title="2">{
                                childPath := k
                                if path != "" </span><span class="cov2" title="2">{
                                        childPath = fmt.Sprintf("%s.%s", path, k)
                                }</span>
                                <span class="cov2" title="2">findDepsInValue(childPath, val)</span>
                        }
                case ParameterMap:<span class="cov2" title="2">
                        for k, val := range v </span><span class="cov3" title="4">{
                                childPath := k
                                if path != "" </span><span class="cov3" title="4">{
                                        childPath = fmt.Sprintf("%s.%s", path, k)
                                }</span>
                                <span class="cov3" title="4">findDepsInValue(childPath, val)</span>
                        }
                case []interface{}:<span class="cov0" title="0">
                        for i, val := range v </span><span class="cov0" title="0">{
                                childPath := fmt.Sprintf("%s[%d]", path, i)
                                if path == "" </span><span class="cov0" title="0">{
                                        childPath = fmt.Sprintf("[%d]", i)
                                }</span>
                                <span class="cov0" title="0">findDepsInValue(childPath, val)</span>
                        }
                }
        }

        // Process all parameters at root level
        <span class="cov3" title="5">for k, v := range params </span><span class="cov5" title="18">{
                findDepsInValue(k, v)
        }</span>

        <span class="cov3" title="5">return deps</span>
}

// findCycles detects cycles in the dependency graph
func (r *variableResolver) findCycles(deps map[string][]string) [][]string <span class="cov3" title="5">{
        var cycles [][]string
        visited := make(map[string]bool)
        recStack := make(map[string]bool)
        path := []string{}

        var dfs func(node string) bool
        dfs = func(node string) bool </span><span class="cov5" title="24">{
                visited[node] = true
                recStack[node] = true
                path = append(path, node)

                for _, dep := range deps[node] </span><span class="cov4" title="8">{
                        if !visited[dep] </span><span class="cov2" title="2">{
                                if dfs(dep) </span><span class="cov2" title="2">{
                                        return true
                                }</span>
                        } else<span class="cov3" title="6"> if recStack[dep] </span><span class="cov1" title="1">{
                                // Found a cycle
                                cycleStart := 0
                                for i, n := range path </span><span class="cov1" title="1">{
                                        if n == dep </span><span class="cov1" title="1">{
                                                cycleStart = i
                                                break</span>
                                        }
                                }
                                <span class="cov1" title="1">cycle := append([]string{}, path[cycleStart:]...)
                                cycle = append(cycle, dep) // Complete the cycle
                                cycles = append(cycles, cycle)
                                return true</span>
                        }
                }

                <span class="cov5" title="21">path = path[:len(path)-1]
                recStack[node] = false
                return false</span>
        }

        // Check each node
        <span class="cov3" title="5">for node := range deps </span><span class="cov5" title="24">{
                if !visited[node] </span><span class="cov5" title="22">{
                        dfs(node)
                }</span>
        }

        <span class="cov3" title="5">return cycles</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package launcher

import (
        "context"
        "encoding/json"
        "fmt"
        "reflect"
        "sort"
        "strings"

        "github.com/go-kure/kure/pkg/logger"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemaGenerator generates JSON schemas for package validation
type schemaGenerator struct {
        logger   logger.Logger
        cache    map[string]*JSONSchema // Cache for generated schemas
        traceMap map[string][]string    // Map of type to field paths that reference it
        maxDepth int                    // Maximum recursion depth
        verbose  bool                   // Verbose mode for debugging
}

// JSONSchema represents a JSON schema for validation
type JSONSchema struct {
        Type        string                 `json:"type,omitempty"`
        Description string                 `json:"description,omitempty"`
        Properties  map[string]*JSONSchema `json:"properties,omitempty"`
        Items       *JSONSchema            `json:"items,omitempty"`
        Required    []string               `json:"required,omitempty"`
        Enum        []interface{}          `json:"enum,omitempty"`
        Pattern     string                 `json:"pattern,omitempty"`
        MinLength   *int                   `json:"minLength,omitempty"`
        MaxLength   *int                   `json:"maxLength,omitempty"`
        Minimum     *float64               `json:"minimum,omitempty"`
        Maximum     *float64               `json:"maximum,omitempty"`
        Default     interface{}            `json:"default,omitempty"`
        Examples    []interface{}          `json:"examples,omitempty"`
        Schema      string                 `json:"$schema,omitempty"`
        Ref         string                 `json:"$ref,omitempty"`
        OneOf       []*JSONSchema          `json:"oneOf,omitempty"`
        AnyOf       []*JSONSchema          `json:"anyOf,omitempty"`
        AllOf       []*JSONSchema          `json:"allOf,omitempty"`
        Not         *JSONSchema            `json:"not,omitempty"`

        // Custom fields for Kurel
        KurelType   string `json:"x-kurel-type,omitempty"`   // Original K8s type
        KurelPath   string `json:"x-kurel-path,omitempty"`   // Field path in resource
        KurelSource string `json:"x-kurel-source,omitempty"` // Source of the field (k8s, kurel, custom)
}

// NewSchemaGenerator creates a new schema generator
func NewSchemaGenerator(log logger.Logger) SchemaGenerator <span class="cov5" title="27">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.Default()
        }</span>
        <span class="cov5" title="27">return &amp;schemaGenerator{
                logger:   log,
                cache:    make(map[string]*JSONSchema),
                traceMap: make(map[string][]string),
                maxDepth: 10,
        }</span>
}

// GeneratePackageSchema generates a schema for a package definition
func (g *schemaGenerator) GeneratePackageSchema(ctx context.Context) (*JSONSchema, error) <span class="cov5" title="35">{
        return g.GeneratePackageSchemaWithOptions(ctx, &amp;SchemaOptions{IncludeK8s: false})
}</span>

// GeneratePackageSchemaWithOptions generates a schema for a package definition with options
func (g *schemaGenerator) GeneratePackageSchemaWithOptions(ctx context.Context, opts *SchemaOptions) (*JSONSchema, error) <span class="cov5" title="35">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;SchemaOptions{IncludeK8s: false}
        }</span>

        <span class="cov5" title="35">g.logger.Debug("Generating package schema", "includeK8s", opts.IncludeK8s)

        // Root schema for a Kurel package
        schema := &amp;JSONSchema{
                Schema:      "https://json-schema.org/draft-07/schema#",
                Type:        "object",
                Description: "Kurel package definition",
                Properties: map[string]*JSONSchema{
                        "path": {
                                Type:        "string",
                                Description: "Path to the package",
                        },
                        "metadata":   g.generateMetadataSchema(),
                        "parameters": g.generateParametersSchema(),
                        "resources":  g.generateResourcesSchemaWithOptions(opts.IncludeK8s),
                        "patches":    g.generatePatchesSchema(),
                },
                Required: []string{"metadata"},
        }

        return schema, nil</span>
}

// GenerateResourceSchema generates a schema for a specific resource type
func (g *schemaGenerator) GenerateResourceSchema(ctx context.Context, gvk schema.GroupVersionKind) (*JSONSchema, error) <span class="cov6" title="62">{
        g.logger.Debug("Generating schema for resource %s", gvk.String())

        // Check cache
        cacheKey := gvk.String()
        if cached, ok := g.cache[cacheKey]; ok </span><span class="cov5" title="28">{
                return cached, nil
        }</span>

        // Generate schema based on GVK
        <span class="cov5" title="34">schema := g.generateKubernetesResourceSchema(gvk)

        // Cache the result
        g.cache[cacheKey] = schema

        return schema, nil</span>
}

// GenerateParameterSchema generates a schema for package parameters
func (g *schemaGenerator) GenerateParameterSchema(ctx context.Context, params ParameterMap) (*JSONSchema, error) <span class="cov1" title="1">{
        g.logger.Debug("Generating parameter schema")

        properties := make(map[string]*JSONSchema)
        required := []string{}

        // Analyze parameter structure
        for key, value := range params </span><span class="cov2" title="4">{
                paramSchema := g.inferSchema(value, fmt.Sprintf("$.parameters.%s", key))
                properties[key] = paramSchema

                // Mark as required if it doesn't have a default
                if paramSchema.Default == nil </span><span class="cov0" title="0">{
                        required = append(required, key)
                }</span>
        }

        <span class="cov1" title="1">return &amp;JSONSchema{
                Type:        "object",
                Description: "Package parameters",
                Properties:  properties,
                Required:    required,
        }, nil</span>
}

// TraceFieldUsage traces how fields are used across resources
func (g *schemaGenerator) TraceFieldUsage(resources []Resource) map[string][]string <span class="cov1" title="1">{
        g.logger.Debug("Tracing field usage across %d resources", len(resources))

        usage := make(map[string][]string)

        for _, resource := range resources </span><span class="cov1" title="1">{
                if resource.Raw != nil </span><span class="cov1" title="1">{
                        g.traceObject(resource.Raw.Object, resource.Kind, "", usage)
                }</span>
        }

        <span class="cov1" title="1">return usage</span>
}

// generateMetadataSchema generates schema for package metadata
func (g *schemaGenerator) generateMetadataSchema() *JSONSchema <span class="cov5" title="35">{
        return &amp;JSONSchema{
                Type:        "object",
                Description: "Package metadata",
                Properties: map[string]*JSONSchema{
                        "name": {
                                Type:        "string",
                                Description: "Package name",
                                Pattern:     "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
                                MinLength:   intPtr(1),
                                MaxLength:   intPtr(63),
                        },
                        "version": {
                                Type:        "string",
                                Description: "Package version (semantic versioning)",
                                Pattern:     "^v?\\d+\\.\\d+\\.\\d+(-[a-z0-9]+)?(\\+[a-z0-9]+)?$",
                                Examples:    []interface{}{"1.0.0", "v2.1.0-beta", "3.0.0+build123"},
                        },
                        "appVersion": {
                                Type:        "string",
                                Description: "Application version",
                        },
                        "description": {
                                Type:        "string",
                                Description: "Package description",
                        },
                        "home": {
                                Type:        "string",
                                Description: "Package home URL",
                                Pattern:     "^https?://",
                        },
                        "keywords": {
                                Type:        "array",
                                Description: "Package keywords",
                                Items: &amp;JSONSchema{
                                        Type: "string",
                                },
                        },
                        "schemas": {
                                Type:        "array",
                                Description: "CRD schema URLs",
                                Items: &amp;JSONSchema{
                                        Type:    "string",
                                        Pattern: "^https?://",
                                },
                        },
                        "maintainers": {
                                Type:        "array",
                                Description: "Package maintainers",
                                Items: &amp;JSONSchema{
                                        Type: "object",
                                        Properties: map[string]*JSONSchema{
                                                "name": {
                                                        Type:        "string",
                                                        Description: "Maintainer name",
                                                },
                                                "email": {
                                                        Type:        "string",
                                                        Description: "Maintainer email",
                                                        Pattern:     "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
                                                },
                                        },
                                        Required: []string{"name"},
                                },
                        },
                },
                Required: []string{"name", "version"},
        }
}</span>

// generateParametersSchema generates schema for parameters section
func (g *schemaGenerator) generateParametersSchema() *JSONSchema <span class="cov5" title="35">{
        return &amp;JSONSchema{
                Type:        "object",
                Description: "Package parameters that can be overridden",
                Properties:  map[string]*JSONSchema{},
                // Allow additional properties for flexibility
        }
}</span>

// generateResourcesSchema generates schema for resources section
func (g *schemaGenerator) generateResourcesSchema() *JSONSchema <span class="cov0" title="0">{
        return g.generateResourcesSchemaWithOptions(false)
}</span>

// generateResourcesSchemaWithOptions generates schema for resources section with K8s option
func (g *schemaGenerator) generateResourcesSchemaWithOptions(includeK8s bool) *JSONSchema <span class="cov5" title="35">{
        baseSchema := &amp;JSONSchema{
                Type:        "array",
                Description: "Kubernetes resources defined by this package",
                Items: &amp;JSONSchema{
                        Type:        "object",
                        Description: "Kubernetes resource",
                        Properties: map[string]*JSONSchema{
                                "apiVersion": {
                                        Type:        "string",
                                        Description: "API version of the resource",
                                },
                                "kind": {
                                        Type:        "string",
                                        Description: "Kind of the resource",
                                },
                                "metadata": g.generateK8sMetadataSchema(),
                                "spec": {
                                        Type:        "object",
                                        Description: "Resource specification",
                                },
                                "data": {
                                        Type:        "object",
                                        Description: "Resource data (for ConfigMap/Secret)",
                                },
                        },
                        Required: []string{"apiVersion", "kind"},
                },
        }

        // If K8s schemas are requested, enhance with additional validation
        if includeK8s </span><span class="cov0" title="0">{
                g.logger.Debug("Including Kubernetes resource schemas")
                // Add common Kubernetes resource kinds to the schema
                baseSchema.Items.Properties["apiVersion"] = &amp;JSONSchema{
                        Type:        "string",
                        Description: "API version of the resource",
                        Enum: []interface{}{
                                "v1",
                                "apps/v1",
                                "networking.k8s.io/v1",
                                "batch/v1",
                                "batch/v1beta1",
                                "autoscaling/v1",
                                "autoscaling/v2",
                                "policy/v1",
                                "policy/v1beta1",
                                "rbac.authorization.k8s.io/v1",
                                "extensions/v1beta1",
                        },
                        KurelSource: "k8s",
                }

                baseSchema.Items.Properties["kind"] = &amp;JSONSchema{
                        Type:        "string",
                        Description: "Kind of the resource",
                        Enum: []interface{}{
                                "Pod", "Service", "Deployment", "StatefulSet", "DaemonSet",
                                "ConfigMap", "Secret", "Ingress", "Job", "CronJob",
                                "HorizontalPodAutoscaler", "PodDisruptionBudget",
                                "Role", "RoleBinding", "ClusterRole", "ClusterRoleBinding",
                                "ServiceAccount", "Namespace", "PersistentVolume", "PersistentVolumeClaim",
                        },
                        KurelSource: "k8s",
                }
        }</span>

        <span class="cov5" title="35">return baseSchema</span>
}

// generatePatchesSchema generates schema for patches section
func (g *schemaGenerator) generatePatchesSchema() *JSONSchema <span class="cov5" title="35">{
        return &amp;JSONSchema{
                Type:        "array",
                Description: "Patches to apply to resources",
                Items: &amp;JSONSchema{
                        Type:        "object",
                        Description: "Patch definition",
                        Properties: map[string]*JSONSchema{
                                "name": {
                                        Type:        "string",
                                        Description: "Unique patch name",
                                        Pattern:     "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
                                },
                                "content": {
                                        Type:        "string",
                                        Description: "Patch content in TOML or YAML format",
                                },
                                "metadata": {
                                        Type:        "object",
                                        Description: "Patch metadata",
                                        Properties: map[string]*JSONSchema{
                                                "description": {
                                                        Type:        "string",
                                                        Description: "Human-readable description",
                                                },
                                                "enabled": {
                                                        Type:        "string",
                                                        Description: "Condition for enabling the patch",
                                                        Examples:    []interface{}{"true", "${feature.enabled}", "${env == 'prod'}"},
                                                },
                                                "requires": {
                                                        Type:        "array",
                                                        Description: "Patches this patch depends on",
                                                        Items: &amp;JSONSchema{
                                                                Type: "string",
                                                        },
                                                },
                                                "conflicts": {
                                                        Type:        "array",
                                                        Description: "Patches that conflict with this patch",
                                                        Items: &amp;JSONSchema{
                                                                Type: "string",
                                                        },
                                                },
                                        },
                                },
                        },
                        Required: []string{"name", "content"},
                },
        }
}</span>

// generateKubernetesResourceSchema generates schema for a Kubernetes resource type
func (g *schemaGenerator) generateKubernetesResourceSchema(gvk schema.GroupVersionKind) *JSONSchema <span class="cov5" title="34">{
        // Map common Kubernetes resource types to their schemas
        // This is a simplified version - in production, you'd want to use OpenAPI specs

        baseSchema := &amp;JSONSchema{
                Type:        "object",
                Description: fmt.Sprintf("Kubernetes %s resource", gvk.Kind),
                Properties: map[string]*JSONSchema{
                        "apiVersion": {
                                Type:    "string",
                                Default: gvk.GroupVersion().String(),
                        },
                        "kind": {
                                Type:    "string",
                                Default: gvk.Kind,
                        },
                        "metadata": g.generateK8sMetadataSchema(),
                },
                Required: []string{"apiVersion", "kind", "metadata"},
        }

        // Add spec based on kind
        switch strings.ToLower(gvk.Kind) </span>{
        case "deployment", "statefulset", "daemonset":<span class="cov4" title="13">
                baseSchema.Properties["spec"] = g.generateWorkloadSpecSchema()</span>
        case "service":<span class="cov4" title="12">
                baseSchema.Properties["spec"] = g.generateServiceSpecSchema()</span>
        case "configmap":<span class="cov2" title="4">
                baseSchema.Properties["data"] = &amp;JSONSchema{
                        Type:        "object",
                        Description: "ConfigMap data",
                }</span>
        case "secret":<span class="cov1" title="2">
                baseSchema.Properties["data"] = &amp;JSONSchema{
                        Type:        "object",
                        Description: "Secret data (base64 encoded)",
                }
                baseSchema.Properties["stringData"] = &amp;JSONSchema{
                        Type:        "object",
                        Description: "Secret string data (not base64 encoded)",
                }</span>
        case "ingress":<span class="cov1" title="1">
                baseSchema.Properties["spec"] = g.generateIngressSpecSchema()</span>
        default:<span class="cov1" title="2">
                baseSchema.Properties["spec"] = &amp;JSONSchema{
                        Type:        "object",
                        Description: "Resource specification",
                }</span>
        }

        <span class="cov5" title="34">return baseSchema</span>
}

// generateK8sMetadataSchema generates schema for Kubernetes metadata
func (g *schemaGenerator) generateK8sMetadataSchema() *JSONSchema <span class="cov6" title="69">{
        return &amp;JSONSchema{
                Type:        "object",
                Description: "Kubernetes metadata",
                Properties: map[string]*JSONSchema{
                        "name": {
                                Type:        "string",
                                Description: "Resource name",
                                Pattern:     "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
                                MaxLength:   intPtr(253),
                        },
                        "namespace": {
                                Type:        "string",
                                Description: "Resource namespace",
                                Pattern:     "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
                                MaxLength:   intPtr(63),
                        },
                        "labels": {
                                Type:        "object",
                                Description: "Resource labels",
                        },
                        "annotations": {
                                Type:        "object",
                                Description: "Resource annotations",
                        },
                },
                Required: []string{"name"},
        }
}</span>

// generateWorkloadSpecSchema generates schema for workload specs
func (g *schemaGenerator) generateWorkloadSpecSchema() *JSONSchema <span class="cov4" title="13">{
        return &amp;JSONSchema{
                Type:        "object",
                Description: "Workload specification",
                Properties: map[string]*JSONSchema{
                        "replicas": {
                                Type:        "integer",
                                Description: "Number of replicas",
                                Minimum:     float64Ptr(0),
                                Default:     1,
                        },
                        "selector": {
                                Type:        "object",
                                Description: "Label selector",
                                Properties: map[string]*JSONSchema{
                                        "matchLabels": {
                                                Type:        "object",
                                                Description: "Label key-value pairs to match",
                                        },
                                },
                        },
                        "template": {
                                Type:        "object",
                                Description: "Pod template",
                                Properties: map[string]*JSONSchema{
                                        "metadata": {
                                                Type:        "object",
                                                Description: "Pod metadata",
                                        },
                                        "spec": g.generatePodSpecSchema(),
                                },
                        },
                },
                Required: []string{"selector", "template"},
        }
}</span>

// generatePodSpecSchema generates schema for pod specs
func (g *schemaGenerator) generatePodSpecSchema() *JSONSchema <span class="cov4" title="13">{
        return &amp;JSONSchema{
                Type:        "object",
                Description: "Pod specification",
                Properties: map[string]*JSONSchema{
                        "containers": {
                                Type:        "array",
                                Description: "List of containers",
                                Items:       g.generateContainerSchema(),
                                MinLength:   intPtr(1),
                        },
                        "initContainers": {
                                Type:        "array",
                                Description: "List of init containers",
                                Items:       g.generateContainerSchema(),
                        },
                        "volumes": {
                                Type:        "array",
                                Description: "List of volumes",
                                Items: &amp;JSONSchema{
                                        Type:        "object",
                                        Description: "Volume definition",
                                },
                        },
                },
                Required: []string{"containers"},
        }
}</span>

// generateContainerSchema generates schema for container specs
func (g *schemaGenerator) generateContainerSchema() *JSONSchema <span class="cov5" title="26">{
        return &amp;JSONSchema{
                Type:        "object",
                Description: "Container specification",
                Properties: map[string]*JSONSchema{
                        "name": {
                                Type:        "string",
                                Description: "Container name",
                                Pattern:     "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
                        },
                        "image": {
                                Type:        "string",
                                Description: "Container image",
                        },
                        "command": {
                                Type:        "array",
                                Description: "Container command",
                                Items: &amp;JSONSchema{
                                        Type: "string",
                                },
                        },
                        "args": {
                                Type:        "array",
                                Description: "Container arguments",
                                Items: &amp;JSONSchema{
                                        Type: "string",
                                },
                        },
                        "env": {
                                Type:        "array",
                                Description: "Environment variables",
                                Items: &amp;JSONSchema{
                                        Type:        "object",
                                        Description: "Environment variable",
                                        Properties: map[string]*JSONSchema{
                                                "name": {
                                                        Type:        "string",
                                                        Description: "Variable name",
                                                },
                                                "value": {
                                                        Type:        "string",
                                                        Description: "Variable value",
                                                },
                                        },
                                },
                        },
                        "ports": {
                                Type:        "array",
                                Description: "Container ports",
                                Items: &amp;JSONSchema{
                                        Type:        "object",
                                        Description: "Port definition",
                                        Properties: map[string]*JSONSchema{
                                                "containerPort": {
                                                        Type:        "integer",
                                                        Description: "Port number",
                                                        Minimum:     float64Ptr(1),
                                                        Maximum:     float64Ptr(65535),
                                                },
                                                "protocol": {
                                                        Type:        "string",
                                                        Description: "Protocol",
                                                        Enum:        []interface{}{"TCP", "UDP", "SCTP"},
                                                        Default:     "TCP",
                                                },
                                        },
                                },
                        },
                },
                Required: []string{"name", "image"},
        }
}</span>

// generateServiceSpecSchema generates schema for service specs
func (g *schemaGenerator) generateServiceSpecSchema() *JSONSchema <span class="cov4" title="12">{
        return &amp;JSONSchema{
                Type:        "object",
                Description: "Service specification",
                Properties: map[string]*JSONSchema{
                        "type": {
                                Type:        "string",
                                Description: "Service type",
                                Enum:        []interface{}{"ClusterIP", "NodePort", "LoadBalancer", "ExternalName"},
                                Default:     "ClusterIP",
                        },
                        "selector": {
                                Type:        "object",
                                Description: "Label selector for pods",
                        },
                        "ports": {
                                Type:        "array",
                                Description: "Service ports",
                                Items: &amp;JSONSchema{
                                        Type:        "object",
                                        Description: "Service port",
                                        Properties: map[string]*JSONSchema{
                                                "port": {
                                                        Type:        "integer",
                                                        Description: "Service port",
                                                        Minimum:     float64Ptr(1),
                                                        Maximum:     float64Ptr(65535),
                                                },
                                                "targetPort": {
                                                        Type:        "integer",
                                                        Description: "Target port on pods",
                                                        Minimum:     float64Ptr(1),
                                                        Maximum:     float64Ptr(65535),
                                                },
                                                "protocol": {
                                                        Type:        "string",
                                                        Description: "Protocol",
                                                        Enum:        []interface{}{"TCP", "UDP", "SCTP"},
                                                        Default:     "TCP",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// generateIngressSpecSchema generates schema for ingress specs
func (g *schemaGenerator) generateIngressSpecSchema() *JSONSchema <span class="cov1" title="1">{
        return &amp;JSONSchema{
                Type:        "object",
                Description: "Ingress specification",
                Properties: map[string]*JSONSchema{
                        "rules": {
                                Type:        "array",
                                Description: "Ingress rules",
                                Items: &amp;JSONSchema{
                                        Type:        "object",
                                        Description: "Ingress rule",
                                        Properties: map[string]*JSONSchema{
                                                "host": {
                                                        Type:        "string",
                                                        Description: "Hostname",
                                                },
                                                "http": {
                                                        Type:        "object",
                                                        Description: "HTTP routes",
                                                },
                                        },
                                },
                        },
                        "tls": {
                                Type:        "array",
                                Description: "TLS configuration",
                                Items: &amp;JSONSchema{
                                        Type:        "object",
                                        Description: "TLS configuration",
                                        Properties: map[string]*JSONSchema{
                                                "hosts": {
                                                        Type:        "array",
                                                        Description: "TLS hosts",
                                                        Items: &amp;JSONSchema{
                                                                Type: "string",
                                                        },
                                                },
                                                "secretName": {
                                                        Type:        "string",
                                                        Description: "TLS secret name",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// inferSchema infers a schema from a value
func (g *schemaGenerator) inferSchema(value interface{}, path string) *JSONSchema <span class="cov5" title="22">{
        if value == nil </span><span class="cov1" title="1">{
                return &amp;JSONSchema{
                        Type:        "null",
                        KurelPath:   path,
                        KurelSource: "inferred",
                }
        }</span>

        <span class="cov4" title="21">switch v := value.(type) </span>{
        case bool:<span class="cov1" title="2">
                return &amp;JSONSchema{
                        Type:        "boolean",
                        Default:     v,
                        KurelPath:   path,
                        KurelSource: "inferred",
                }</span>
        case int, int32, int64:<span class="cov3" title="5">
                return &amp;JSONSchema{
                        Type:        "integer",
                        Default:     v,
                        KurelPath:   path,
                        KurelSource: "inferred",
                }</span>
        case float32, float64:<span class="cov1" title="1">
                return &amp;JSONSchema{
                        Type:        "number",
                        Default:     v,
                        KurelPath:   path,
                        KurelSource: "inferred",
                }</span>
        case string:<span class="cov3" title="7">
                schema := &amp;JSONSchema{
                        Type:        "string",
                        Default:     v,
                        KurelPath:   path,
                        KurelSource: "inferred",
                }
                // Check for common patterns
                if strings.Contains(v, "${") </span><span class="cov1" title="1">{
                        schema.Description = "Variable substitution supported"
                        schema.Pattern = ".*\\$\\{[^}]+\\}.*"
                }</span>
                <span class="cov3" title="7">return schema</span>
        case []interface{}:<span class="cov1" title="2">
                var itemSchema *JSONSchema
                if len(v) &gt; 0 </span><span class="cov1" title="2">{
                        itemSchema = g.inferSchema(v[0], fmt.Sprintf("%s[0]", path))
                }</span> else<span class="cov0" title="0"> {
                        itemSchema = &amp;JSONSchema{Type: "any"}
                }</span>
                <span class="cov1" title="2">return &amp;JSONSchema{
                        Type:        "array",
                        Items:       itemSchema,
                        Default:     v,
                        KurelPath:   path,
                        KurelSource: "inferred",
                }</span>
        case map[string]interface{}:<span class="cov2" title="4">
                properties := make(map[string]*JSONSchema)
                for key, val := range v </span><span class="cov3" title="7">{
                        properties[key] = g.inferSchema(val, fmt.Sprintf("%s.%s", path, key))
                }</span>
                <span class="cov2" title="4">return &amp;JSONSchema{
                        Type:        "object",
                        Properties:  properties,
                        Default:     v,
                        KurelPath:   path,
                        KurelSource: "inferred",
                }</span>
        default:<span class="cov0" title="0">
                return &amp;JSONSchema{
                        Type:        "any",
                        Default:     v,
                        KurelPath:   path,
                        KurelSource: "inferred",
                }</span>
        }
}

// traceObject traces field usage in an object
func (g *schemaGenerator) traceObject(obj map[string]interface{}, kind, path string, usage map[string][]string) <span class="cov3" title="7">{
        for key, value := range obj </span><span class="cov4" title="14">{
                fieldPath := key
                if path != "" </span><span class="cov3" title="10">{
                        fieldPath = fmt.Sprintf("%s.%s", path, key)
                }</span>

                // Record usage
                <span class="cov4" title="14">fullPath := fmt.Sprintf("%s:%s", kind, fieldPath)

                // Check if this field references a type
                if str, ok := value.(string); ok &amp;&amp; strings.Contains(str, "${") </span><span class="cov2" title="3">{
                        // Extract variable references
                        vars := extractVariables(str)
                        for _, v := range vars </span><span class="cov2" title="3">{
                                usage[v] = append(usage[v], fullPath)
                        }</span>
                }

                // Recurse into nested objects
                <span class="cov4" title="14">switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov2" title="4">
                        g.traceObject(v, kind, fieldPath, usage)</span>
                case []interface{}:<span class="cov1" title="2">
                        for i, item := range v </span><span class="cov1" title="2">{
                                if m, ok := item.(map[string]interface{}); ok </span><span class="cov1" title="2">{
                                        g.traceObject(m, kind, fmt.Sprintf("%s[%d]", fieldPath, i), usage)
                                }</span>
                        }
                }
        }
}

// extractVariables extracts variable references from a string
func extractVariables(str string) []string <span class="cov2" title="3">{
        var vars []string
        start := 0
        for </span><span class="cov3" title="6">{
                idx := strings.Index(str[start:], "${")
                if idx == -1 </span><span class="cov2" title="3">{
                        break</span>
                }
                <span class="cov2" title="3">start += idx
                end := strings.Index(str[start:], "}")
                if end == -1 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov2" title="3">vars = append(vars, str[start+2:start+end])
                start += end + 1</span>
        }
        <span class="cov2" title="3">return vars</span>
}

// ExportSchema exports a schema to JSON
func (g *schemaGenerator) ExportSchema(schema *JSONSchema) ([]byte, error) <span class="cov2" title="4">{
        return json.MarshalIndent(schema, "", "  ")
}</span>

// DebugSchema generates a debug representation of a schema
func (g *schemaGenerator) DebugSchema(schema *JSONSchema) string <span class="cov1" title="1">{
        var b strings.Builder
        g.debugSchemaRecursive(schema, "", &amp;b)
        return b.String()
}</span>

// debugSchemaRecursive recursively builds debug output
func (g *schemaGenerator) debugSchemaRecursive(schema *JSONSchema, indent string, b *strings.Builder) <span class="cov2" title="3">{
        if schema == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Type and description
        <span class="cov2" title="3">b.WriteString(fmt.Sprintf("%sType: %s\n", indent, schema.Type))
        if schema.Description != "" </span><span class="cov2" title="3">{
                b.WriteString(fmt.Sprintf("%sDescription: %s\n", indent, schema.Description))
        }</span>

        // Properties
        <span class="cov2" title="3">if len(schema.Properties) &gt; 0 </span><span class="cov1" title="1">{
                b.WriteString(fmt.Sprintf("%sProperties:\n", indent))
                keys := make([]string, 0, len(schema.Properties))
                for k := range schema.Properties </span><span class="cov1" title="2">{
                        keys = append(keys, k)
                }</span>
                <span class="cov1" title="1">sort.Strings(keys)
                for _, key := range keys </span><span class="cov1" title="2">{
                        b.WriteString(fmt.Sprintf("%s  %s:\n", indent, key))
                        g.debugSchemaRecursive(schema.Properties[key], indent+"    ", b)
                }</span>
        }

        // Array items
        <span class="cov2" title="3">if schema.Items != nil </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf("%sItems:\n", indent))
                g.debugSchemaRecursive(schema.Items, indent+"  ", b)
        }</span>

        // Required fields
        <span class="cov2" title="3">if len(schema.Required) &gt; 0 </span><span class="cov1" title="1">{
                b.WriteString(fmt.Sprintf("%sRequired: %v\n", indent, schema.Required))
        }</span>

        // Constraints
        <span class="cov2" title="3">if schema.Pattern != "" </span><span class="cov1" title="1">{
                b.WriteString(fmt.Sprintf("%sPattern: %s\n", indent, schema.Pattern))
        }</span>
        <span class="cov2" title="3">if schema.MinLength != nil </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf("%sMinLength: %d\n", indent, *schema.MinLength))
        }</span>
        <span class="cov2" title="3">if schema.MaxLength != nil </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf("%sMaxLength: %d\n", indent, *schema.MaxLength))
        }</span>
}

// SetVerbose enables verbose mode
func (g *schemaGenerator) SetVerbose(verbose bool) <span class="cov0" title="0">{
        g.verbose = verbose
}</span>

// Helper functions
func intPtr(i int) *int <span class="cov8" title="226">{
        return &amp;i
}</span>

func float64Ptr(f float64) *float64 <span class="cov7" title="123">{
        return &amp;f
}</span>

// ValidateWithSchema validates data against a schema
func ValidateWithSchema(data interface{}, schema *JSONSchema) []ValidationError <span class="cov6" title="78">{
        var errors []ValidationError
        validateRecursive(data, schema, "$", &amp;errors)
        return errors
}</span>

// validateRecursive recursively validates data against schema
func validateRecursive(data interface{}, schema *JSONSchema, path string, errors *[]ValidationError) <span class="cov9" title="975">{
        if schema == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check type
        <span class="cov9" title="975">actualType := getJSONType(data)
        if schema.Type != "" &amp;&amp; schema.Type != "any" </span><span class="cov9" title="975">{
                // Allow integer values for number type (JSON doesn't distinguish)
                if !(schema.Type == "number" &amp;&amp; actualType == "integer") &amp;&amp;
                        !(schema.Type == "integer" &amp;&amp; actualType == "number") &amp;&amp;
                        actualType != schema.Type </span><span class="cov3" title="9">{
                        *errors = append(*errors, ValidationError{
                                Field:   path,
                                Message: fmt.Sprintf("expected type %s but got %s", schema.Type, actualType),
                        })
                        return
                }</span>
        }

        // Validate based on type
        <span class="cov9" title="966">switch schema.Type </span>{
        case "object":<span class="cov8" title="354">
                if obj, ok := data.(map[string]interface{}); ok </span><span class="cov8" title="328">{
                        // Check required fields
                        for _, req := range schema.Required </span><span class="cov8" title="362">{
                                val, exists := obj[req]
                                if !exists </span><span class="cov3" title="10">{
                                        *errors = append(*errors, ValidationError{
                                                Field:   fmt.Sprintf("%s.%s", path, req),
                                                Message: "required field missing",
                                        })
                                }</span> else<span class="cov8" title="352"> if str, isString := val.(string); isString &amp;&amp; str == "" </span><span class="cov2" title="4">{
                                        // For required string fields, empty strings are also invalid
                                        *errors = append(*errors, ValidationError{
                                                Field:   fmt.Sprintf("%s.%s", path, req),
                                                Message: "required field cannot be empty",
                                        })
                                }</span>
                        }

                        // Validate properties
                        <span class="cov8" title="328">for key, value := range obj </span><span class="cov10" title="1022">{
                                if propSchema, exists := schema.Properties[key]; exists </span><span class="cov9" title="818">{
                                        validateRecursive(value, propSchema, fmt.Sprintf("%s.%s", path, key), errors)
                                }</span>
                        }
                }

        case "array":<span class="cov7" title="115">
                if arr, ok := data.([]interface{}); ok </span><span class="cov5" title="45">{
                        // Check length constraints
                        if schema.MinLength != nil &amp;&amp; len(arr) &lt; *schema.MinLength </span><span class="cov1" title="1">{
                                *errors = append(*errors, ValidationError{
                                        Field:   path,
                                        Message: fmt.Sprintf("array length %d is less than minimum %d", len(arr), *schema.MinLength),
                                })
                        }</span>

                        // Validate items
                        <span class="cov5" title="45">if schema.Items != nil </span><span class="cov5" title="45">{
                                for i, item := range arr </span><span class="cov6" title="79">{
                                        validateRecursive(item, schema.Items, fmt.Sprintf("%s[%d]", path, i), errors)
                                }</span>
                        }
                }

        case "string":<span class="cov8" title="459">
                if str, ok := data.(string); ok </span><span class="cov8" title="459">{
                        // Check pattern
                        if schema.Pattern != "" </span>{<span class="cov7" title="209">
                                // Pattern validation would go here
                        }</span>

                        // Check length
                        <span class="cov8" title="459">if schema.MinLength != nil &amp;&amp; len(str) &lt; *schema.MinLength </span><span class="cov1" title="1">{
                                *errors = append(*errors, ValidationError{
                                        Field:   path,
                                        Message: fmt.Sprintf("string length %d is less than minimum %d", len(str), *schema.MinLength),
                                })
                        }</span>
                        <span class="cov8" title="459">if schema.MaxLength != nil &amp;&amp; len(str) &gt; *schema.MaxLength </span><span class="cov1" title="1">{
                                *errors = append(*errors, ValidationError{
                                        Field:   path,
                                        Message: fmt.Sprintf("string length %d exceeds maximum %d", len(str), *schema.MaxLength),
                                })
                        }</span>
                }

        case "integer", "number":<span class="cov5" title="38">
                if num, ok := getNumber(data); ok </span><span class="cov5" title="38">{
                        // Check range
                        if schema.Minimum != nil &amp;&amp; num &lt; *schema.Minimum </span><span class="cov1" title="1">{
                                *errors = append(*errors, ValidationError{
                                        Field:   path,
                                        Message: fmt.Sprintf("value %v is less than minimum %v", num, *schema.Minimum),
                                })
                        }</span>
                        <span class="cov5" title="38">if schema.Maximum != nil &amp;&amp; num &gt; *schema.Maximum </span><span class="cov2" title="3">{
                                *errors = append(*errors, ValidationError{
                                        Field:   path,
                                        Message: fmt.Sprintf("value %v exceeds maximum %v", num, *schema.Maximum),
                                })
                        }</span>
                }
        }

        // Check enum values
        <span class="cov9" title="966">if len(schema.Enum) &gt; 0 </span><span class="cov4" title="11">{
                found := false
                for _, allowed := range schema.Enum </span><span class="cov4" title="18">{
                        if reflect.DeepEqual(data, allowed) </span><span class="cov3" title="9">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov4" title="11">if !found </span><span class="cov1" title="2">{
                        *errors = append(*errors, ValidationError{
                                Field:   path,
                                Message: fmt.Sprintf("value %v is not in allowed values %v", data, schema.Enum),
                        })
                }</span>
        }
}

// getJSONType returns the JSON type of a value
func getJSONType(v interface{}) string <span class="cov9" title="975">{
        if v == nil </span><span class="cov3" title="8">{
                return "null"
        }</span>
        <span class="cov9" title="967">switch val := v.(type) </span>{
        case bool:<span class="cov0" title="0">
                return "boolean"</span>
        case int, int32, int64:<span class="cov5" title="38">
                return "integer"</span>
        case float32, float64:<span class="cov0" title="0">
                return "number"</span>
        case string:<span class="cov8" title="460">
                return "string"</span>
        case []interface{}:<span class="cov5" title="45">
                return "array"</span>
        case []string:<span class="cov6" title="70">
                return "array"</span>
        case map[string]interface{}:<span class="cov8" title="328">
                return "object"</span>
        case ParameterMap:<span class="cov5" title="26">
                return "object"</span>
        default:<span class="cov0" title="0">
                // Use reflection for other types
                rv := reflect.ValueOf(val)
                switch rv.Kind() </span>{
                case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                        return "array"</span>
                case reflect.Map, reflect.Struct:<span class="cov0" title="0">
                        return "object"</span>
                default:<span class="cov0" title="0">
                        return "unknown"</span>
                }
        }
}

// getNumber converts various numeric types to float64
func getNumber(v interface{}) (float64, bool) <span class="cov5" title="38">{
        switch n := v.(type) </span>{
        case int:<span class="cov4" title="13">
                return float64(n), true</span>
        case int32:<span class="cov0" title="0">
                return float64(n), true</span>
        case int64:<span class="cov5" title="25">
                return float64(n), true</span>
        case float32:<span class="cov0" title="0">
                return float64(n), true</span>
        case float64:<span class="cov0" title="0">
                return n, true</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

// MergeSchemas merges multiple schemas into one
func MergeSchemas(schemas ...*JSONSchema) *JSONSchema <span class="cov3" title="5">{
        if len(schemas) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="5">if len(schemas) == 1 </span><span class="cov0" title="0">{
                return schemas[0]
        }</span>

        // Start with first non-nil schema as base
        <span class="cov3" title="5">var result *JSONSchema
        for _, s := range schemas </span><span class="cov3" title="6">{
                if s != nil </span><span class="cov2" title="4">{
                        result = &amp;JSONSchema{
                                Type:       s.Type,
                                Properties: make(map[string]*JSONSchema),
                        }
                        break</span>
                }
        }
        <span class="cov3" title="5">if result == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Merge all schemas
        <span class="cov2" title="4">for _, schema := range schemas </span><span class="cov3" title="8">{
                if schema == nil </span><span class="cov1" title="1">{
                        continue</span>
                }

                // Merge properties
                <span class="cov3" title="7">for key, prop := range schema.Properties </span><span class="cov3" title="7">{
                        if existing, exists := result.Properties[key]; exists </span><span class="cov1" title="1">{
                                // Recursively merge if both are objects
                                if existing.Type == "object" &amp;&amp; prop.Type == "object" </span><span class="cov1" title="1">{
                                        result.Properties[key] = MergeSchemas(existing, prop)
                                }</span> else<span class="cov0" title="0"> {
                                        // Otherwise use the latest
                                        result.Properties[key] = prop
                                }</span>
                        } else<span class="cov3" title="6"> {
                                result.Properties[key] = prop
                        }</span>
                }

                // Merge required fields (union)
                <span class="cov3" title="7">for _, req := range schema.Required </span><span class="cov1" title="2">{
                        found := false
                        for _, existing := range result.Required </span><span class="cov1" title="1">{
                                if existing == req </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov1" title="2">if !found </span><span class="cov1" title="2">{
                                result.Required = append(result.Required, req)
                        }</span>
                }
        }

        <span class="cov2" title="4">return result</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package launcher

import (
        "sync"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// KurelMetadata contains package metadata from the kurel: key in parameters.yaml
type KurelMetadata struct {
        Name        string   `yaml:"name" json:"name"`
        Version     string   `yaml:"version" json:"version"`
        AppVersion  string   `yaml:"appVersion" json:"appVersion"`
        Description string   `yaml:"description,omitempty" json:"description,omitempty"`
        Home        string   `yaml:"home,omitempty" json:"home,omitempty"`
        Keywords    []string `yaml:"keywords,omitempty" json:"keywords,omitempty"`
        Schemas     []string `yaml:"schemas,omitempty" json:"schemas,omitempty"` // CRD schema URLs
        Maintainers []struct {
                Name  string `yaml:"name" json:"name"`
                Email string `yaml:"email,omitempty" json:"email,omitempty"`
        } `yaml:"maintainers,omitempty" json:"maintainers,omitempty"`
}

// ParameterMap holds configuration parameters
type ParameterMap map[string]interface{}

// ParameterSource tracks where a parameter value came from for debugging
type ParameterSource struct {
        Value    interface{} `json:"value"`
        Location string      `json:"location"` // "package", "local", "default"
        File     string      `json:"file"`     // Which file it came from
        Line     int         `json:"line"`     // Line number if applicable
}

// ParameterMapWithSource maps parameter names to their values with source tracking
type ParameterMapWithSource map[string]ParameterSource

// Resource represents a Kubernetes resource with thread-safe access
type Resource struct {
        APIVersion   string                     `yaml:"apiVersion" json:"apiVersion"`
        Kind         string                     `yaml:"kind" json:"kind"`
        Metadata     metav1.ObjectMeta          `yaml:"metadata" json:"metadata"`
        Raw          *unstructured.Unstructured // For patch system compatibility
        TemplateData []byte                     `json:"-"` // Raw template content before variable resolution
        mu           sync.RWMutex               // Protect concurrent access
}

// GetName returns the resource name thread-safely
func (r *Resource) GetName() string <span class="cov10" title="210">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.Metadata.Name
}</span>

// GetNamespace returns the resource namespace thread-safely
func (r *Resource) GetNamespace() string <span class="cov8" title="72">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.Metadata.Namespace
}</span>

// ToUnstructured converts the resource to unstructured format
func (r *Resource) ToUnstructured() (*unstructured.Unstructured, error) <span class="cov2" title="2">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if r.Raw == nil </span><span class="cov1" title="1">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">return r.Raw.DeepCopy(), nil</span>
}

// DeepCopy creates an independent copy of the resource
func (r *Resource) DeepCopy() Resource <span class="cov7" title="53">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        var rawCopy *unstructured.Unstructured
        if r.Raw != nil </span><span class="cov5" title="16">{
                rawCopy = r.Raw.DeepCopy()
        }</span>

        // Deep copy template data
        <span class="cov7" title="53">var templateCopy []byte
        if r.TemplateData != nil </span><span class="cov7" title="40">{
                templateCopy = make([]byte, len(r.TemplateData))
                copy(templateCopy, r.TemplateData)
        }</span>

        <span class="cov7" title="53">return Resource{
                APIVersion:   r.APIVersion,
                Kind:         r.Kind,
                Metadata:     *r.Metadata.DeepCopy(),
                Raw:          rawCopy,
                TemplateData: templateCopy,
        }</span>
}

// Patch represents a patch file with its metadata
type Patch struct {
        Name     string         `json:"name"`
        Path     string         `json:"path"`
        Content  string         `json:"-"` // TOML content
        Metadata *PatchMetadata `json:"metadata,omitempty"`
}

// PatchMetadata contains patch configuration and dependencies
type PatchMetadata struct {
        Enabled     string   `yaml:"enabled,omitempty" json:"enabled,omitempty"` // Variable expression
        Description string   `yaml:"description,omitempty" json:"description,omitempty"`
        Requires    []string `yaml:"requires,omitempty" json:"requires,omitempty"`   // Required patches
        Conflicts   []string `yaml:"conflicts,omitempty" json:"conflicts,omitempty"` // Conflicting patches
}

// PackageDefinition represents an immutable kurel package
type PackageDefinition struct {
        Path       string        `json:"path"`
        Metadata   KurelMetadata `json:"metadata"`
        Parameters ParameterMap  `json:"parameters"`
        Resources  []Resource    `json:"resources"`
        Patches    []Patch       `json:"patches"`
        mu         sync.RWMutex  // Protect concurrent reads
}

// DeepCopy creates an independent copy of the package definition for safe mutation
func (pd *PackageDefinition) DeepCopy() *PackageDefinition <span class="cov6" title="30">{
        pd.mu.RLock()
        defer pd.mu.RUnlock()

        // Deep copy resources
        resources := make([]Resource, len(pd.Resources))
        for i, r := range pd.Resources </span><span class="cov7" title="52">{
                resources[i] = r.DeepCopy()
        }</span>

        // Deep copy patches
        <span class="cov6" title="30">patches := make([]Patch, len(pd.Patches))
        for i, p := range pd.Patches </span><span class="cov7" title="37">{
                patches[i] = Patch{
                        Name:     p.Name,
                        Path:     p.Path,
                        Content:  p.Content,
                        Metadata: deepCopyPatchMetadata(p.Metadata),
                }
        }</span>

        <span class="cov6" title="30">return &amp;PackageDefinition{
                Path:       pd.Path,
                Metadata:   pd.Metadata, // struct copy
                Parameters: deepCopyParameterMap(pd.Parameters),
                Resources:  resources,
                Patches:    patches,
        }</span>
}

// PackageInstance represents a package with user customization
type PackageInstance struct {
        Definition     *PackageDefinition     `json:"definition"`
        UserValues     ParameterMap           `json:"userValues"`
        Resolved       ParameterMapWithSource `json:"resolved"` // Final values with source tracking
        LocalPath      string                 `json:"localPath,omitempty"`
        EnabledPatches []Patch                `json:"enabledPatches,omitempty"` // Patches after dependency resolution
}

// Helper functions for deep copying

func deepCopyParameterMap(m ParameterMap) ParameterMap <span class="cov6" title="31">{
        if m == nil </span><span class="cov3" title="4">{
                return nil
        }</span>

        <span class="cov6" title="27">result := make(ParameterMap)
        for k, v := range m </span><span class="cov9" title="141">{
                result[k] = deepCopyValue(v)
        }</span>
        <span class="cov6" title="27">return result</span>
}

func deepCopyValue(v interface{}) interface{} <span class="cov9" title="152">{
        switch val := v.(type) </span>{
        case map[string]interface{}:<span class="cov4" title="7">
                result := make(map[string]interface{})
                for k, v := range val </span><span class="cov4" title="8">{
                        result[k] = deepCopyValue(v)
                }</span>
                <span class="cov4" title="7">return result</span>
        case []interface{}:<span class="cov1" title="1">
                result := make([]interface{}, len(val))
                for i, v := range val </span><span class="cov2" title="3">{
                        result[i] = deepCopyValue(v)
                }</span>
                <span class="cov1" title="1">return result</span>
        default:<span class="cov9" title="144">
                // Primitive types are already immutable
                return val</span>
        }
}

func deepCopyPatchMetadata(pm *PatchMetadata) *PatchMetadata <span class="cov7" title="37">{
        if pm == nil </span><span class="cov7" title="36">{
                return nil
        }</span>

        <span class="cov1" title="1">requires := make([]string, len(pm.Requires))
        copy(requires, pm.Requires)

        conflicts := make([]string, len(pm.Conflicts))
        copy(conflicts, pm.Conflicts)

        return &amp;PatchMetadata{
                Enabled:     pm.Enabled,
                Description: pm.Description,
                Requires:    requires,
                Conflicts:   conflicts,
        }</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package launcher

import (
        "context"
        "fmt"
        "regexp"
        "strings"

        "github.com/blang/semver/v4"
        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/logger"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// validator implements the Validator interface
type validator struct {
        logger          logger.Logger
        schemaGenerator SchemaGenerator
        strictMode      bool // If true, warnings become errors
        maxErrors       int  // Maximum errors before stopping
        verbose         bool // Verbose mode for debugging
}

// NewValidator creates a new validator
func NewValidator(log logger.Logger) Validator <span class="cov5" title="15">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.Default()
        }</span>
        <span class="cov5" title="15">return &amp;validator{
                logger:          log,
                schemaGenerator: NewSchemaGenerator(log),
                maxErrors:       100,
                strictMode:      false,
        }</span>
}

// ValidatePackage validates an entire package definition
func (v *validator) ValidatePackage(ctx context.Context, def *PackageDefinition) (*ValidationResult, error) <span class="cov6" title="31">{
        if def == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("package definition is nil")
        }</span>

        <span class="cov6" title="31">v.logger.Debug("Validating package %s", def.Metadata.Name)

        result := &amp;ValidationResult{
                Errors:   []ValidationError{},
                Warnings: []ValidationWarning{},
        }

        // Generate package schema
        schema, err := v.schemaGenerator.GeneratePackageSchema(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("failed to generate schema: %w", err)
        }</span>

        // Convert package to unstructured for validation
        <span class="cov6" title="31">pkgData := v.packageToMap(def)

        // Validate against schema
        schemaErrors := ValidateWithSchema(pkgData, schema)
        for _, err := range schemaErrors </span><span class="cov4" title="8">{
                // Schema validation errors are always errors (not warnings)
                err.Severity = "error"
                v.addValidationError(result, err)
        }</span>

        // Perform semantic validation
        <span class="cov6" title="31">v.validateSemantics(ctx, def, result)

        // Validate resources
        v.validateResources(ctx, def.Resources, result)

        // Validate patches
        v.validatePatches(ctx, def.Patches, result)

        // Validate parameters
        v.validateParameters(ctx, def.Parameters, result)

        // Check if we exceeded error limit
        if len(result.Errors) &gt;= v.maxErrors </span><span class="cov1" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Path:    "",
                        Message: fmt.Sprintf("validation stopped after %d errors", v.maxErrors),
                })
        }</span>

        // In strict mode, warnings become errors
        <span class="cov6" title="31">if v.strictMode </span><span class="cov1" title="1">{
                for _, w := range result.Warnings </span><span class="cov1" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Resource: w.Resource,
                                Field:    w.Field,
                                Message:  w.Message,
                        })
                }</span>
                <span class="cov1" title="1">result.Warnings = []ValidationWarning{}</span>
        }

        <span class="cov6" title="31">v.logger.Info("Validation complete: %d errors, %d warnings", len(result.Errors), len(result.Warnings))

        return result, nil</span>
}

// ValidateResource validates a single resource
func (v *validator) ValidateResource(ctx context.Context, resource Resource) (*ValidationResult, error) <span class="cov7" title="64">{
        v.logger.Debug("Validating resource %s/%s", resource.Kind, resource.GetName())

        result := &amp;ValidationResult{
                Errors:   []ValidationError{},
                Warnings: []ValidationWarning{},
        }

        // Basic validation
        if resource.APIVersion == "" </span><span class="cov3" title="4">{
                v.addError(result, "resource", "apiVersion is required")
        }</span>
        <span class="cov7" title="64">if resource.Kind == "" </span><span class="cov3" title="4">{
                v.addError(result, "resource", "kind is required")
        }</span>
        <span class="cov7" title="64">if resource.GetName() == "" </span><span class="cov4" title="9">{
                v.addError(result, "resource.metadata", "name is required")
        }</span>

        // Validate against Kubernetes schema if available
        <span class="cov7" title="64">if resource.APIVersion != "" &amp;&amp; resource.Kind != "" </span><span class="cov7" title="59">{
                gv, err := schema.ParseGroupVersion(resource.APIVersion)
                if err != nil </span><span class="cov0" title="0">{
                        v.addWarning(result, "resource.apiVersion", fmt.Sprintf("invalid apiVersion format: %v", err))
                }</span> else<span class="cov7" title="59"> {
                        gvk := gv.WithKind(resource.Kind)
                        resourceSchema, err := v.schemaGenerator.GenerateResourceSchema(ctx, gvk)
                        if err != nil </span><span class="cov0" title="0">{
                                v.logger.Warn("Could not generate schema for %s: %v", gvk, err)
                        }</span> else<span class="cov7" title="59"> {
                                // Validate against resource schema
                                if resource.Raw != nil </span><span class="cov5" title="25">{
                                        schemaErrors := ValidateWithSchema(resource.Raw.Object, resourceSchema)
                                        for _, err := range schemaErrors </span><span class="cov4" title="13">{
                                                // Schema validation errors are always errors (not warnings)
                                                err.Severity = "error"
                                                v.addValidationError(result, err)
                                        }</span>
                                }
                        }
                }
        }

        // Resource-specific validation
        <span class="cov7" title="64">v.validateResourceSpecific(&amp;resource, result)
        return result, nil</span>
}

// ValidatePatch validates a patch definition
func (v *validator) ValidatePatch(ctx context.Context, patch Patch) (*ValidationResult, error) <span class="cov6" title="41">{
        v.logger.Debug("Validating patch %s", patch.Name)

        result := &amp;ValidationResult{
                Errors:   []ValidationError{},
                Warnings: []ValidationWarning{},
        }

        // Name validation
        if patch.Name == "" </span><span class="cov1" title="1">{
                v.addError(result, "patch", "name is required")
        }</span> else<span class="cov6" title="40"> if !isValidName(patch.Name) </span><span class="cov1" title="1">{
                v.addError(result, "patch.name", fmt.Sprintf("invalid name format: %s", patch.Name))
        }</span>

        // Content validation
        <span class="cov6" title="41">if patch.Content == "" </span><span class="cov1" title="1">{
                v.addError(result, "patch", "content is required")
        }</span> else<span class="cov6" title="40"> {
                // Try to parse patch content
                if err := v.validatePatchContent(patch.Content); err != nil </span><span class="cov0" title="0">{
                        v.addError(result, "patch.content", fmt.Sprintf("invalid patch content: %v", err))
                }</span>
        }

        // Metadata validation
        <span class="cov6" title="41">if patch.Metadata != nil </span><span class="cov3" title="6">{
                // Validate dependencies
                for _, dep := range patch.Metadata.Requires </span><span class="cov3" title="5">{
                        if dep == patch.Name </span><span class="cov1" title="1">{
                                v.addError(result, "patch.metadata.requires", "patch cannot depend on itself")
                        }</span>
                }

                // Validate conflicts
                <span class="cov3" title="6">for _, conflict := range patch.Metadata.Conflicts </span><span class="cov1" title="1">{
                        if conflict == patch.Name </span><span class="cov1" title="1">{
                                v.addWarning(result, "patch.metadata.conflicts", "patch cannot conflict with itself")
                        }</span>
                }

                // Validate enabled condition
                <span class="cov3" title="6">if patch.Metadata.Enabled != "" </span><span class="cov0" title="0">{
                        if err := v.validateCondition(patch.Metadata.Enabled); err != nil </span><span class="cov0" title="0">{
                                v.addWarning(result, "patch.metadata.enabled", fmt.Sprintf("potentially invalid condition: %v", err))
                        }</span>
                }
        }
        <span class="cov6" title="41">return result, nil</span>
}

// validateSemantics performs semantic validation beyond schema
func (v *validator) validateSemantics(ctx context.Context, def *PackageDefinition, result *ValidationResult) <span class="cov6" title="31">{
        // Check for duplicate resource names within same namespace
        resourceMap := make(map[string]bool)
        for i, resource := range def.Resources </span><span class="cov7" title="60">{
                key := fmt.Sprintf("%s/%s/%s", resource.Kind, resource.GetNamespace(), resource.GetName())
                if resourceMap[key] </span><span class="cov3" title="5">{
                        v.addError(result, fmt.Sprintf("resources[%d]", i),
                                fmt.Sprintf("duplicate resource: %s", key))
                }</span>
                <span class="cov7" title="60">resourceMap[key] = true</span>
        }

        // Check for patch name uniqueness (already enforced at load time, but double-check)
        <span class="cov6" title="31">patchMap := make(map[string]bool)
        for i, patch := range def.Patches </span><span class="cov6" title="35">{
                if patchMap[patch.Name] </span><span class="cov0" title="0">{
                        v.addError(result, fmt.Sprintf("patches[%d]", i),
                                fmt.Sprintf("duplicate patch name: %s", patch.Name))
                }</span>
                <span class="cov6" title="35">patchMap[patch.Name] = true</span>
        }

        // Validate patch dependencies exist
        <span class="cov6" title="31">for _, patch := range def.Patches </span><span class="cov6" title="35">{
                if patch.Metadata != nil </span><span class="cov3" title="4">{
                        for _, req := range patch.Metadata.Requires </span><span class="cov3" title="4">{
                                if !patchMap[req] </span><span class="cov1" title="1">{
                                        v.addError(result, fmt.Sprintf("patch[%s].requires", patch.Name),
                                                fmt.Sprintf("dependency '%s' does not exist", req))
                                }</span>
                        }
                        <span class="cov3" title="4">for _, conflict := range patch.Metadata.Conflicts </span><span class="cov0" title="0">{
                                if !patchMap[conflict] </span><span class="cov0" title="0">{
                                        v.addWarning(result, fmt.Sprintf("patch[%s].conflicts", patch.Name),
                                                fmt.Sprintf("conflict '%s' does not exist", conflict))
                                }</span>
                        }
                }
        }

        // Validate semantic version format
        <span class="cov6" title="31">if def.Metadata.Version != "" </span><span class="cov5" title="27">{
                if _, err := semver.Parse(def.Metadata.Version); err != nil </span><span class="cov2" title="3">{
                        v.addError(result, "metadata.version",
                                fmt.Sprintf("invalid semantic version: %s", def.Metadata.Version))
                }</span>
        }

        // Check for circular dependencies in patches
        <span class="cov6" title="31">if cycles := v.findPatchCycles(def.Patches); len(cycles) &gt; 0 </span><span class="cov1" title="1">{
                for _, cycle := range cycles </span><span class="cov1" title="1">{
                        v.addError(result, "patches", fmt.Sprintf("circular dependency: %s", strings.Join(cycle, " -&gt; ")))
                }</span>
        }
}

// validateResources validates all resources in the package
func (v *validator) validateResources(ctx context.Context, resources []Resource, result *ValidationResult) <span class="cov6" title="31">{
        for i, resource := range resources </span><span class="cov7" title="60">{
                resResult, err := v.ValidateResource(ctx, resource)
                if err != nil </span><span class="cov0" title="0">{
                        v.addError(result, fmt.Sprintf("resources[%d]", i), fmt.Sprintf("validation error: %v", err))
                        continue</span>
                }

                // Merge results
                <span class="cov7" title="60">for _, e := range resResult.Errors </span><span class="cov6" title="37">{
                        e.Path = fmt.Sprintf("resources[%d].%s", i, e.Path)
                        result.Errors = append(result.Errors, e)
                }</span>
                <span class="cov7" title="60">for _, w := range resResult.Warnings </span><span class="cov3" title="6">{
                        w.Field = fmt.Sprintf("resources[%d].%s", i, w.Field)
                        result.Warnings = append(result.Warnings, w)
                }</span>

                <span class="cov7" title="60">if !resResult.IsValid() </span>{<span class="cov4" title="9">
                }</span>
        }
}

// validatePatches validates all patches in the package
func (v *validator) validatePatches(ctx context.Context, patches []Patch, result *ValidationResult) <span class="cov6" title="31">{
        for i, patch := range patches </span><span class="cov6" title="35">{
                patchResult, err := v.ValidatePatch(ctx, patch)
                if err != nil </span><span class="cov0" title="0">{
                        v.addError(result, fmt.Sprintf("patches[%d]", i), fmt.Sprintf("validation error: %v", err))
                        continue</span>
                }

                // Merge results
                <span class="cov6" title="35">for _, e := range patchResult.Errors </span><span class="cov0" title="0">{
                        e.Path = fmt.Sprintf("patches[%d].%s", i, e.Path)
                        result.Errors = append(result.Errors, e)
                }</span>
                <span class="cov6" title="35">for _, w := range patchResult.Warnings </span><span class="cov0" title="0">{
                        w.Field = fmt.Sprintf("patches[%d].%s", i, w.Field)
                        result.Warnings = append(result.Warnings, w)
                }</span>

                <span class="cov6" title="35">if !patchResult.IsValid() </span>{<span class="cov0" title="0">
                }</span>
        }
}

// validateParameters validates package parameters
func (v *validator) validateParameters(ctx context.Context, params ParameterMap, result *ValidationResult) <span class="cov6" title="31">{
        // Check for reserved parameter names
        reserved := []string{"kurel", "system", "internal"}
        for key := range params </span><span class="cov8" title="130">{
                for _, r := range reserved </span><span class="cov10" title="390">{
                        if key == r || strings.HasPrefix(key, r+".") </span><span class="cov3" title="4">{
                                v.addWarning(result, fmt.Sprintf("parameters.%s", key),
                                        fmt.Sprintf("parameter name '%s' uses reserved prefix", key))
                        }</span>
                }
        }

        // Check for circular references in parameters
        <span class="cov6" title="31">if cycles := v.findParameterCycles(params); len(cycles) &gt; 0 </span><span class="cov0" title="0">{
                for _, cycle := range cycles </span><span class="cov0" title="0">{
                        v.addError(result, "parameters", fmt.Sprintf("circular reference: %s", strings.Join(cycle, " -&gt; ")))
                }</span>
        }
}

// validateResourceSpecific performs resource-type specific validation
func (v *validator) validateResourceSpecific(resource *Resource, result *ValidationResult) <span class="cov7" title="64">{
        switch strings.ToLower(resource.Kind) </span>{
        case "deployment", "statefulset", "daemonset":<span class="cov6" title="29">
                v.validateWorkload(resource, result)</span>
        case "service":<span class="cov5" title="22">
                v.validateService(resource, result)</span>
        case "configmap", "secret":<span class="cov3" title="6">
                v.validateConfigMapSecret(resource, result)</span>
        case "ingress":<span class="cov1" title="1">
                v.validateIngress(resource, result)</span>
        }
}

// validateWorkload validates workload resources
func (v *validator) validateWorkload(resource *Resource, result *ValidationResult) <span class="cov6" title="29">{
        if resource.Raw == nil </span><span class="cov5" title="20">{
                return
        }</span>

        // Check for required fields
        <span class="cov4" title="9">spec, found, _ := unstructured.NestedMap(resource.Raw.Object, "spec")
        if !found </span><span class="cov1" title="1">{
                v.addError(result, "spec", "spec is required for workload resources")
                return
        }</span>

        // Check selector
        <span class="cov4" title="8">_, found, _ = unstructured.NestedMap(spec, "selector")
        if !found </span><span class="cov3" title="4">{
                v.addError(result, "spec.selector", "selector is required")
        }</span>

        // Check template
        <span class="cov4" title="8">template, found, _ := unstructured.NestedMap(spec, "template")
        if !found </span><span class="cov0" title="0">{
                v.addError(result, "spec.template", "template is required")
                return
        }</span>

        // Check pod spec
        <span class="cov4" title="8">podSpec, found, _ := unstructured.NestedMap(template, "spec")
        if !found </span><span class="cov0" title="0">{
                v.addError(result, "spec.template.spec", "pod spec is required")
                return
        }</span>

        // Check containers
        <span class="cov4" title="8">containers, found, _ := unstructured.NestedSlice(podSpec, "containers")
        if !found || len(containers) == 0 </span><span class="cov3" title="4">{
                v.addError(result, "spec.template.spec.containers", "at least one container is required")
        }</span>

        // Validate each container
        <span class="cov4" title="8">for i, container := range containers </span><span class="cov3" title="4">{
                if c, ok := container.(map[string]interface{}); ok </span><span class="cov3" title="4">{
                        // Check name
                        name, found, _ := unstructured.NestedString(c, "name")
                        if !found || name == "" </span><span class="cov0" title="0">{
                                v.addError(result, fmt.Sprintf("spec.template.spec.containers[%d].name", i), "container name is required")
                        }</span>

                        // Check image
                        <span class="cov3" title="4">image, found, _ := unstructured.NestedString(c, "image")
                        if !found || image == "" </span><span class="cov0" title="0">{
                                v.addError(result, fmt.Sprintf("spec.template.spec.containers[%d].image", i), "container image is required")
                        }</span>
                }
        }
}

// validateService validates service resources
func (v *validator) validateService(resource *Resource, result *ValidationResult) <span class="cov5" title="22">{
        if resource.Raw == nil </span><span class="cov5" title="15">{
                return
        }</span>

        <span class="cov3" title="7">spec, found, _ := unstructured.NestedMap(resource.Raw.Object, "spec")
        if !found </span><span class="cov0" title="0">{
                v.addError(result, "spec", "spec is required for service resources")
                return
        }</span>

        // Check ports
        <span class="cov3" title="7">ports, found, _ := unstructured.NestedSlice(spec, "ports")
        if found </span><span class="cov3" title="7">{
                for i, port := range ports </span><span class="cov4" title="9">{
                        if p, ok := port.(map[string]interface{}); ok </span><span class="cov4" title="9">{
                                // Check port number
                                portNum, found, _ := unstructured.NestedInt64(p, "port")
                                if !found </span><span class="cov0" title="0">{
                                        v.addError(result, fmt.Sprintf("spec.ports[%d].port", i), "port number is required")
                                }</span> else<span class="cov4" title="9"> if portNum &lt; 1 || portNum &gt; 65535 </span><span class="cov1" title="1">{
                                        v.addError(result, fmt.Sprintf("spec.ports[%d].port", i), "port must be between 1 and 65535")
                                }</span>
                        }
                }
        }

        // Check selector for ClusterIP services
        <span class="cov3" title="7">svcType, _, _ := unstructured.NestedString(spec, "type")
        if svcType == "" || svcType == "ClusterIP" || svcType == "NodePort" || svcType == "LoadBalancer" </span><span class="cov3" title="7">{
                selector, found, _ := unstructured.NestedMap(spec, "selector")
                if !found || len(selector) == 0 </span><span class="cov1" title="1">{
                        v.addWarning(result, "spec.selector", "selector is recommended for service")
                }</span>
        }
}

// validateConfigMapSecret validates ConfigMap and Secret resources
func (v *validator) validateConfigMapSecret(resource *Resource, result *ValidationResult) <span class="cov3" title="6">{
        if resource.Raw == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check for either data or binaryData
        <span class="cov3" title="6">_, dataFound, _ := unstructured.NestedMap(resource.Raw.Object, "data")
        _, binaryFound, _ := unstructured.NestedMap(resource.Raw.Object, "binaryData")

        if !dataFound &amp;&amp; !binaryFound </span><span class="cov3" title="4">{
                v.addWarning(result, "", "neither data nor binaryData specified")
        }</span>

        // For Secrets, check stringData
        <span class="cov3" title="6">if strings.ToLower(resource.Kind) == "secret" </span><span class="cov2" title="2">{
                stringData, stringFound, _ := unstructured.NestedMap(resource.Raw.Object, "stringData")
                if !dataFound &amp;&amp; !binaryFound &amp;&amp; !stringFound </span><span class="cov0" title="0">{
                        v.addWarning(result, "", "no data specified in secret")
                }</span>

                // Warn about sensitive data in plain text
                <span class="cov2" title="2">if stringFound &amp;&amp; len(stringData) &gt; 0 </span><span class="cov2" title="2">{
                        v.addWarning(result, "stringData", "stringData is not encrypted and will be base64 encoded")
                }</span>
        }
}

// validateIngress validates Ingress resources
func (v *validator) validateIngress(resource *Resource, result *ValidationResult) <span class="cov1" title="1">{
        if resource.Raw == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">spec, found, _ := unstructured.NestedMap(resource.Raw.Object, "spec")
        if !found </span><span class="cov0" title="0">{
                v.addError(result, "spec", "spec is required for ingress resources")
                return
        }</span>

        // Check rules
        <span class="cov1" title="1">rules, found, _ := unstructured.NestedSlice(spec, "rules")
        if !found || len(rules) == 0 </span><span class="cov0" title="0">{
                v.addWarning(result, "spec.rules", "no ingress rules defined")
        }</span>

        // Validate each rule
        <span class="cov1" title="1">for i, rule := range rules </span><span class="cov1" title="1">{
                if r, ok := rule.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        // Check host
                        host, _, _ := unstructured.NestedString(r, "host")
                        if host != "" &amp;&amp; !isValidHostname(host) </span><span class="cov1" title="1">{
                                v.addError(result, fmt.Sprintf("spec.rules[%d].host", i), fmt.Sprintf("invalid hostname: %s", host))
                        }</span>
                }
        }
}

// validatePatchContent validates the syntax of patch content
func (v *validator) validatePatchContent(content string) error <span class="cov6" title="40">{
        // Try to detect format and validate accordingly
        lines := strings.Split(content, "\n")
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return errors.Errorf("empty patch content")
        }</span>

        // Simple validation for now - just check if it looks like valid TOML or YAML
        <span class="cov6" title="40">hasColon := false
        hasBracket := false

        for _, line := range lines </span><span class="cov8" title="104">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov6" title="30">{
                        continue</span>
                }
                <span class="cov7" title="74">if strings.Contains(line, ":") </span><span class="cov6" title="44">{
                        hasColon = true
                }</span>
                <span class="cov7" title="74">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov6" title="30">{
                        hasBracket = true
                }</span>
        }

        <span class="cov6" title="40">if !hasColon &amp;&amp; !hasBracket </span><span class="cov0" title="0">{
                return errors.Errorf("patch content does not appear to be valid TOML or YAML")
        }</span>

        <span class="cov6" title="40">return nil</span>
}

// validateCondition validates a condition expression
func (v *validator) validateCondition(condition string) error <span class="cov0" title="0">{
        // Check for variable references
        if strings.Contains(condition, "${") </span><span class="cov0" title="0">{
                // Extract variables and check format
                vars := extractVariables(condition)
                for _, varName := range vars </span><span class="cov0" title="0">{
                        if varName == "" </span><span class="cov0" title="0">{
                                return errors.Errorf("empty variable reference")
                        }</span>
                        // Check for valid variable name format
                        <span class="cov0" title="0">if !isValidVariableName(varName) </span><span class="cov0" title="0">{
                                return errors.Errorf("invalid variable name: %s", varName)
                        }</span>
                }
        }

        // Check for simple boolean literals
        <span class="cov0" title="0">if condition == "true" || condition == "false" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// findPatchCycles finds circular dependencies in patches
func (v *validator) findPatchCycles(patches []Patch) [][]string <span class="cov6" title="31">{
        var cycles [][]string

        // Build dependency graph
        deps := make(map[string][]string)
        for _, patch := range patches </span><span class="cov6" title="35">{
                if patch.Metadata != nil &amp;&amp; len(patch.Metadata.Requires) &gt; 0 </span><span class="cov3" title="4">{
                        deps[patch.Name] = patch.Metadata.Requires
                }</span>
        }

        // Find cycles using DFS
        <span class="cov6" title="31">visited := make(map[string]int) // 0: unvisited, 1: visiting, 2: visited
        var path []string

        var dfs func(node string) bool
        dfs = func(node string) bool </span><span class="cov3" title="6">{
                if visited[node] == 1 </span><span class="cov1" title="1">{
                        // Found cycle
                        cycleStart := -1
                        for i, n := range path </span><span class="cov1" title="1">{
                                if n == node </span><span class="cov1" title="1">{
                                        cycleStart = i
                                        break</span>
                                }
                        }
                        <span class="cov1" title="1">if cycleStart &gt;= 0 </span><span class="cov1" title="1">{
                                cycle := append([]string{}, path[cycleStart:]...)
                                cycle = append(cycle, node)
                                cycles = append(cycles, cycle)
                        }</span>
                        <span class="cov1" title="1">return true</span>
                }
                <span class="cov3" title="5">if visited[node] == 2 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov3" title="5">visited[node] = 1
                path = append(path, node)

                for _, dep := range deps[node] </span><span class="cov3" title="4">{
                        if dfs(dep) </span>{<span class="cov1" title="1">
                                // Don't return immediately to find all cycles
                        }</span>
                }

                <span class="cov3" title="5">path = path[:len(path)-1]
                visited[node] = 2
                return false</span>
        }

        <span class="cov6" title="31">for node := range deps </span><span class="cov3" title="4">{
                if visited[node] == 0 </span><span class="cov2" title="2">{
                        dfs(node)
                }</span>
        }

        <span class="cov6" title="31">return cycles</span>
}

// findParameterCycles finds circular references in parameters
func (v *validator) findParameterCycles(params ParameterMap) [][]string <span class="cov6" title="31">{
        var cycles [][]string

        // Build dependency graph from variable references
        deps := make(map[string][]string)
        for key, value := range params </span><span class="cov8" title="130">{
                if str, ok := value.(string); ok &amp;&amp; strings.Contains(str, "${") </span><span class="cov0" title="0">{
                        vars := extractVariables(str)
                        for _, v := range vars </span><span class="cov0" title="0">{
                                // Only track dependencies within parameters
                                if _, exists := params[v]; exists </span><span class="cov0" title="0">{
                                        deps[key] = append(deps[key], v)
                                }</span>
                        }
                }
        }

        // Use same cycle detection as patches
        <span class="cov6" title="31">visited := make(map[string]int)
        var path []string

        var dfs func(node string) bool
        dfs = func(node string) bool </span><span class="cov0" title="0">{
                if visited[node] == 1 </span><span class="cov0" title="0">{
                        // Found cycle
                        cycleStart := -1
                        for i, n := range path </span><span class="cov0" title="0">{
                                if n == node </span><span class="cov0" title="0">{
                                        cycleStart = i
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if cycleStart &gt;= 0 </span><span class="cov0" title="0">{
                                cycle := append([]string{}, path[cycleStart:]...)
                                cycle = append(cycle, node)
                                cycles = append(cycles, cycle)
                        }</span>
                        <span class="cov0" title="0">return true</span>
                }
                <span class="cov0" title="0">if visited[node] == 2 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">visited[node] = 1
                path = append(path, node)

                for _, dep := range deps[node] </span><span class="cov0" title="0">{
                        dfs(dep)
                }</span>

                <span class="cov0" title="0">path = path[:len(path)-1]
                visited[node] = 2
                return false</span>
        }

        <span class="cov6" title="31">for node := range deps </span><span class="cov0" title="0">{
                if visited[node] == 0 </span><span class="cov0" title="0">{
                        dfs(node)
                }</span>
        }

        <span class="cov6" title="31">return cycles</span>
}

// packageToMap converts a PackageDefinition to a map for validation
func (v *validator) packageToMap(def *PackageDefinition) map[string]interface{} <span class="cov6" title="31">{
        metadata := map[string]interface{}{
                "name":        def.Metadata.Name,
                "version":     def.Metadata.Version,
                "appVersion":  def.Metadata.AppVersion,
                "description": def.Metadata.Description,
                "home":        def.Metadata.Home,
        }

        // Only add arrays if they're not nil
        if def.Metadata.Keywords != nil </span><span class="cov0" title="0">{
                metadata["keywords"] = def.Metadata.Keywords
        }</span> else<span class="cov6" title="31"> {
                metadata["keywords"] = []string{}
        }</span>

        <span class="cov6" title="31">if def.Metadata.Schemas != nil </span><span class="cov0" title="0">{
                metadata["schemas"] = def.Metadata.Schemas
        }</span> else<span class="cov6" title="31"> {
                metadata["schemas"] = []string{}
        }</span>

        <span class="cov6" title="31">if def.Metadata.Maintainers != nil </span><span class="cov0" title="0">{
                metadata["maintainers"] = def.Metadata.Maintainers
        }</span>

        <span class="cov6" title="31">result := map[string]interface{}{
                "path":     def.Path,
                "metadata": metadata,
        }

        // Only add parameters if not nil
        if def.Parameters != nil </span><span class="cov5" title="26">{
                result["parameters"] = def.Parameters
        }</span> else<span class="cov3" title="5"> {
                result["parameters"] = make(map[string]interface{})
        }</span>

        // Convert resources
        <span class="cov6" title="31">var resources []interface{}
        for _, r := range def.Resources </span><span class="cov7" title="60">{
                if r.Raw != nil </span><span class="cov5" title="21">{
                        resources = append(resources, r.Raw.Object)
                }</span>
        }
        <span class="cov6" title="31">if len(resources) &gt; 0 </span><span class="cov4" title="10">{
                result["resources"] = resources
        }</span>

        // Convert patches
        <span class="cov6" title="31">var patches []interface{}
        for _, p := range def.Patches </span><span class="cov6" title="35">{
                patchMap := map[string]interface{}{
                        "name":    p.Name,
                        "content": p.Content,
                }
                if p.Metadata != nil </span><span class="cov3" title="4">{
                        patchMap["metadata"] = map[string]interface{}{
                                "description": p.Metadata.Description,
                                "enabled":     p.Metadata.Enabled,
                                "requires":    p.Metadata.Requires,
                                "conflicts":   p.Metadata.Conflicts,
                        }
                }</span>
                <span class="cov6" title="35">patches = append(patches, patchMap)</span>
        }
        <span class="cov6" title="31">if len(patches) &gt; 0 </span><span class="cov5" title="18">{
                result["patches"] = patches
        }</span>

        <span class="cov6" title="31">return result</span>
}

// Helper functions

func (v *validator) addError(result *ValidationResult, path, message string) <span class="cov6" title="42">{
        result.Errors = append(result.Errors, ValidationError{
                Path:    path,
                Message: message,
        })
}</span>

func (v *validator) addWarning(result *ValidationResult, path, message string) <span class="cov4" title="12">{
        result.Warnings = append(result.Warnings, ValidationWarning{
                Field:   path,
                Message: message,
        })
}</span>

func (v *validator) addValidationError(result *ValidationResult, err ValidationError) <span class="cov5" title="21">{
        if v.strictMode || err.Severity == "error" </span><span class="cov5" title="21">{
                result.Errors = append(result.Errors, err)
        }</span> else<span class="cov0" title="0"> {
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Resource: err.Resource,
                        Field:    err.Field,
                        Message:  err.Message,
                })
        }</span>
}

// isValidName checks if a name follows Kubernetes naming conventions
func isValidName(name string) bool <span class="cov6" title="49">{
        if len(name) == 0 || len(name) &gt; 253 </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov6" title="47">pattern := `^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$`
        matched, _ := regexp.MatchString(pattern, name)
        return matched</span>
}

// isValidHostname checks if a hostname is valid
func isValidHostname(host string) bool <span class="cov4" title="10">{
        if len(host) == 0 || len(host) &gt; 253 </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov4" title="8">pattern := `^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?$`
        matched, _ := regexp.MatchString(pattern, host)
        return matched</span>
}

// isValidVariableName checks if a variable name is valid
func isValidVariableName(name string) bool <span class="cov4" title="10">{
        // Variable names can have dots and brackets for nested access
        pattern := `^[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*|\[[0-9]+\])*$`
        matched, _ := regexp.MatchString(pattern, name)
        return matched
}</span>

// SetStrictMode enables or disables strict validation mode
func (v *validator) SetStrictMode(strict bool) <span class="cov2" title="2">{
        v.strictMode = strict
}</span>

// SetMaxErrors sets the maximum number of errors before stopping
func (v *validator) SetMaxErrors(max int) <span class="cov1" title="1">{
        v.maxErrors = max
}</span>

// SetVerbose enables verbose mode
func (v *validator) SetVerbose(verbose bool) <span class="cov0" title="0">{
        v.verbose = verbose
}</span>

// FormatResult formats a validation result for display
func FormatResult(result *ValidationResult) string <span class="cov2" title="2">{
        var b strings.Builder

        if result.IsValid() </span><span class="cov1" title="1">{
                b.WriteString("✓ Package is valid\n")
        }</span> else<span class="cov1" title="1"> {
                b.WriteString("✗ Package validation failed\n")
        }</span>

        <span class="cov2" title="2">if len(result.Errors) &gt; 0 </span><span class="cov1" title="1">{
                b.WriteString(fmt.Sprintf("\nErrors (%d):\n", len(result.Errors)))
                for _, err := range result.Errors </span><span class="cov2" title="2">{
                        path := err.Path
                        if path == "" </span><span class="cov1" title="1">{
                                path = err.Field
                        }</span>
                        <span class="cov2" title="2">if path != "" </span><span class="cov2" title="2">{
                                b.WriteString(fmt.Sprintf("  - %s: %s\n", path, err.Message))
                        }</span> else<span class="cov0" title="0"> {
                                b.WriteString(fmt.Sprintf("  - %s\n", err.Message))
                        }</span>
                        <span class="cov2" title="2">if err.Resource != "" </span><span class="cov1" title="1">{
                                b.WriteString(fmt.Sprintf("    Resource: %s\n", err.Resource))
                        }</span>
                }
        }

        <span class="cov2" title="2">if len(result.Warnings) &gt; 0 </span><span class="cov1" title="1">{
                b.WriteString(fmt.Sprintf("\nWarnings (%d):\n", len(result.Warnings)))
                for _, warn := range result.Warnings </span><span class="cov1" title="1">{
                        if warn.Field != "" </span><span class="cov1" title="1">{
                                b.WriteString(fmt.Sprintf("  - %s: %s\n", warn.Field, warn.Message))
                        }</span> else<span class="cov0" title="0"> {
                                b.WriteString(fmt.Sprintf("  - %s\n", warn.Message))
                        }</span>
                }
        }

        <span class="cov2" title="2">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">// Package logger provides a structured logging interface for the Kure library.
// It supports different log levels (Debug, Info, Warn, Error) and can be
// configured with verbosity settings.
package logger

import (
        "fmt"
        "io"
        "log"
        "os"
)

// Level represents the severity level of a log message
type Level int

const (
        // LevelDebug is for detailed debugging information
        LevelDebug Level = iota
        // LevelInfo is for informational messages
        LevelInfo
        // LevelWarn is for warning messages
        LevelWarn
        // LevelError is for error messages
        LevelError
)

// Logger is the interface for structured logging in Kure
type Logger interface {
        // Debug logs a debug message (only shown in verbose/debug mode)
        Debug(format string, args ...interface{})
        // Info logs an informational message
        Info(format string, args ...interface{})
        // Warn logs a warning message
        Warn(format string, args ...interface{})
        // Error logs an error message
        Error(format string, args ...interface{})
        // WithPrefix returns a new logger with an additional prefix
        WithPrefix(prefix string) Logger
        // SetLevel sets the minimum log level
        SetLevel(level Level)
}

// Options configures a logger instance
type Options struct {
        // Output is where logs are written (default: os.Stderr)
        Output io.Writer
        // Level is the minimum log level (default: LevelInfo)
        Level Level
        // Prefix is the log prefix (default: empty)
        Prefix string
        // ShowTimestamp indicates whether to include timestamps (default: true)
        ShowTimestamp bool
}

// DefaultOptions returns the default logger options
func DefaultOptions() Options <span class="cov4" title="3">{
        return Options{
                Output:        os.Stderr,
                Level:         LevelInfo,
                Prefix:        "",
                ShowTimestamp: true,
        }
}</span>

// defaultLogger is the standard implementation of Logger
type defaultLogger struct {
        logger *log.Logger
        level  Level
        prefix string
}

// New creates a new logger with the given options
func New(opts Options) Logger <span class="cov10" title="21">{
        flags := 0
        if opts.ShowTimestamp </span><span class="cov4" title="3">{
                flags = log.LstdFlags
        }</span>

        <span class="cov10" title="21">prefix := opts.Prefix
        if prefix != "" &amp;&amp; prefix[len(prefix)-1] != ' ' </span><span class="cov4" title="3">{
                prefix += " "
        }</span>

        <span class="cov10" title="21">return &amp;defaultLogger{
                logger: log.New(opts.Output, prefix, flags),
                level:  opts.Level,
                prefix: prefix,
        }</span>
}

// Default creates a logger with default options
func Default() Logger <span class="cov3" title="2">{
        return New(DefaultOptions())
}</span>

// Debug logs a debug message
func (l *defaultLogger) Debug(format string, args ...interface{}) <span class="cov5" title="5">{
        if l.level &lt;= LevelDebug </span><span class="cov4" title="3">{
                l.logger.Printf("[DEBUG] "+format, args...)
        }</span>
}

// Info logs an info message
func (l *defaultLogger) Info(format string, args ...interface{}) <span class="cov7" title="9">{
        if l.level &lt;= LevelInfo </span><span class="cov7" title="8">{
                l.logger.Printf("[INFO] "+format, args...)
        }</span>
}

// Warn logs a warning message
func (l *defaultLogger) Warn(format string, args ...interface{}) <span class="cov4" title="3">{
        if l.level &lt;= LevelWarn </span><span class="cov3" title="2">{
                l.logger.Printf("[WARN] "+format, args...)
        }</span>
}

// Error logs an error message
func (l *defaultLogger) Error(format string, args ...interface{}) <span class="cov3" title="2">{
        if l.level &lt;= LevelError </span><span class="cov3" title="2">{
                l.logger.Printf("[ERROR] "+format, args...)
        }</span>
}

// WithPrefix returns a new logger with an additional prefix
func (l *defaultLogger) WithPrefix(prefix string) Logger <span class="cov3" title="2">{
        newPrefix := l.prefix + prefix
        if newPrefix != "" &amp;&amp; newPrefix[len(newPrefix)-1] != ' ' </span><span class="cov3" title="2">{
                newPrefix += " "
        }</span>

        <span class="cov3" title="2">return &amp;defaultLogger{
                logger: log.New(l.logger.Writer(), newPrefix, l.logger.Flags()),
                level:  l.level,
                prefix: newPrefix,
        }</span>
}

// SetLevel sets the minimum log level
func (l *defaultLogger) SetLevel(level Level) <span class="cov1" title="1">{
        l.level = level
}</span>

// noopLogger is a logger that does nothing (useful for testing)
type noopLogger struct{}

// Noop returns a logger that discards all messages
func Noop() Logger <span class="cov3" title="2">{
        return &amp;noopLogger{}
}</span>

func (l *noopLogger) Debug(format string, args ...interface{}) {<span class="cov1" title="1">}</span>
func (l *noopLogger) Info(format string, args ...interface{})  {<span class="cov1" title="1">}</span>
func (l *noopLogger) Warn(format string, args ...interface{})  {<span class="cov1" title="1">}</span>
func (l *noopLogger) Error(format string, args ...interface{}) {<span class="cov1" title="1">}</span>
func (l *noopLogger) WithPrefix(prefix string) Logger          <span class="cov1" title="1">{ return l }</span>
func (l *noopLogger) SetLevel(level Level)                     {<span class="cov1" title="1">}</span>

// Helper function for formatting byte sizes
func FormatBytes(bytes int64) string <span class="cov7" title="8">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov4" title="3">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov5" title="5">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov6" title="6">{
                div *= unit
                exp++
        }</span>
        <span class="cov5" title="5">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// Helper function to format durations in a human-readable way
func FormatDuration(nanos int64) string <span class="cov5" title="5">{
        if nanos &lt; 1000 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%dns", nanos)
        }</span> else<span class="cov5" title="4"> if nanos &lt; 1000000 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%.2fµs", float64(nanos)/1000)
        }</span> else<span class="cov4" title="3"> if nanos &lt; 1000000000 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%.2fms", float64(nanos)/1000000)
        }</span>
        <span class="cov3" title="2">return fmt.Sprintf("%.2fs", float64(nanos)/1000000000)</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package patch

import (
        "io"
        "os"
        "path/filepath"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// ApplyPatch loads resources and patch instructions from the provided
// file paths and returns the patched resources.
func ApplyPatch(basePath, patchPath string) ([]*unstructured.Unstructured, error) <span class="cov8" title="1">{
        baseFile, err := os.Open(filepath.Clean(basePath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer baseFile.Close()

        patchFile, err := os.Open(filepath.Clean(patchPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer patchFile.Close()

        set, err := LoadPatchableAppSet([]io.Reader{baseFile}, patchFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resources, err := set.Resolve()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var patched []*unstructured.Unstructured
        for _, r := range resources </span><span class="cov8" title="1">{
                if err := r.Apply(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">patched = append(patched, r.Base)</span>
        }
        <span class="cov8" title="1">return patched, nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package patch

import (
        "bufio"
        "fmt"
        "io"
        "log"
        "os"
        "strings"

        "gopkg.in/yaml.v3"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

type RawPatchMap map[string]interface{}

type TargetedPatch struct {
        Target string                 `yaml:"target"`
        Patch  map[string]interface{} `yaml:"patch"`
}

// PatchSpec ties a parsed PatchOp to an optional explicit target.
type PatchSpec struct {
        Target string
        Patch  PatchOp
}

var Debug = os.Getenv("KURE_DEBUG") == "1"

func LoadPatchFile(r io.Reader) ([]PatchSpec, error) <span class="cov5" title="5">{
        return LoadPatchFileWithVariables(r, nil)
}</span>

func LoadPatchFileWithVariables(r io.Reader, varCtx *VariableContext) ([]PatchSpec, error) <span class="cov6" title="6">{
        // Read all content to detect format
        content, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read patch content: %w", err)
        }</span>

        <span class="cov6" title="6">contentStr := string(content)

        // Detect format and delegate to appropriate parser
        if IsTOMLFormat(contentStr) </span><span class="cov1" title="1">{
                return LoadTOMLPatchFile(strings.NewReader(contentStr), varCtx)
        }</span> else<span class="cov5" title="5"> {
                return LoadYAMLPatchFile(strings.NewReader(contentStr), varCtx)
        }</span>
}

func LoadYAMLPatchFile(r io.Reader, varCtx *VariableContext) ([]PatchSpec, error) <span class="cov5" title="5">{
        dec := yaml.NewDecoder(r)

        var firstToken yaml.Node
        if err := dec.Decode(&amp;firstToken); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read patch input: %w", err)
        }</span>
        <span class="cov5" title="5">if firstToken.Kind == yaml.DocumentNode &amp;&amp; len(firstToken.Content) &gt; 0 </span><span class="cov5" title="5">{
                firstToken = *firstToken.Content[0]
        }</span>

        <span class="cov5" title="5">var patches []PatchSpec

        if firstToken.Kind == yaml.MappingNode </span><span class="cov1" title="1">{
                var raw RawPatchMap
                if err := firstToken.Decode(&amp;raw); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid simple patch map: %w", err)
                }</span>
                <span class="cov1" title="1">for k, v := range raw </span><span class="cov1" title="1">{
                        // Apply variable substitution
                        substitutedValue, err := SubstituteVariables(fmt.Sprintf("%v", v), varCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("variable substitution failed for key '%s': %w", k, err)
                        }</span>

                        // Apply type inference to convert strings to appropriate types (int, bool, etc.)
                        <span class="cov1" title="1">if valueStr, ok := substitutedValue.(string); ok </span><span class="cov1" title="1">{
                                substitutedValue = inferValueType(k, valueStr)
                        }</span>

                        <span class="cov1" title="1">op, err := ParsePatchLine(k, substitutedValue)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid patch line '%s': %w", k, err)
                        }</span>
                        <span class="cov1" title="1">patches = append(patches, PatchSpec{Patch: op})</span>
                }
        } else<span class="cov5" title="4"> if firstToken.Kind == yaml.SequenceNode </span><span class="cov5" title="4">{
                var list []TargetedPatch
                if err := firstToken.Decode(&amp;list); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid patch list: %w", err)
                }</span>
                <span class="cov5" title="4">for _, entry := range list </span><span class="cov5" title="4">{
                        for k, v := range entry.Patch </span><span class="cov5" title="5">{
                                // Apply variable substitution
                                substitutedValue, err := SubstituteVariables(fmt.Sprintf("%v", v), varCtx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("variable substitution failed for key '%s': %w", k, err)
                                }</span>

                                // Apply type inference to convert strings to appropriate types (int, bool, etc.)
                                <span class="cov5" title="5">if valueStr, ok := substitutedValue.(string); ok </span><span class="cov5" title="5">{
                                        substitutedValue = inferValueType(k, valueStr)
                                }</span>

                                <span class="cov5" title="5">op, err := ParsePatchLine(k, substitutedValue)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("invalid patch line '%s': %w", k, err)
                                }</span>
                                <span class="cov5" title="5">if err := op.NormalizePath(); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("invalid patch path syntax: %s: %w", op.Path, err)
                                }</span>
                                <span class="cov5" title="5">if Debug </span><span class="cov0" title="0">{
                                        log.Printf("Targeted patch loaded: target=%s op=%s path=%s value=%v", entry.Target, op.Op, op.Path, substitutedValue)
                                }</span>
                                <span class="cov5" title="5">patches = append(patches, PatchSpec{Target: entry.Target, Patch: op})</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("unrecognized patch format")
        }</span>

        <span class="cov5" title="5">return patches, nil</span>
}

func LoadTOMLPatchFile(r io.Reader, varCtx *VariableContext) ([]PatchSpec, error) <span class="cov4" title="3">{
        scanner := bufio.NewScanner(r)
        var patches []PatchSpec
        var currentHeader *TOMLHeader

        lineNum := 0
        for scanner.Scan() </span><span class="cov10" title="19">{
                lineNum++
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov4" title="3">{
                        continue</span>
                }

                // Check for TOML header
                <span class="cov9" title="16">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov5" title="5">{
                        header, err := ParseTOMLHeader(line)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid TOML header at line %d: %w", lineNum, err)
                        }</span>
                        <span class="cov5" title="5">currentHeader = header
                        continue</span>
                }

                // Parse key-value pair
                <span class="cov8" title="11">if currentHeader == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("patch value without header at line %d: %s", lineNum, line)
                }</span>

                // Split key: value
                <span class="cov8" title="11">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid patch line format at line %d: %s", lineNum, line)
                }</span>

                <span class="cov8" title="11">key := strings.TrimSpace(parts[0])
                valueStr := strings.TrimSpace(parts[1])

                // Apply variable substitution to value
                value, err := SubstituteVariables(valueStr, varCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("variable substitution failed at line %d: %w", lineNum, err)
                }</span>

                // Apply type inference to convert strings to appropriate types (int, bool, etc.)
                <span class="cov8" title="11">if valueStr, ok := value.(string); ok </span><span class="cov8" title="11">{
                        value = inferValueType(key, valueStr)
                }</span>

                // Convert TOML header to resource target and field path
                <span class="cov8" title="11">resourceTarget, fieldPath, err := currentHeader.ResolveTOMLPath()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to resolve TOML path for header %s: %w", currentHeader.String(), err)
                }</span>

                // Combine field path with key if we have a field path
                <span class="cov8" title="11">var finalPath string
                if fieldPath != "" </span><span class="cov6" title="6">{
                        finalPath = fieldPath + "." + key
                }</span> else<span class="cov5" title="5"> {
                        finalPath = key
                }</span>

                // Create patch operation
                <span class="cov8" title="11">op, err := ParsePatchLine(finalPath, value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid patch line '%s' at line %d: %w", finalPath, lineNum, err)
                }</span>

                <span class="cov8" title="11">if err := op.NormalizePath(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid patch path syntax: %s: %w", op.Path, err)
                }</span>

                <span class="cov8" title="11">if Debug </span><span class="cov0" title="0">{
                        log.Printf("TOML patch loaded: header=%s target=%s op=%s path=%s value=%v",
                                currentHeader.String(), resourceTarget, op.Op, op.Path, value)
                }</span>

                <span class="cov8" title="11">patches = append(patches, PatchSpec{Target: resourceTarget, Patch: op})</span>
        }

        <span class="cov4" title="3">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading patch file: %w", err)
        }</span>

        <span class="cov4" title="3">return patches, nil</span>
}

func LoadResourcesFromMultiYAML(r io.Reader) ([]*unstructured.Unstructured, error) <span class="cov3" title="2">{
        dec := yaml.NewDecoder(r)
        var resources []*unstructured.Unstructured
        for </span><span class="cov5" title="4">{
                var raw map[string]interface{}
                err := dec.Decode(&amp;raw)
                if err != nil </span><span class="cov3" title="2">{
                        if err == io.EOF </span><span class="cov3" title="2">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to decode resource document: %w", err)</span>
                }
                <span class="cov3" title="2">if len(raw) &gt; 0 </span><span class="cov3" title="2">{
                        u := &amp;unstructured.Unstructured{Object: raw}
                        if Debug </span><span class="cov0" title="0">{
                                log.Printf("Loaded resource: kind=%s name=%s", u.GetKind(), u.GetName())
                        }</span>
                        <span class="cov3" title="2">resources = append(resources, u)</span>
                }
        }
        <span class="cov3" title="2">return resources, nil</span>
}

func LoadPatchableAppSet(resourceReaders []io.Reader, patchReader io.Reader) (*PatchableAppSet, error) <span class="cov3" title="2">{
        var resources []*unstructured.Unstructured
        for _, r := range resourceReaders </span><span class="cov3" title="2">{
                rs, err := LoadResourcesFromMultiYAML(r)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">resources = append(resources, rs...)</span>
        }

        <span class="cov3" title="2">patches, err := LoadPatchFile(patchReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">return NewPatchableAppSet(resources, patches)</span>
}

func resolvePatchTarget(resources []*unstructured.Unstructured, path string) (string, string) <span class="cov1" title="1">{
        pathParts := parsePath(path)
        if len(pathParts) == 0 </span><span class="cov0" title="0">{
                return "", ""
        }</span>
        <span class="cov1" title="1">first := strings.ToLower(pathParts[0])
        for _, r := range resources </span><span class="cov3" title="2">{
                name := strings.ToLower(r.GetName())
                kind := strings.ToLower(r.GetKind())
                if first == name || first == fmt.Sprintf("%s.%s", kind, name) </span><span class="cov0" title="0">{
                        trimmed := strings.Join(pathParts[1:], ".")
                        return r.GetName(), trimmed
                }</span>
        }
        <span class="cov1" title="1">return "", ""</span>
}

func resourceExists(resources []*unstructured.Unstructured, name string) bool <span class="cov5" title="4">{
        for _, r := range resources </span><span class="cov5" title="4">{
                // Check direct name match
                if r.GetName() == name </span><span class="cov5" title="4">{
                        return true
                }</span>
                // Check kind.name format match
                <span class="cov0" title="0">kindName := fmt.Sprintf("%s.%s", strings.ToLower(r.GetKind()), r.GetName())
                if strings.ToLower(name) == kindName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func extractResourceName(resources []*unstructured.Unstructured, target string) string <span class="cov5" title="4">{
        for _, r := range resources </span><span class="cov5" title="4">{
                // Check direct name match
                if r.GetName() == target </span><span class="cov5" title="4">{
                        return target
                }</span>
                // Check kind.name format match
                <span class="cov0" title="0">kindName := fmt.Sprintf("%s.%s", strings.ToLower(r.GetKind()), r.GetName())
                if strings.ToLower(target) == kindName </span><span class="cov0" title="0">{
                        return r.GetName()
                }</span>
        }
        <span class="cov0" title="0">return target</span> // fallback to original target if no match
}

// preserveTargetForDisambiguation returns the target string, preserving kind.name format
// when there are multiple resources with the same name but different kinds
func preserveTargetForDisambiguation(resources []*unstructured.Unstructured, target string) string <span class="cov0" title="0">{
        // If it's already a kind.name format and exists, keep it as-is
        if strings.Contains(target, ".") &amp;&amp; resourceExists(resources, target) </span><span class="cov0" title="0">{
                return target
        }</span>

        // If it's just a name, check if there are multiple resources with this name
        <span class="cov0" title="0">nameCount := 0
        for _, r := range resources </span><span class="cov0" title="0">{
                if r.GetName() == target </span><span class="cov0" title="0">{
                        nameCount++
                }</span>
        }

        // If there's only one resource with this name, we can use the short name
        <span class="cov0" title="0">if nameCount &lt;= 1 </span><span class="cov0" title="0">{
                return target
        }</span>

        // Multiple resources with same name - we need to keep the kind.name format
        // Try to find the original kind.name format that matches this target
        <span class="cov0" title="0">for _, r := range resources </span><span class="cov0" title="0">{
                kindName := fmt.Sprintf("%s.%s", strings.ToLower(r.GetKind()), r.GetName())
                if strings.ToLower(target) == strings.ToLower(r.GetName()) </span><span class="cov0" title="0">{
                        // This could be ambiguous, but we need to keep the original target if possible
                        continue</span>
                }
                <span class="cov0" title="0">if strings.ToLower(target) == kindName </span><span class="cov0" title="0">{
                        return kindName
                }</span>
        }

        <span class="cov0" title="0">return target</span>
}

// smartTarget attempts to match a patch to a resource based on field presence.
func smartTarget(resources []*unstructured.Unstructured, p PatchOp) []string <span class="cov1" title="1">{
        var matches []string
        for _, r := range resources </span><span class="cov3" title="2">{
                if err := p.ValidateAgainst(r); err == nil </span><span class="cov1" title="1">{
                        matches = append(matches, r.GetName())
                }</span>
        }
        <span class="cov1" title="1">return matches</span>
}

// NewPatchableAppSet constructs a PatchableAppSet from already loaded resources
// and parsed patch specifications.
func NewPatchableAppSet(resources []*unstructured.Unstructured, patches []PatchSpec) (*PatchableAppSet, error) <span class="cov4" title="3">{
        var wrapped []struct {
                Target string
                Patch  PatchOp
        }

        for _, spec := range patches </span><span class="cov5" title="4">{
                p := spec.Patch
                if err := p.NormalizePath(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid patch path syntax: %s: %w", p.Path, err)
                }</span>

                <span class="cov5" title="4">var target string
                var trimmed string
                if spec.Target != "" </span><span class="cov5" title="4">{
                        if !resourceExists(resources, spec.Target) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("explicit target not found: %s", spec.Target)
                        }</span>
                        // Extract actual resource name from kind.name format if needed
                        <span class="cov5" title="4">target = extractResourceName(resources, spec.Target)</span>
                } else<span class="cov0" title="0"> {
                        target, trimmed = resolvePatchTarget(resources, p.Path)
                        if target == "" </span><span class="cov0" title="0">{
                                cands := smartTarget(resources, p)
                                if len(cands) == 1 </span><span class="cov0" title="0">{
                                        target = cands[0]
                                }</span>
                        }
                }

                <span class="cov5" title="4">if target == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not determine target resource for patch path: %s", p.Path)
                }</span>

                <span class="cov5" title="4">if trimmed != "" </span><span class="cov0" title="0">{
                        p.Path = trimmed
                }</span>

                <span class="cov5" title="4">if Debug </span><span class="cov0" title="0">{
                        log.Printf("Patch resolved: target=%s op=%s path=%s value=%v", target, p.Op, p.Path, p.Value)
                }</span>
                <span class="cov5" title="4">wrapped = append(wrapped, struct {
                        Target string
                        Patch  PatchOp
                }{Target: target, Patch: p})</span>
        }

        <span class="cov4" title="3">return &amp;PatchableAppSet{
                Resources: resources,
                Patches:   wrapped,
        }, nil</span>
}

// NewPatchableAppSetWithStructure constructs a PatchableAppSet with YAML structure preservation
func NewPatchableAppSetWithStructure(documentSet *YAMLDocumentSet, patches []PatchSpec) (*PatchableAppSet, error) <span class="cov1" title="1">{
        resources := documentSet.GetResources()

        var wrapped []struct {
                Target string
                Patch  PatchOp
        }

        for _, spec := range patches </span><span class="cov1" title="1">{
                p := spec.Patch
                if err := p.NormalizePath(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid patch path syntax: %s: %w", p.Path, err)
                }</span>

                <span class="cov1" title="1">var target string
                var trimmed string
                if spec.Target != "" </span><span class="cov0" title="0">{
                        if !resourceExists(resources, spec.Target) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("explicit target not found: %s", spec.Target)
                        }</span>
                        // Preserve kind.name format when needed for disambiguation
                        <span class="cov0" title="0">target = preserveTargetForDisambiguation(resources, spec.Target)</span>
                } else<span class="cov1" title="1"> {
                        target, trimmed = resolvePatchTarget(resources, p.Path)
                        if target == "" </span><span class="cov1" title="1">{
                                cands := smartTarget(resources, p)
                                if len(cands) == 1 </span><span class="cov1" title="1">{
                                        target = cands[0]
                                }</span>
                        }
                }

                <span class="cov1" title="1">if target == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not determine target resource for patch path: %s", p.Path)
                }</span>

                <span class="cov1" title="1">if trimmed != "" </span><span class="cov0" title="0">{
                        p.Path = trimmed
                }</span>

                <span class="cov1" title="1">if Debug </span><span class="cov0" title="0">{
                        log.Printf("Patch resolved: target=%s op=%s path=%s value=%v", target, p.Op, p.Path, p.Value)
                }</span>
                <span class="cov1" title="1">wrapped = append(wrapped, struct {
                        Target string
                        Patch  PatchOp
                }{Target: target, Patch: p})</span>
        }

        <span class="cov1" title="1">return &amp;PatchableAppSet{
                Resources:   resources,
                DocumentSet: documentSet,
                Patches:     wrapped,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package patch

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

        "github.com/go-kure/kure/pkg/errors"
)

// PatchOp represents a single patch operation to apply to an object.
type PatchOp struct {
        Op         string      `json:"op"`
        Path       string      `json:"path"`
        ParsedPath []PathPart  `json:"patsedpath,omitempty"`
        Selector   string      `json:"selector,omitempty"`
        Value      interface{} `json:"value"`
}

// ResourceWithPatches ties a base object with the patches that should be applied to it.
type ResourceWithPatches struct {
        Name    string
        Base    *unstructured.Unstructured
        Patches []PatchOp
}

// Apply executes all patches on the base object.
func (r *ResourceWithPatches) Apply() error <span class="cov4" title="4">{
        for _, patch := range r.Patches </span><span class="cov4" title="5">{
                if err := applyPatchOp(r.Base.Object, patch); err != nil </span><span class="cov0" title="0">{
                        return errors.NewPatchError(
                                patch.Op,
                                patch.Path,
                                r.Name,
                                "patch application failed",
                                err,
                        )
                }</span>
        }
        <span class="cov4" title="4">return nil</span>
}

func applyPatchOp(obj map[string]interface{}, op PatchOp) error <span class="cov5" title="9">{
        switch op.Op </span>{
        case "replace":<span class="cov5" title="8">
                // Handle array selector patches
                if op.Selector != "" </span><span class="cov3" title="3">{
                        return applyArrayReplace(obj, op)
                }</span>
                <span class="cov4" title="5">convertedValue := convertValueForUnstructured(op.Value)
                if err := unstructured.SetNestedField(obj, convertedValue, parsePath(op.Path)...); err != nil </span><span class="cov0" title="0">{
                        return errors.NewPatchError(op.Op, op.Path, "", "failed to set field", err)
                }</span>
                <span class="cov4" title="5">return nil</span>
        case "delete":<span class="cov1" title="1">
                if op.Selector == "" </span><span class="cov1" title="1">{
                        _, found, err := unstructured.NestedFieldNoCopy(obj, parsePath(op.Path)...)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.NewPatchError(op.Op, op.Path, "", "failed to access field", err)
                        }</span>
                        <span class="cov1" title="1">if !found </span><span class="cov0" title="0">{
                                return errors.NewPatchError(op.Op, op.Path, "", "path not found", nil)
                        }</span>
                        <span class="cov1" title="1">unstructured.RemoveNestedField(obj, parsePath(op.Path)...)
                        return nil</span>
                }
                <span class="cov0" title="0">path := parsePath(op.Path)
                lst, found, err := unstructured.NestedSlice(obj, path...)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewPatchError(op.Op, op.Path, "", "failed to access list", err)
                }</span>
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return errors.NewPatchError(op.Op, op.Path, "", "list not found", nil)
                }</span>
                <span class="cov0" title="0">idx, err := resolveListIndex(lst, op.Selector)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewPatchError(op.Op, op.Path, "", "failed to resolve list index", err)
                }</span>
                <span class="cov0" title="0">if idx &lt; 0 || idx &gt;= len(lst) </span><span class="cov0" title="0">{
                        return errors.NewPatchError(op.Op, op.Path, "", fmt.Sprintf("index %d out of bounds for list of length %d", idx, len(lst)), nil)
                }</span>
                <span class="cov0" title="0">lst = append(lst[:idx], lst[idx+1:]...)
                return unstructured.SetNestedSlice(obj, lst, path...)</span>
        case "append":<span class="cov0" title="0">
                lst, found, err := unstructured.NestedSlice(obj, parsePath(op.Path)...)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewPatchError(op.Op, op.Path, "", "failed to access list", err)
                }</span>
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return errors.NewPatchError(op.Op, op.Path, "", "list not found", nil)
                }</span>
                <span class="cov0" title="0">convertedValue := convertValueForUnstructured(op.Value)
                lst = append(lst, convertedValue)
                if err := unstructured.SetNestedSlice(obj, lst, parsePath(op.Path)...); err != nil </span><span class="cov0" title="0">{
                        return errors.NewPatchError(op.Op, op.Path, "", "failed to update list", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        case "insertBefore", "insertAfter":<span class="cov0" title="0">
                return applyListPatch(obj, op)</span>
        default:<span class="cov0" title="0">
                return errors.NewValidationError("operation", op.Op, "patch", []string{"replace", "delete", "append", "insertBefore", "insertAfter"})</span>
        }
}

func applyListPatch(obj map[string]interface{}, op PatchOp) error <span class="cov0" title="0">{
        path := parsePath(op.Path)
        lst, found, err := unstructured.NestedSlice(obj, path...)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewPatchError(op.Op, op.Path, "", "failed to access list", err)
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return errors.NewPatchError(op.Op, op.Path, "", "list not found", nil)
        }</span>

        <span class="cov0" title="0">idx, err := resolveListIndex(lst, op.Selector)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewPatchError(op.Op, op.Path, "", "failed to resolve list index", err)
        }</span>

        <span class="cov0" title="0">convertedValue := convertValueForUnstructured(op.Value)
        switch op.Op </span>{
        case "insertBefore":<span class="cov0" title="0">
                lst = append(lst[:idx], append([]interface{}{convertedValue}, lst[idx:]...)...)</span>
        case "insertAfter":<span class="cov0" title="0">
                lst = append(lst[:idx+1], append([]interface{}{convertedValue}, lst[idx+1:]...)...)</span>
        }

        <span class="cov0" title="0">if err := unstructured.SetNestedSlice(obj, lst, path...); err != nil </span><span class="cov0" title="0">{
                return errors.NewPatchError(op.Op, op.Path, "", "failed to update list", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func resolveListIndex(list []interface{}, selector string) (int, error) <span class="cov3" title="3">{
        if strings.Contains(selector, "=") </span><span class="cov3" title="3">{
                parts := strings.SplitN(selector, "=", 2)
                key, val := parts[0], parts[1]
                for i, item := range list </span><span class="cov4" title="4">{
                        m, ok := item.(map[string]interface{})
                        if ok &amp;&amp; fmt.Sprintf("%v", m[key]) == val </span><span class="cov3" title="3">{
                                return i, nil
                        }</span>
                }
                <span class="cov0" title="0">return -1, errors.NewPatchError("resolve", "", "", fmt.Sprintf("key-value match '%s=%s' not found in list", key, val), nil)</span>
        }
        <span class="cov0" title="0">i, err := strconv.Atoi(selector)
        if err != nil </span><span class="cov0" title="0">{
                return -1, errors.NewValidationError("selector", selector, "patch", []string{"integer index", "key=value pair"})
        }</span>
        <span class="cov0" title="0">if i &lt; 0 </span><span class="cov0" title="0">{
                i = len(list) + i
        }</span>
        <span class="cov0" title="0">if i &lt; 0 || i &gt; len(list) </span><span class="cov0" title="0">{
                return -1, errors.NewPatchError("resolve", "", "", fmt.Sprintf("index %d out of bounds for list of length %d", i, len(list)), nil)
        }</span>
        <span class="cov0" title="0">return i, nil</span>
}

// applyArrayReplace handles replace operations on array elements using selectors
func applyArrayReplace(obj map[string]interface{}, op PatchOp) error <span class="cov3" title="3">{
        path := parsePath(op.Path)
        lst, found, err := unstructured.NestedSlice(obj, path...)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewPatchError(op.Op, op.Path, "", "failed to access array", err)
        }</span>
        <span class="cov3" title="3">if !found </span><span class="cov0" title="0">{
                return errors.NewPatchError(op.Op, op.Path, "", "array not found", nil)
        }</span>

        <span class="cov3" title="3">idx, err := resolveListIndex(lst, op.Selector)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to resolve array index")
        }</span>

        <span class="cov3" title="3">if idx &lt; 0 || idx &gt;= len(lst) </span><span class="cov0" title="0">{
                return errors.NewPatchError(op.Op, op.Path, "", fmt.Sprintf("array index %d out of bounds for array of length %d", idx, len(lst)), nil)
        }</span>

        // Check if this is a nested field patch (value is a map with remaining path)
        <span class="cov3" title="3">if valueMap, ok := op.Value.(map[string]interface{}); ok &amp;&amp; len(valueMap) == 1 </span><span class="cov3" title="3">{
                // This is a nested patch - get the array item and patch it
                item, ok := lst[idx].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.NewPatchError(op.Op, op.Path, "", fmt.Sprintf("array item at index %d is not an object", idx), nil)
                }</span>

                // Apply the nested patch to the array item
                <span class="cov3" title="3">for remainingPath, newValue := range valueMap </span><span class="cov3" title="3">{
                        // Convert value to appropriate type for unstructured
                        convertedValue := convertValueForUnstructured(newValue)
                        if err := unstructured.SetNestedField(item, convertedValue, parsePath(remainingPath)...); err != nil </span><span class="cov0" title="0">{
                                return errors.NewPatchError(op.Op, op.Path+"."+remainingPath, "", "failed to set nested field", err)
                        }</span>
                }

                // Update the array with the modified item
                <span class="cov3" title="3">lst[idx] = item</span>
        } else<span class="cov0" title="0"> {
                // Direct replacement of the array item
                convertedValue := convertValueForUnstructured(op.Value)
                lst[idx] = convertedValue
        }</span>

        <span class="cov3" title="3">if err := unstructured.SetNestedSlice(obj, lst, path...); err != nil </span><span class="cov0" title="0">{
                return errors.NewPatchError(op.Op, op.Path, "", "failed to update array", err)
        }</span>
        <span class="cov3" title="3">return nil</span>
}

func parsePath(path string) []string <span class="cov7" title="16">{
        clean := strings.Trim(path, ".")
        if clean == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov7" title="16">return strings.Split(clean, ".")</span>
}

// ParsePatchLine converts a YAML patch line of form "path[selector]" into a PatchOp.
func ParsePatchLine(key string, value interface{}) (PatchOp, error) <span class="cov8" title="25">{
        var op PatchOp
        if strings.HasSuffix(key, "[-]") </span><span class="cov1" title="1">{
                op.Op = "append"
                op.Path = strings.TrimSuffix(key, "[-]")
                op.Value = value
                return op, nil
        }</span>

        // handle delete syntax: path[delete] or path[delete=selector]
        <span class="cov8" title="24">delRe := regexp.MustCompile(`^(.*)\[delete(?:=(.*))?]$`)
        if m := delRe.FindStringSubmatch(key); len(m) == 3 </span><span class="cov1" title="1">{
                op.Op = "delete"
                op.Path = m[1]
                op.Selector = m[2]
                op.Value = nil
                return op, nil
        }</span>

        // First check for selectors at the end (existing behavior)
        <span class="cov8" title="23">re := regexp.MustCompile(`(.*)\[(.*?)]$`)
        matches := re.FindStringSubmatch(key)
        if len(matches) == 3 </span><span class="cov3" title="3">{
                path, sel := matches[1], matches[2]
                switch </span>{
                case strings.HasPrefix(sel, "-") &amp;&amp; !isNumeric(strings.TrimPrefix(sel, "-")):<span class="cov0" title="0">
                        // Insert before matching item: [-name=value]
                        op.Op = "insertBefore"
                        op.Selector = strings.TrimPrefix(sel, "-")</span>
                case strings.HasPrefix(sel, "+") &amp;&amp; !isNumeric(strings.TrimPrefix(sel, "+")):<span class="cov1" title="1">
                        // Insert after matching item: [+name=value]
                        op.Op = "insertAfter"
                        op.Selector = strings.TrimPrefix(sel, "+")</span>
                case strings.HasPrefix(sel, "-") &amp;&amp; isNumeric(strings.TrimPrefix(sel, "-")):<span class="cov1" title="1">
                        // Insert before index: [-3] means insert before index 3
                        op.Op = "insertBefore"
                        op.Selector = strings.TrimPrefix(sel, "-")</span>
                case strings.HasPrefix(sel, "+") &amp;&amp; isNumeric(strings.TrimPrefix(sel, "+")):<span class="cov1" title="1">
                        // Insert after index: [+2] means insert after index 2
                        op.Op = "insertAfter"
                        op.Selector = strings.TrimPrefix(sel, "+")</span>
                default:<span class="cov0" title="0">
                        op.Op = "replace"
                        op.Selector = sel</span>
                }
                <span class="cov3" title="3">op.Path = path
                op.Value = value
                return op, nil</span>
        }

        // Check for selectors in the middle of the path
        <span class="cov7" title="20">midSelectorRe := regexp.MustCompile(`^(.+)\[([^\]]+)\]\.(.+)$`)
        midMatches := midSelectorRe.FindStringSubmatch(key)
        if len(midMatches) == 4 </span><span class="cov5" title="9">{
                basePath, sel, remainingPath := midMatches[1], midMatches[2], midMatches[3]
                switch </span>{
                case strings.HasPrefix(sel, "-") &amp;&amp; !isNumeric(strings.TrimPrefix(sel, "-")):<span class="cov0" title="0">
                        // Insert before matching item in mid-path
                        op.Op = "insertBefore"
                        op.Selector = strings.TrimPrefix(sel, "-")</span>
                case strings.HasPrefix(sel, "+") &amp;&amp; !isNumeric(strings.TrimPrefix(sel, "+")):<span class="cov0" title="0">
                        // Insert after matching item in mid-path
                        op.Op = "insertAfter"
                        op.Selector = strings.TrimPrefix(sel, "+")</span>
                case strings.HasPrefix(sel, "-") &amp;&amp; isNumeric(strings.TrimPrefix(sel, "-")):<span class="cov0" title="0">
                        // Insert before index in mid-path
                        op.Op = "insertBefore"
                        op.Selector = strings.TrimPrefix(sel, "-")</span>
                case strings.HasPrefix(sel, "+") &amp;&amp; isNumeric(strings.TrimPrefix(sel, "+")):<span class="cov0" title="0">
                        // Insert after index in mid-path
                        op.Op = "insertAfter"
                        op.Selector = strings.TrimPrefix(sel, "+")</span>
                default:<span class="cov5" title="9">
                        op.Op = "replace"
                        op.Selector = sel</span>
                }
                <span class="cov5" title="9">op.Path = basePath
                // Store the remaining path after the selector as part of the operation
                // We'll need to modify the patch application logic to handle this
                op.Value = map[string]interface{}{remainingPath: value}
                return op, nil</span>
        }

        <span class="cov6" title="11">op.Op = "replace"
        op.Path = key
        op.Value = value
        return op, nil</span>
}

// ValidateAgainst checks that the patch operation is valid for the given object.
func (p *PatchOp) ValidateAgainst(obj *unstructured.Unstructured) error <span class="cov2" title="2">{
        path := parsePath(p.Path)
        switch p.Op </span>{
        case "replace":<span class="cov2" title="2">
                _, found, err := unstructured.NestedFieldNoCopy(obj.Object, path...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">if !found </span><span class="cov1" title="1">{
                        return fmt.Errorf("path not found for replace: %s", p.Path)
                }</span>
        case "delete":<span class="cov0" title="0">
                if p.Selector == "" </span><span class="cov0" title="0">{
                        _, found, err := unstructured.NestedFieldNoCopy(obj.Object, path...)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                return fmt.Errorf("path not found for delete: %s", p.Path)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">lst, found, err := unstructured.NestedSlice(obj.Object, path...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return fmt.Errorf("path not found for list delete: %s", p.Path)
                }</span>
                <span class="cov0" title="0">if _, err := resolveListIndex(lst, p.Selector); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case "insertBefore", "insertAfter", "append":<span class="cov0" title="0">
                _, found, err := unstructured.NestedSlice(obj.Object, path...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return fmt.Errorf("path not found for list op: %s", p.Path)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// PathPart represents one segment of a parsed patch path.
type PathPart struct {
        Field      string
        MatchType  string // "", "index", or "key"
        MatchValue string
}

// NormalizePath parses the Path field and stores the result in ParsedPath.
func (p *PatchOp) NormalizePath() error <span class="cov7" title="21">{
        parsed, err := ParsePatchPath(p.Path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NormalizePath failed for %s: %w", p.Path, err)
        }</span>
        <span class="cov7" title="21">p.ParsedPath = parsed
        return nil</span>
}

// InferPatchOp infers a patch operation based on the path syntax.
func InferPatchOp(path string) string <span class="cov0" title="0">{
        // Check for insertion patterns
        if re := regexp.MustCompile(`\[([+-])[^0-9]`); re.MatchString(path) </span><span class="cov0" title="0">{
                matches := re.FindStringSubmatch(path)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if matches[1] == "+" </span><span class="cov0" title="0">{
                                return "insertafter"
                        }</span> else<span class="cov0" title="0"> if matches[1] == "-" </span><span class="cov0" title="0">{
                                return "insertbefore"
                        }</span>
                }
        }
        // Check for pure index-based insertion
        <span class="cov0" title="0">if re := regexp.MustCompile(`\[([+-])\d+\]`); re.MatchString(path) </span><span class="cov0" title="0">{
                matches := re.FindStringSubmatch(path)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if matches[1] == "+" </span><span class="cov0" title="0">{
                                return "insertafter"
                        }</span> else<span class="cov0" title="0"> if matches[1] == "-" </span><span class="cov0" title="0">{
                                return "insertbefore"
                        }</span>
                }
        }
        <span class="cov0" title="0">if strings.HasSuffix(path, "[-]") </span><span class="cov0" title="0">{
                return "append"
        }</span>
        <span class="cov0" title="0">return "replace"</span>
}

// ParsePatchPath parses a patch path with selectors into structured parts.
func ParsePatchPath(path string) ([]PathPart, error) <span class="cov8" title="23">{
        clean := strings.Trim(path, ".")
        if clean == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty path")
        }</span>

        <span class="cov8" title="23">segments := strings.Split(clean, ".")
        parts := make([]PathPart, 0, len(segments))

        for _, seg := range segments </span><span class="cov10" title="55">{
                if seg == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid empty segment in %q", path)
                }</span>

                <span class="cov10" title="55">var part PathPart
                idx := strings.IndexRune(seg, '[')
                if idx == -1 </span><span class="cov9" title="53">{
                        part.Field = seg
                        parts = append(parts, part)
                        continue</span>
                }
                <span class="cov2" title="2">if !strings.HasSuffix(seg, "]") || idx == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("malformed selector in segment %q", seg)
                }</span>

                <span class="cov2" title="2">part.Field = seg[:idx]
                sel := seg[idx+1 : len(seg)-1]
                if sel == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("empty selector in segment %q", seg)
                }</span>

                <span class="cov2" title="2">if strings.Contains(sel, "=") </span><span class="cov1" title="1">{
                        part.MatchType = "key"
                        part.MatchValue = sel
                }</span> else<span class="cov1" title="1"> {
                        if _, err := strconv.Atoi(sel); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid index %q in segment %q", sel, seg)
                        }</span>
                        <span class="cov1" title="1">part.MatchType = "index"
                        part.MatchValue = sel</span>
                }
                <span class="cov2" title="2">parts = append(parts, part)</span>
        }

        <span class="cov8" title="23">return parts, nil</span>
}

// isNumeric checks if a string represents a valid integer
func isNumeric(s string) bool <span class="cov4" title="5">{
        _, err := strconv.Atoi(s)
        return err == nil
}</span>

// convertValueForUnstructured converts values to types compatible with unstructured.SetNestedField
// The unstructured package expects specific types and doesn't handle raw int types well
func convertValueForUnstructured(value interface{}) interface{} <span class="cov5" title="8">{
        switch v := value.(type) </span>{
        case int:<span class="cov3" title="3">
                return int64(v)</span> // Convert int to int64 for unstructured compatibility
        case int32:<span class="cov0" title="0">
                return int64(v)</span>
        case int64:<span class="cov0" title="0">
                return v</span>
        case float32:<span class="cov0" title="0">
                return float64(v)</span>
        case float64:<span class="cov0" title="0">
                return v</span>
        case bool:<span class="cov0" title="0">
                return v</span>
        case string:<span class="cov4" title="5">
                return v</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Recursively convert map values
                converted := make(map[string]interface{})
                for k, val := range v </span><span class="cov0" title="0">{
                        converted[k] = convertValueForUnstructured(val)
                }</span>
                <span class="cov0" title="0">return converted</span>
        case []interface{}:<span class="cov0" title="0">
                // Recursively convert slice values
                converted := make([]interface{}, len(v))
                for i, val := range v </span><span class="cov0" title="0">{
                        converted[i] = convertValueForUnstructured(val)
                }</span>
                <span class="cov0" title="0">return converted</span>
        default:<span class="cov0" title="0">
                // Return as-is for other types
                return value</span>
        }
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package patch

import (
        "fmt"
        "io"
        "os"
        "strings"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

        "github.com/go-kure/kure/pkg/errors"
)

// PatchableAppSet represents a collection of resources together with the
// patches that should be applied to them.
type PatchableAppSet struct {
        Resources   []*unstructured.Unstructured
        DocumentSet *YAMLDocumentSet // Preserves original YAML structure
        Patches     []struct {
                Target string
                Patch  PatchOp
        }
}

// Resolve groups patches by their target resource and returns them as
// ResourceWithPatches objects.
func (s *PatchableAppSet) Resolve() ([]*ResourceWithPatches, error) <span class="cov8" title="4">{
        // First create a unique key for each resource to avoid name collisions
        resourceMap := make(map[string]*unstructured.Unstructured)
        resourceKeys := make([]string, 0)

        for _, r := range s.Resources </span><span class="cov10" title="5">{
                name := r.GetName()
                kindName := fmt.Sprintf("%s.%s", strings.ToLower(r.GetKind()), name)

                // Use kind.name as the primary key to ensure uniqueness
                resourceMap[kindName] = r
                resourceKeys = append(resourceKeys, kindName)

                // Also allow lookup by name alone if it's unique
                if _, exists := resourceMap[name]; !exists </span><span class="cov10" title="5">{
                        resourceMap[name] = r
                }</span>
        }

        // Group patches by target, using the unique resource key for grouping
        <span class="cov8" title="4">out := make(map[string]*ResourceWithPatches)
        for _, p := range s.Patches </span><span class="cov10" title="5">{
                if resource, ok := resourceMap[p.Target]; ok </span><span class="cov10" title="5">{
                        // Use the resource's unique key (kind.name) as the map key for grouping
                        resourceKey := fmt.Sprintf("%s.%s", strings.ToLower(resource.GetKind()), resource.GetName())

                        if rw, exists := out[resourceKey]; exists </span><span class="cov1" title="1">{
                                rw.Patches = append(rw.Patches, p.Patch)
                        }</span> else<span class="cov8" title="4"> {
                                out[resourceKey] = &amp;ResourceWithPatches{
                                        Name:    resource.GetName(),
                                        Base:    resource.DeepCopy(),
                                        Patches: []PatchOp{p.Patch},
                                }
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, errors.ResourceNotFoundError("patch target", p.Target, "", nil)
                }</span>
        }

        // Convert to result slice, preserving original resource order
        <span class="cov8" title="4">var result []*ResourceWithPatches
        for _, key := range resourceKeys </span><span class="cov10" title="5">{
                if rw, exists := out[key]; exists </span><span class="cov8" title="4">{
                        result = append(result, rw)
                }</span>
        }

        <span class="cov8" title="4">return result, nil</span>
}

// WriteToFile writes the patched resources to a file while preserving structure
func (s *PatchableAppSet) WriteToFile(filename string) error <span class="cov0" title="0">{
        if s.DocumentSet == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no document set available for structure preservation")
        }</span>

        // First, resolve and apply all patches
        <span class="cov0" title="0">resolved, err := s.Resolve()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve patches: %w", err)
        }</span>

        // Group patches by target for efficient application
        <span class="cov0" title="0">patchesByTarget := make(map[string][]PatchOp)
        for _, r := range resolved </span><span class="cov0" title="0">{
                patchesByTarget[r.Name] = r.Patches
        }</span>

        // Apply patches to documents while preserving structure
        <span class="cov0" title="0">for _, doc := range s.DocumentSet.Documents </span><span class="cov0" title="0">{
                resourceName := doc.Resource.GetName()
                if patches, exists := patchesByTarget[resourceName]; exists </span><span class="cov0" title="0">{
                        if err := doc.ApplyPatchesToDocument(patches); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to apply patches to document %s: %w", resourceName, err)
                        }</span>
                }
        }

        // Write to file
        <span class="cov0" title="0">return s.DocumentSet.WriteToFile(filename)</span>
}

// WritePatchedFiles writes separate files for each patch set applied
func (s *PatchableAppSet) WritePatchedFiles(originalPath string, patchFiles []string, outputDir string) error <span class="cov0" title="0">{
        if s.DocumentSet == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no document set available for structure preservation")
        }</span>

        // Enable debug for this operation
        <span class="cov0" title="0">oldDebug := Debug
        Debug = true
        defer func() </span><span class="cov0" title="0">{ Debug = oldDebug }</span>()

        <span class="cov0" title="0">for _, patchFile := range patchFiles </span><span class="cov0" title="0">{
                // Generate output filename
                outputFile := GenerateOutputFilename(originalPath, patchFile, outputDir)

                // Create a copy of the document set for this patch
                docSetCopy, err := s.DocumentSet.Copy()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy document set: %w", err)
                }</span>

                // Load patches from the specific patch file
                <span class="cov0" title="0">patchReader, err := openFile(patchFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open patch file %s: %w", patchFile, err)
                }</span>
                <span class="cov0" title="0">defer patchReader.Close()

                patches, err := LoadPatchFile(patchReader)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load patches from %s: %w", patchFile, err)
                }</span>

                // Create a proper PatchableAppSet with structure preservation
                <span class="cov0" title="0">patchableSet, err := NewPatchableAppSetWithStructure(docSetCopy, patches)
                if err != nil </span><span class="cov0" title="0">{
                        // If the error is about a missing target, skip this patch file with a warning
                        if strings.Contains(err.Error(), "explicit target not found") </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️  Skipping %s: contains patches for resources not present in base YAML\n", patchFile)
                                if Debug </span><span class="cov0" title="0">{
                                        fmt.Printf("   Details: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("failed to create patchable set for %s: %w", patchFile, err)</span>
                }

                // Resolve and apply patches
                <span class="cov0" title="0">resolved, err := patchableSet.Resolve()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve patches from %s: %w", patchFile, err)
                }</span>

                // Apply patches to the resources in memory
                <span class="cov0" title="0">for _, r := range resolved </span><span class="cov0" title="0">{
                        if err := r.Apply(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to apply patches to resource %s: %w", r.Name, err)
                        }</span>
                }

                // Update the document set resources with the patched versions
                <span class="cov0" title="0">for _, r := range resolved </span><span class="cov0" title="0">{
                        // Use kind and name to find the correct document when there are duplicates
                        doc := docSetCopy.FindDocumentByKindAndName(r.Base.GetKind(), r.Name)
                        if doc == nil </span><span class="cov0" title="0">{
                                // Fallback to name-only search if kind-specific search fails
                                doc = docSetCopy.FindDocumentByName(r.Name)
                        }</span>
                        <span class="cov0" title="0">if doc != nil </span><span class="cov0" title="0">{
                                doc.Resource = r.Base
                                // Update the YAML node from the patched resource
                                if err := doc.UpdateDocumentFromResource(); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to update document structure for %s: %w", r.Name, err)
                                }</span>
                        }
                }

                // Create output directory if it doesn't exist
                <span class="cov0" title="0">if outputDir != "" &amp;&amp; outputDir != "." </span><span class="cov0" title="0">{
                        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create output directory %s: %w", outputDir, err)
                        }</span>
                }

                // Write to output file
                <span class="cov0" title="0">if err := docSetCopy.WriteToFile(outputFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write patched file %s: %w", outputFile, err)
                }</span>

                <span class="cov0" title="0">if Debug </span><span class="cov0" title="0">{
                        fmt.Printf("Wrote patched resources to: %s\n", outputFile)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper function to open a file (to be replaced with actual file operations)
var openFile = func(filename string) (io.ReadCloser, error) <span class="cov0" title="0">{
        return os.Open(filename)
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package patch

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

// TOMLHeader represents a parsed TOML-style header like [kind.name.section.selector]
type TOMLHeader struct {
        Kind     string
        Name     string
        Sections []string
        Selector *Selector
}

// Selector represents different types of selectors in TOML headers
type Selector struct {
        Type      string // "index", "key-value", "bracketed"
        Index     *int
        Key       string
        Value     string
        Bracketed string
}

// VariableContext holds variables for substitution
type VariableContext struct {
        Values   map[string]interface{}
        Features map[string]bool
}

// ParseTOMLHeader parses a TOML-style header into structured components
// Examples:
//
//        [deployment.app] → Kind: deployment, Name: app
//        [deployment.app.containers.name=main] → Kind: deployment, Name: app, Sections: [containers], Selector: {Key: name, Value: main}
//        [deployment.app.ports.0] → Kind: deployment, Name: app, Sections: [ports], Selector: {Index: 0}
//        [deployment.app.containers[image.name=main]] → Kind: deployment, Name: app, Sections: [containers], Selector: {Bracketed: image.name=main}
func ParseTOMLHeader(header string) (*TOMLHeader, error) <span class="cov5" title="14">{
        // Remove brackets and trim whitespace
        header = strings.TrimSpace(header)
        if !strings.HasPrefix(header, "[") || !strings.HasSuffix(header, "]") </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid TOML header format: %s", header)
        }</span>

        <span class="cov5" title="13">content := strings.TrimSpace(header[1 : len(header)-1])
        if content == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("empty TOML header")
        }</span>

        // Handle bracketed selectors first: [deployment.app.containers[image.name=main]]
        <span class="cov5" title="12">bracketedRe := regexp.MustCompile(`^(.+)\[(.+)\]$`)
        if matches := bracketedRe.FindStringSubmatch(content); len(matches) == 3 </span><span class="cov1" title="1">{
                path := matches[1]
                bracketed := matches[2]

                parts := strings.Split(path, ".")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("TOML header must have at least kind.name: %s", header)
                }</span>

                <span class="cov1" title="1">return &amp;TOMLHeader{
                        Kind:     parts[0],
                        Name:     parts[1],
                        Sections: parts[2:],
                        Selector: &amp;Selector{
                                Type:      "bracketed",
                                Bracketed: bracketed,
                        },
                }, nil</span>
        }

        // Split by dots
        <span class="cov5" title="11">parts := strings.Split(content, ".")
        if len(parts) &lt; 2 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("TOML header must have at least kind.name: %s", header)
        }</span>

        <span class="cov4" title="10">result := &amp;TOMLHeader{
                Kind: parts[0],
                Name: parts[1],
        }

        // Process remaining parts for sections and selectors
        if len(parts) &gt; 2 </span><span class="cov4" title="7">{
                sections := parts[2:]
                lastIdx := len(sections) - 1
                lastPart := sections[lastIdx]

                // Check if the last part is a selector
                selector, isSelector := parseSelector(lastPart)
                if isSelector </span><span class="cov4" title="6">{
                        result.Selector = selector
                        if lastIdx &gt; 0 </span><span class="cov4" title="6">{
                                result.Sections = sections[:lastIdx]
                        }</span>
                } else<span class="cov1" title="1"> {
                        result.Sections = sections
                }</span>
        }

        <span class="cov4" title="10">return result, nil</span>
}

// parseSelector determines if a part is a selector and parses it
func parseSelector(part string) (*Selector, bool) <span class="cov4" title="7">{
        // Check for key=value selector
        if strings.Contains(part, "=") &amp;&amp; !strings.Contains(part, "[") </span><span class="cov3" title="4">{
                keyValue := strings.SplitN(part, "=", 2)
                return &amp;Selector{
                        Type:  "key-value",
                        Key:   keyValue[0],
                        Value: keyValue[1],
                }, true
        }</span>

        // Check for numeric index
        <span class="cov2" title="3">if idx, err := strconv.Atoi(part); err == nil </span><span class="cov2" title="2">{
                return &amp;Selector{
                        Type:  "index",
                        Index: &amp;idx,
                }, true
        }</span>

        <span class="cov1" title="1">return nil, false</span>
}

// ResolveTOMLPath converts a TOML header to resource target and field path
func (h *TOMLHeader) ResolveTOMLPath() (resourceTarget, fieldPath string, err error) <span class="cov5" title="15">{
        // Resource target should include kind to distinguish resources with same name
        if h.Kind != "" </span><span class="cov5" title="15">{
                resourceTarget = fmt.Sprintf("%s.%s", h.Kind, h.Name)
        }</span> else<span class="cov0" title="0"> {
                resourceTarget = h.Name
        }</span>

        // Build field path from sections and selector
        <span class="cov5" title="15">var pathParts []string

        // Map TOML sections to Kubernetes paths based on resource kind
        pathParts = h.mapSectionsToKubernetesPath()

        // Add selector to path
        if h.Selector != nil </span><span class="cov4" title="9">{
                switch h.Selector.Type </span>{
                case "index":<span class="cov2" title="2">
                        // Remove the last part and add it with index selector
                        if len(pathParts) &gt; 0 </span><span class="cov2" title="2">{
                                lastPart := pathParts[len(pathParts)-1]
                                pathParts = pathParts[:len(pathParts)-1]
                                pathParts = append(pathParts, fmt.Sprintf("%s[%d]", lastPart, *h.Selector.Index))
                        }</span> else<span class="cov0" title="0"> {
                                pathParts = append(pathParts, fmt.Sprintf("[%d]", *h.Selector.Index))
                        }</span>
                case "key-value":<span class="cov4" title="7">
                        // Remove the last part and add it with key-value selector
                        if len(pathParts) &gt; 0 </span><span class="cov4" title="7">{
                                lastPart := pathParts[len(pathParts)-1]
                                pathParts = pathParts[:len(pathParts)-1]
                                pathParts = append(pathParts, fmt.Sprintf("%s[%s=%s]", lastPart, h.Selector.Key, h.Selector.Value))
                        }</span> else<span class="cov0" title="0"> {
                                pathParts = append(pathParts, fmt.Sprintf("[%s=%s]", h.Selector.Key, h.Selector.Value))
                        }</span>
                case "bracketed":<span class="cov0" title="0">
                        // For bracketed selectors, parse the inner content and apply it
                        if len(pathParts) &gt; 0 </span><span class="cov0" title="0">{
                                lastPart := pathParts[len(pathParts)-1]
                                pathParts = pathParts[:len(pathParts)-1]
                                pathParts = append(pathParts, fmt.Sprintf("%s[%s]", lastPart, h.Selector.Bracketed))
                        }</span> else<span class="cov0" title="0"> {
                                pathParts = append(pathParts, fmt.Sprintf("[%s]", h.Selector.Bracketed))
                        }</span>
                }
        }

        <span class="cov5" title="15">fieldPath = strings.Join(pathParts, ".")

        // Clean up path - remove multiple dots, leading/trailing dots
        fieldPath = regexp.MustCompile(`\.+`).ReplaceAllString(fieldPath, ".")
        fieldPath = strings.Trim(fieldPath, ".")

        return resourceTarget, fieldPath, nil</span>
}

// mapSectionsToKubernetesPath maps TOML sections to appropriate Kubernetes field paths
// based on the resource kind and section hierarchy
func (h *TOMLHeader) mapSectionsToKubernetesPath() []string <span class="cov5" title="15">{
        if len(h.Sections) == 0 </span><span class="cov4" title="6">{
                return []string{}
        }</span>

        <span class="cov4" title="9">var pathParts []string
        kind := strings.ToLower(h.Kind)

        // Process sections based on Kubernetes resource structure
        for i, section := range h.Sections </span><span class="cov4" title="10">{
                switch section </span>{
                case "containers":<span class="cov3" title="4">
                        if isWorkloadKind(kind) </span><span class="cov3" title="4">{
                                pathParts = append(pathParts, "spec", "template", "spec", "containers")
                        }</span> else<span class="cov0" title="0"> {
                                pathParts = append(pathParts, "spec", "containers")
                        }</span>
                case "initContainers":<span class="cov0" title="0">
                        if isWorkloadKind(kind) </span><span class="cov0" title="0">{
                                pathParts = append(pathParts, "spec", "template", "spec", "initContainers")
                        }</span> else<span class="cov0" title="0"> {
                                pathParts = append(pathParts, "spec", "initContainers")
                        }</span>
                case "ports":<span class="cov3" title="4">
                        // Context-sensitive: could be container ports or service ports
                        if i &gt; 0 &amp;&amp; h.Sections[i-1] == "containers" </span><span class="cov0" title="0">{
                                pathParts = append(pathParts, "ports")
                        }</span> else<span class="cov3" title="4"> {
                                pathParts = append(pathParts, "spec", "ports")
                        }</span>
                case "env":<span class="cov0" title="0">
                        pathParts = append(pathParts, "env")</span>
                case "envFrom":<span class="cov0" title="0">
                        pathParts = append(pathParts, "envFrom")</span>
                case "volumeMounts":<span class="cov0" title="0">
                        pathParts = append(pathParts, "volumeMounts")</span>
                case "volumes":<span class="cov0" title="0">
                        if isWorkloadKind(kind) </span><span class="cov0" title="0">{
                                pathParts = append(pathParts, "spec", "template", "spec", "volumes")
                        }</span> else<span class="cov0" title="0"> {
                                pathParts = append(pathParts, "spec", "volumes")
                        }</span>
                case "resources":<span class="cov0" title="0">
                        pathParts = append(pathParts, "resources")</span>
                case "securityContext":<span class="cov0" title="0">
                        pathParts = append(pathParts, "securityContext")</span>
                case "image":<span class="cov0" title="0">
                        pathParts = append(pathParts, "image")</span>
                case "command":<span class="cov0" title="0">
                        pathParts = append(pathParts, "command")</span>
                case "args":<span class="cov0" title="0">
                        pathParts = append(pathParts, "args")</span>

                // Service-specific sections
                case "selector":<span class="cov0" title="0">
                        pathParts = append(pathParts, "spec", "selector")</span>
                case "type":<span class="cov0" title="0">
                        pathParts = append(pathParts, "spec", "type")</span>

                // Ingress-specific sections
                case "tls":<span class="cov0" title="0">
                        pathParts = append(pathParts, "spec", "tls")</span>
                case "rules":<span class="cov1" title="1">
                        if kind == "role" || kind == "clusterrole" </span><span class="cov0" title="0">{
                                pathParts = append(pathParts, "rules")
                        }</span> else<span class="cov1" title="1"> {
                                // Ingress rules
                                pathParts = append(pathParts, "spec", "rules")
                        }</span>
                case "backend":<span class="cov0" title="0">
                        pathParts = append(pathParts, "backend")</span>
                case "paths":<span class="cov1" title="1">
                        pathParts = append(pathParts, "http", "paths")</span>

                // ConfigMap/Secret sections
                case "data":<span class="cov0" title="0">
                        pathParts = append(pathParts, "data")</span>
                case "stringData":<span class="cov0" title="0">
                        pathParts = append(pathParts, "stringData")</span>
                case "binaryData":<span class="cov0" title="0">
                        pathParts = append(pathParts, "binaryData")</span>

                // RBAC sections  - handled above in the ingress case, check context
                case "subjects":<span class="cov0" title="0">
                        pathParts = append(pathParts, "subjects")</span>
                case "roleRef":<span class="cov0" title="0">
                        pathParts = append(pathParts, "roleRef")</span>

                // Generic spec and metadata sections
                case "spec":<span class="cov0" title="0">
                        pathParts = append(pathParts, "spec")</span>
                case "metadata":<span class="cov0" title="0">
                        pathParts = append(pathParts, "metadata")</span>
                case "labels":<span class="cov0" title="0">
                        if len(pathParts) == 0 || pathParts[len(pathParts)-1] != "metadata" </span><span class="cov0" title="0">{
                                pathParts = append(pathParts, "metadata", "labels")
                        }</span> else<span class="cov0" title="0"> {
                                pathParts = append(pathParts, "labels")
                        }</span>
                case "annotations":<span class="cov0" title="0">
                        if len(pathParts) == 0 || pathParts[len(pathParts)-1] != "metadata" </span><span class="cov0" title="0">{
                                pathParts = append(pathParts, "metadata", "annotations")
                        }</span> else<span class="cov0" title="0"> {
                                pathParts = append(pathParts, "annotations")
                        }</span>
                case "template":<span class="cov0" title="0">
                        pathParts = append(pathParts, "template")</span>

                // Numeric sections (likely array indices when not handled as selectors)
                default:<span class="cov0" title="0">
                        if _, err := strconv.Atoi(section); err == nil </span><span class="cov0" title="0">{
                                // This is a numeric index, treat it as array access
                                if len(pathParts) &gt; 0 </span><span class="cov0" title="0">{
                                        lastPart := pathParts[len(pathParts)-1]
                                        pathParts = pathParts[:len(pathParts)-1]
                                        pathParts = append(pathParts, fmt.Sprintf("%s[%s]", lastPart, section))
                                }</span> else<span class="cov0" title="0"> {
                                        pathParts = append(pathParts, fmt.Sprintf("[%s]", section))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Unknown section, add as-is
                                pathParts = append(pathParts, section)
                        }</span>
                }
        }

        <span class="cov4" title="9">return pathParts</span>
}

// isWorkloadKind returns true for Kubernetes workload kinds that have pod templates
func isWorkloadKind(kind string) bool <span class="cov3" title="4">{
        workloadKinds := []string{
                "deployment", "replicaset", "statefulset", "daemonset", "job", "cronjob",
        }

        for _, wk := range workloadKinds </span><span class="cov3" title="4">{
                if strings.ToLower(kind) == wk </span><span class="cov3" title="4">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// SubstituteVariables replaces ${values.key} and ${features.flag} patterns with actual values
func SubstituteVariables(value string, ctx *VariableContext) (interface{}, error) <span class="cov6" title="24">{
        if ctx == nil </span><span class="cov5" title="14">{
                return value, nil
        }</span>

        <span class="cov4" title="10">strValue := fmt.Sprintf("%v", value)

        // Pattern for ${values.key} and ${features.flag}
        varPattern := regexp.MustCompile(`\$\{(values|features)\.([^}]+)\}`)

        result := varPattern.ReplaceAllStringFunc(strValue, func(match string) string </span><span class="cov4" title="9">{
                matches := varPattern.FindStringSubmatch(match)
                if len(matches) != 3 </span><span class="cov0" title="0">{
                        return match // Return original if we can't parse
                }</span>

                <span class="cov4" title="9">scope := matches[1]
                key := matches[2]

                switch scope </span>{
                case "values":<span class="cov4" title="6">
                        if val, exists := ctx.Values[key]; exists </span><span class="cov3" title="5">{
                                return fmt.Sprintf("%v", val)
                        }</span>
                case "features":<span class="cov2" title="3">
                        if val, exists := ctx.Features[key]; exists </span><span class="cov2" title="3">{
                                return fmt.Sprintf("%v", val)
                        }</span>
                }

                <span class="cov1" title="1">return match</span> // Return original if variable not found
        })

        // If no substitution occurred, return original value
        <span class="cov4" title="10">if result == strValue </span><span class="cov2" title="3">{
                return value, nil
        }</span>

        <span class="cov4" title="7">return result, nil</span>
}

// IsTOMLFormat detects if the content appears to be TOML-style patch format
func IsTOMLFormat(content string) bool <span class="cov5" title="11">{
        lines := strings.Split(content, "\n")

        for _, line := range lines </span><span class="cov5" title="13">{
                line = strings.TrimSpace(line)

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov3" title="4">{
                        continue</span>
                }

                // Look for TOML section header
                <span class="cov4" title="9">if strings.HasPrefix(line, "[") &amp;&amp; strings.Contains(line, "]") </span><span class="cov2" title="2">{
                        return true
                }</span>

                // Look for TOML key = value pattern (but not in inline tables)
                <span class="cov4" title="7">if strings.Contains(line, " = ") &amp;&amp; !strings.Contains(line, "{") </span><span class="cov0" title="0">{
                        return true
                }</span>

                // If we find non-comment, non-empty content that's not a TOML header
                // but looks like YAML (starts with - or has :), it's probably YAML
                <span class="cov4" title="7">if strings.HasPrefix(line, "-") || (strings.Contains(line, ":") &amp;&amp; !strings.HasPrefix(line, "[")) </span><span class="cov4" title="7">{
                        return false
                }</span>
        }

        <span class="cov2" title="2">return false</span>
}

// String returns a string representation of the TOML header
func (h *TOMLHeader) String() string <span class="cov0" title="0">{
        parts := []string{h.Kind, h.Name}
        parts = append(parts, h.Sections...)

        result := strings.Join(parts, ".")

        if h.Selector != nil </span><span class="cov0" title="0">{
                switch h.Selector.Type </span>{
                case "index":<span class="cov0" title="0">
                        result += fmt.Sprintf(".%d", *h.Selector.Index)</span>
                case "key-value":<span class="cov0" title="0">
                        result += fmt.Sprintf(".%s=%s", h.Selector.Key, h.Selector.Value)</span>
                case "bracketed":<span class="cov0" title="0">
                        result += fmt.Sprintf("[%s]", h.Selector.Bracketed)</span>
                }
        }

        <span class="cov0" title="0">return fmt.Sprintf("[%s]", result)</span>
}

// inferValueType attempts to convert string values to appropriate Go types
// This is important for Kubernetes fields that expect specific types (e.g., ports as integers)
func inferValueType(key, value string) interface{} <span class="cov5" title="17">{
        // Handle boolean values
        switch strings.ToLower(value) </span>{
        case "true":<span class="cov1" title="1">
                return true</span>
        case "false":<span class="cov0" title="0">
                return false</span>
        }

        // Handle integer values - common Kubernetes fields that should be integers
        <span class="cov5" title="16">if isIntegerField(key) </span><span class="cov4" title="6">{
                if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov3" title="5">{
                        return intVal
                }</span>
        }

        // Try to parse as integer for any numeric-looking string
        <span class="cov5" title="11">if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                // Check if this looks like a port, replica count, or other integer field
                if isLikelyIntegerValue(key, value) </span><span class="cov0" title="0">{
                        return intVal
                }</span>
        }

        // Return as string for everything else
        <span class="cov5" title="11">return value</span>
}

// isIntegerField checks if a field path indicates it should be an integer
func isIntegerField(key string) bool <span class="cov5" title="16">{
        integerFields := []string{
                "port", "targetPort", "nodePort", "containerPort",
                "replicas", "maxUnavailable", "maxSurge",
                "initialDelaySeconds", "timeoutSeconds", "periodSeconds", "successThreshold", "failureThreshold",
                "terminationGracePeriodSeconds", "activeDeadlineSeconds",
                "runAsUser", "runAsGroup", "fsGroup",
                "weight", "priority", "number",
        }

        keyLower := strings.ToLower(key)
        for _, field := range integerFields </span><span class="cov10" title="214">{
                if strings.Contains(keyLower, strings.ToLower(field)) </span><span class="cov4" title="6">{
                        return true
                }</span>
        }

        <span class="cov4" title="10">return false</span>
}

// isLikelyIntegerValue uses heuristics to determine if a value should be an integer
func isLikelyIntegerValue(key, value string) bool <span class="cov0" title="0">{
        keyLower := strings.ToLower(key)

        // Port ranges (1-65535)
        if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                if intVal &gt;= 1 &amp;&amp; intVal &lt;= 65535 </span><span class="cov0" title="0">{
                        if strings.Contains(keyLower, "port") </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }

                // Replica counts (typically 0-100)
                <span class="cov0" title="0">if intVal &gt;= 0 &amp;&amp; intVal &lt;= 100 </span><span class="cov0" title="0">{
                        if strings.Contains(keyLower, "replica") </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }

                // Common timeout/delay values (0-3600 seconds)
                <span class="cov0" title="0">if intVal &gt;= 0 &amp;&amp; intVal &lt;= 3600 </span><span class="cov0" title="0">{
                        if strings.Contains(keyLower, "delay") || strings.Contains(keyLower, "timeout") || strings.Contains(keyLower, "period") </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package patch

import (
        "bufio"
        "bytes"
        "fmt"
        "io"
        "os"
        "regexp"
        "strconv"
        "strings"

        "gopkg.in/yaml.v3"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// YAMLDocument represents a single YAML document with preserved structure
type YAMLDocument struct {
        Node     *yaml.Node
        Resource *unstructured.Unstructured
        Original string // Original YAML content with comments
        Order    int    // Original position in file
}

// YAMLDocumentSet holds multiple YAML documents with preserved order and comments
type YAMLDocumentSet struct {
        Documents []*YAMLDocument
        Separator string // Document separator (usually "---")
}

// LoadResourcesWithStructure loads YAML resources while preserving comments and order
func LoadResourcesWithStructure(r io.Reader) (*YAMLDocumentSet, error) <span class="cov4" title="6">{
        content, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read YAML content: %w", err)
        }</span>

        // Split into documents while preserving separators and content
        <span class="cov4" title="6">documents, err := parseYAMLDocuments(string(content))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML documents: %w", err)
        }</span>

        <span class="cov4" title="6">set := &amp;YAMLDocumentSet{
                Documents: make([]*YAMLDocument, 0, len(documents)),
                Separator: "---",
        }

        for i, docContent := range documents </span><span class="cov5" title="12">{
                if strings.TrimSpace(docContent) == "" </span><span class="cov0" title="0">{
                        continue</span> // Skip empty documents
                }

                // Parse with yaml.v3 to preserve structure
                <span class="cov5" title="12">var node yaml.Node
                if err := yaml.Unmarshal([]byte(docContent), &amp;node); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse document %d: %w", i, err)
                }</span>

                // Also parse into unstructured for patching
                <span class="cov5" title="12">var raw map[string]interface{}
                if err := yaml.Unmarshal([]byte(docContent), &amp;raw); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse document %d into unstructured: %w", i, err)
                }</span>

                <span class="cov5" title="12">if len(raw) == 0 </span><span class="cov0" title="0">{
                        continue</span> // Skip empty documents
                }

                // Apply type conversion to base YAML values to fix string ports, etc.
                // First convert the raw data for the unstructured object
                <span class="cov5" title="12">convertedRaw := convertBaseYAMLTypes(raw)
                var resource *unstructured.Unstructured
                if convertedMap, ok := convertedRaw.(map[string]interface{}); ok </span><span class="cov5" title="12">{
                        resource = &amp;unstructured.Unstructured{Object: convertedMap}
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to original if conversion failed
                        resource = &amp;unstructured.Unstructured{Object: raw}
                }</span>

                // Also apply type conversion to the YAML node to preserve formatting
                <span class="cov5" title="12">if err := convertYAMLNodeTypes(&amp;node); err != nil </span><span class="cov0" title="0">{
                        if Debug </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to convert YAML node types: %v\n", err)
                        }</span>
                }

                <span class="cov5" title="12">doc := &amp;YAMLDocument{
                        Node:     &amp;node,
                        Resource: resource,
                        Original: docContent,
                        Order:    i,
                }

                set.Documents = append(set.Documents, doc)

                if Debug </span><span class="cov0" title="0">{
                        fmt.Printf("Loaded document %d: kind=%s name=%s\n", i, resource.GetKind(), resource.GetName())
                }</span>
        }

        <span class="cov4" title="6">return set, nil</span>
}

// parseYAMLDocuments splits multi-document YAML while preserving content structure
func parseYAMLDocuments(content string) ([]string, error) <span class="cov4" title="6">{
        var documents []string
        var currentDoc strings.Builder

        scanner := bufio.NewScanner(strings.NewReader(content))

        for scanner.Scan() </span><span class="cov9" title="113">{
                line := scanner.Text()

                // Check for document separator
                if strings.TrimSpace(line) == "---" </span><span class="cov4" title="6">{
                        // Save current document if it has content
                        if currentDoc.Len() &gt; 0 </span><span class="cov4" title="6">{
                                documents = append(documents, currentDoc.String())
                                currentDoc.Reset()
                        }</span>
                        <span class="cov4" title="6">continue</span>
                }

                // Add line to current document
                <span class="cov9" title="107">if currentDoc.Len() &gt; 0 </span><span class="cov9" title="95">{
                        currentDoc.WriteString("\n")
                }</span>
                <span class="cov9" title="107">currentDoc.WriteString(line)</span>
        }

        // Add final document
        <span class="cov4" title="6">if currentDoc.Len() &gt; 0 </span><span class="cov4" title="6">{
                documents = append(documents, currentDoc.String())
        }</span>

        <span class="cov4" title="6">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading YAML content: %w", err)
        }</span>

        <span class="cov4" title="6">return documents, nil</span>
}

// ApplyPatchesToDocument applies patches to a YAML document while preserving structure
func (doc *YAMLDocument) ApplyPatchesToDocument(patches []PatchOp) error <span class="cov0" title="0">{
        // Apply patches to the unstructured resource
        for _, patch := range patches </span><span class="cov0" title="0">{
                if err := applyPatchOp(doc.Resource.Object, patch); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to apply patch %v: %w", patch, err)
                }</span>
        }

        // Update the YAML node with patched data
        // First, marshal the patched resource to YAML
        <span class="cov0" title="0">patchedYAML, err := yaml.Marshal(doc.Resource.Object)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal patched resource: %w", err)
        }</span>

        // Parse the patched YAML back into a node structure
        <span class="cov0" title="0">var patchedNode yaml.Node
        if err := yaml.Unmarshal(patchedYAML, &amp;patchedNode); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse patched YAML: %w", err)
        }</span>

        // Try to preserve comments by merging structures
        <span class="cov0" title="0">if err := mergeYAMLNodes(doc.Node, &amp;patchedNode); err != nil </span><span class="cov0" title="0">{
                // If merging fails, fall back to using the patched node
                doc.Node = &amp;patchedNode
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// mergeYAMLNodes attempts to merge patched values into original node structure
// This is a best-effort attempt to preserve comments and formatting
func mergeYAMLNodes(original, patched *yaml.Node) error <span class="cov0" title="0">{
        if original.Kind != patched.Kind </span><span class="cov0" title="0">{
                return fmt.Errorf("node kinds don't match: %v vs %v", original.Kind, patched.Kind)
        }</span>

        <span class="cov0" title="0">switch original.Kind </span>{
        case yaml.DocumentNode:<span class="cov0" title="0">
                if len(original.Content) &gt; 0 &amp;&amp; len(patched.Content) &gt; 0 </span><span class="cov0" title="0">{
                        return mergeYAMLNodes(original.Content[0], patched.Content[0])
                }</span>
        case yaml.MappingNode:<span class="cov0" title="0">
                return mergeMappingNodes(original, patched)</span>
        case yaml.SequenceNode:<span class="cov0" title="0">
                return mergeSequenceNodes(original, patched)</span>
        case yaml.ScalarNode:<span class="cov0" title="0">
                // Update scalar value while preserving style and comments
                original.Value = patched.Value</span>
                // Keep original style and comments
        }

        <span class="cov0" title="0">return nil</span>
}

// mergeMappingNodes merges mapping (object) nodes
func mergeMappingNodes(original, patched *yaml.Node) error <span class="cov0" title="0">{
        if len(patched.Content)%2 != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid mapping node: odd number of content items")
        }</span>

        // Create a map of keys in the patched node for efficient lookup
        <span class="cov0" title="0">patchedMap := make(map[string]*yaml.Node)
        for i := 0; i &lt; len(patched.Content); i += 2 </span><span class="cov0" title="0">{
                key := patched.Content[i].Value
                value := patched.Content[i+1]
                patchedMap[key] = value
        }</span>

        // Update existing keys in original
        <span class="cov0" title="0">for i := 0; i &lt; len(original.Content); i += 2 </span><span class="cov0" title="0">{
                key := original.Content[i].Value
                if patchedValue, exists := patchedMap[key]; exists </span><span class="cov0" title="0">{
                        // Recursively merge if both are objects/arrays, otherwise replace
                        if original.Content[i+1].Kind == patchedValue.Kind &amp;&amp;
                                (patchedValue.Kind == yaml.MappingNode || patchedValue.Kind == yaml.SequenceNode) </span><span class="cov0" title="0">{
                                mergeYAMLNodes(original.Content[i+1], patchedValue)
                        }</span> else<span class="cov0" title="0"> {
                                // Replace the value node but keep the key node (preserves comments on key)
                                original.Content[i+1] = patchedValue
                        }</span>
                        <span class="cov0" title="0">delete(patchedMap, key)</span> // Mark as processed
                }
        }

        // Add new keys from patched
        <span class="cov0" title="0">for key, value := range patchedMap </span><span class="cov0" title="0">{
                keyNode := &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: key,
                }
                original.Content = append(original.Content, keyNode, value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// mergeSequenceNodes merges sequence (array) nodes
func mergeSequenceNodes(original, patched *yaml.Node) error <span class="cov0" title="0">{
        // For sequences, we generally replace the entire content
        // as it's difficult to meaningfully merge arrays while preserving order
        original.Content = patched.Content
        return nil
}</span>

// WriteToFile writes the document set to a file with preserved structure
func (set *YAMLDocumentSet) WriteToFile(filename string) error <span class="cov0" title="0">{
        var buf bytes.Buffer

        for i, doc := range set.Documents </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        buf.WriteString(set.Separator + "\n")
                }</span>

                // Marshal the updated node back to YAML
                <span class="cov0" title="0">encoder := yaml.NewEncoder(&amp;buf)
                encoder.SetIndent(2)

                if err := encoder.Encode(doc.Node); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode document %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">encoder.Close()</span>
        }

        // Write to file
        <span class="cov0" title="0">content := buf.String()
        // Clean up extra newlines at the end
        content = strings.TrimSuffix(content, "\n") + "\n"

        if err := writeFile(filename, []byte(content)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file %s: %w", filename, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// writeFile is a helper to write content to a file
func writeFile(filename string, content []byte) error <span class="cov0" title="0">{
        return os.WriteFile(filename, content, 0644)
}</span>

// GetResources returns the unstructured resources in order
func (set *YAMLDocumentSet) GetResources() []*unstructured.Unstructured <span class="cov2" title="2">{
        resources := make([]*unstructured.Unstructured, len(set.Documents))
        for i, doc := range set.Documents </span><span class="cov4" title="6">{
                resources[i] = doc.Resource
        }</span>
        <span class="cov2" title="2">return resources</span>
}

// FindDocumentByName finds a document by resource name
func (set *YAMLDocumentSet) FindDocumentByName(name string) *YAMLDocument <span class="cov3" title="3">{
        for _, doc := range set.Documents </span><span class="cov3" title="4">{
                if doc.Resource.GetName() == name </span><span class="cov3" title="3">{
                        return doc
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// FindDocumentByKindAndName finds a document by resource kind and name
func (set *YAMLDocumentSet) FindDocumentByKindAndName(kind, name string) *YAMLDocument <span class="cov0" title="0">{
        for _, doc := range set.Documents </span><span class="cov0" title="0">{
                if strings.ToLower(doc.Resource.GetKind()) == strings.ToLower(kind) &amp;&amp;
                        doc.Resource.GetName() == name </span><span class="cov0" title="0">{
                        return doc
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// UpdateDocumentFromResource updates a document's YAML node from its resource
func (doc *YAMLDocument) UpdateDocumentFromResource() error <span class="cov1" title="1">{
        // Marshal the updated resource to YAML
        updatedYAML, err := yaml.Marshal(doc.Resource.Object)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal updated resource: %w", err)
        }</span>

        // Parse the updated YAML back into a node structure
        <span class="cov1" title="1">var updatedNode yaml.Node
        if err := yaml.Unmarshal(updatedYAML, &amp;updatedNode); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse updated YAML: %w", err)
        }</span>

        // For now, use the updated node directly to ensure correctness
        // Comment preservation will be improved in a future iteration
        <span class="cov1" title="1">doc.Node = &amp;updatedNode

        return nil</span>
}

// GenerateOutputFilename creates the output filename based on the pattern
// &lt;outputDir&gt;/&lt;originalname&gt;-patch-&lt;patchname&gt;.yaml
func GenerateOutputFilename(originalPath, patchPath, outputDir string) string <span class="cov0" title="0">{
        // Extract base names without extensions
        originalBase := extractBaseName(originalPath)
        patchBase := extractBaseName(patchPath)

        if outputDir == "" </span><span class="cov0" title="0">{
                outputDir = "." // Default to current directory
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s/%s-patch-%s.yaml", outputDir, originalBase, patchBase)</span>
}

// Copy creates a deep copy of the YAMLDocumentSet
func (set *YAMLDocumentSet) Copy() (*YAMLDocumentSet, error) <span class="cov1" title="1">{
        copiedSet := &amp;YAMLDocumentSet{
                Documents: make([]*YAMLDocument, len(set.Documents)),
                Separator: set.Separator,
        }

        for i, doc := range set.Documents </span><span class="cov2" title="2">{
                // Deep copy the YAML node
                copiedNode, err := copyYAMLNode(doc.Node)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to copy YAML node for document %d: %w", i, err)
                }</span>

                // Deep copy the unstructured resource
                <span class="cov2" title="2">copiedResource := doc.Resource.DeepCopy()

                copiedSet.Documents[i] = &amp;YAMLDocument{
                        Node:     copiedNode,
                        Resource: copiedResource,
                        Original: doc.Original, // String is immutable, safe to share
                        Order:    doc.Order,
                }</span>
        }

        <span class="cov1" title="1">return copiedSet, nil</span>
}

// copyYAMLNode creates a deep copy of a yaml.Node
func copyYAMLNode(node *yaml.Node) (*yaml.Node, error) <span class="cov6" title="24">{
        if node == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov6" title="24">copied := &amp;yaml.Node{
                Kind:        node.Kind,
                Style:       node.Style,
                Tag:         node.Tag,
                Value:       node.Value,
                Anchor:      node.Anchor,
                Alias:       node.Alias,
                Content:     make([]*yaml.Node, len(node.Content)),
                HeadComment: node.HeadComment,
                LineComment: node.LineComment,
                FootComment: node.FootComment,
                Line:        node.Line,
                Column:      node.Column,
        }

        // Recursively copy content nodes
        for i, child := range node.Content </span><span class="cov6" title="22">{
                copiedChild, err := copyYAMLNode(child)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to copy child node %d: %w", i, err)
                }</span>
                <span class="cov6" title="22">copied.Content[i] = copiedChild</span>
        }

        <span class="cov6" title="24">return copied, nil</span>
}

// extractBaseName extracts the base name without extension from a file path
func extractBaseName(filePath string) string <span class="cov0" title="0">{
        // Find the last slash to get filename
        lastSlash := strings.LastIndex(filePath, "/")
        if lastSlash == -1 </span><span class="cov0" title="0">{
                lastSlash = strings.LastIndex(filePath, "\\") // Windows path
        }</span>

        <span class="cov0" title="0">filename := filePath
        if lastSlash &gt;= 0 </span><span class="cov0" title="0">{
                filename = filePath[lastSlash+1:]
        }</span>

        // Remove extension
        <span class="cov0" title="0">if dotIndex := strings.LastIndex(filename, "."); dotIndex &gt; 0 </span><span class="cov0" title="0">{
                filename = filename[:dotIndex]
        }</span>

        // Clean up filename for use in output (remove invalid characters)
        <span class="cov0" title="0">re := regexp.MustCompile(`[^a-zA-Z0-9\-_]`)
        return re.ReplaceAllString(filename, "-")</span>
}

// convertBaseYAMLTypes recursively converts string values in base YAML to appropriate types
// This fixes issues where Kubernetes YAML files have numeric fields as strings
func convertBaseYAMLTypes(obj interface{}) interface{} <span class="cov9" title="107">{
        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov7" title="43">
                converted := make(map[string]interface{})
                for key, value := range v </span><span class="cov9" title="99">{
                        // Apply type inference based on field name and value
                        if strValue, ok := value.(string); ok </span><span class="cov8" title="65">{
                                if shouldConvertToInteger(key, strValue) </span><span class="cov5" title="9">{
                                        if intVal, err := strconv.Atoi(strValue); err == nil </span><span class="cov5" title="9">{
                                                converted[key] = int64(intVal) // Use int64 for unstructured compatibility
                                                continue</span>
                                        }
                                }
                                <span class="cov8" title="56">if shouldConvertToBoolean(strValue) </span><span class="cov0" title="0">{
                                        if boolVal, err := strconv.ParseBool(strValue); err == nil </span><span class="cov0" title="0">{
                                                converted[key] = boolVal
                                                continue</span>
                                        }
                                }
                        }
                        // Recursively convert nested objects
                        <span class="cov9" title="90">converted[key] = convertBaseYAMLTypes(value)</span>
                }
                <span class="cov7" title="43">return converted</span>
        case []interface{}:<span class="cov3" title="4">
                converted := make([]interface{}, len(v))
                for i, item := range v </span><span class="cov3" title="5">{
                        converted[i] = convertBaseYAMLTypes(item)
                }</span>
                <span class="cov3" title="4">return converted</span>
        default:<span class="cov8" title="60">
                return obj</span>
        }
}

// shouldConvertToInteger determines if a string field should be converted to integer
func shouldConvertToInteger(key, value string) bool <span class="cov10" title="134">{
        // Skip if not a valid integer
        if _, err := strconv.Atoi(value); err != nil </span><span class="cov9" title="112">{
                return false
        }</span>

        // Convert common Kubernetes integer fields
        <span class="cov6" title="22">integerFields := []string{
                "port", "targetport", "nodeport", "containerport",
                "replicas", "maxunavailable", "maxsurge",
                "initialdelayseconds", "timeoutseconds", "periodseconds",
                "successthreshold", "failurethreshold",
                "terminationgraceperiodseconds", "activedeadlineseconds",
                "runasuser", "runasgroup", "fsgroup",
                "weight", "priority", "number",
        }

        keyLower := strings.ToLower(key)
        for _, field := range integerFields </span><span class="cov7" title="38">{
                if strings.Contains(keyLower, field) </span><span class="cov6" title="22">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// shouldConvertToBoolean determines if a string should be converted to boolean
func shouldConvertToBoolean(value string) bool <span class="cov9" title="112">{
        lowerValue := strings.ToLower(value)
        return lowerValue == "true" || lowerValue == "false"
}</span>

// convertYAMLNodeTypes recursively converts string values in YAML nodes to appropriate types
// while preserving the original YAML structure and formatting
func convertYAMLNodeTypes(node *yaml.Node) error <span class="cov9" title="128">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov9" title="128">switch node.Kind </span>{
        case yaml.DocumentNode:<span class="cov5" title="12">
                // Process document content
                for _, child := range node.Content </span><span class="cov5" title="12">{
                        if err := convertYAMLNodeTypes(child); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        case yaml.MappingNode:<span class="cov7" title="43">
                // Process mapping nodes (key-value pairs)
                for i := 0; i &lt; len(node.Content); i += 2 </span><span class="cov9" title="99">{
                        keyNode := node.Content[i]
                        valueNode := node.Content[i+1]

                        // Convert the value node based on the key name
                        if keyNode.Kind == yaml.ScalarNode &amp;&amp; valueNode.Kind == yaml.ScalarNode </span><span class="cov8" title="69">{
                                convertScalarNodeType(keyNode.Value, valueNode)
                        }</span>

                        // Recursively process nested nodes
                        <span class="cov9" title="99">if err := convertYAMLNodeTypes(valueNode); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        case yaml.SequenceNode:<span class="cov3" title="4">
                // Process sequence nodes (arrays)
                for _, child := range node.Content </span><span class="cov3" title="5">{
                        if err := convertYAMLNodeTypes(child); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        case yaml.ScalarNode:<span class="cov8" title="69"></span>
                // Scalar nodes are handled by their parent mapping node
                // No additional processing needed here
        }

        <span class="cov9" title="128">return nil</span>
}

// convertScalarNodeType converts a scalar YAML node value based on the field name
func convertScalarNodeType(fieldName string, valueNode *yaml.Node) <span class="cov8" title="69">{
        if valueNode.Kind != yaml.ScalarNode </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="69">originalValue := valueNode.Value

        // Try integer conversion
        if shouldConvertToInteger(fieldName, originalValue) </span><span class="cov5" title="13">{
                if _, err := strconv.Atoi(originalValue); err == nil </span><span class="cov5" title="13">{
                        // Keep the same value but remove quotes by changing the style
                        valueNode.Style = 0 // Plain style (no quotes)
                        // The value stays the same, but YAML will interpret it as an integer
                        return
                }</span>
        }

        // Try boolean conversion
        <span class="cov8" title="56">if shouldConvertToBoolean(originalValue) </span><span class="cov0" title="0">{
                lowerValue := strings.ToLower(originalValue)
                if lowerValue == "true" || lowerValue == "false" </span><span class="cov0" title="0">{
                        valueNode.Value = lowerValue
                        valueNode.Style = 0 // Plain style
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package stack

import (
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/errors"
)

// Application represents a deployable application with a configuration.
type Application struct {
        Name      string
        Namespace string
        Config    ApplicationConfig
}

// ApplicationConfig describes the behaviour of specific application types.
type ApplicationConfig interface {
        Generate(*Application) ([]*client.Object, error)
}

// NewApplication constructs an Application with the provided parameters.
func NewApplication(name, namespace string, cfg ApplicationConfig) *Application <span class="cov10" title="6">{
        return &amp;Application{Name: name, Namespace: namespace, Config: cfg}
}</span>

// SetName updates the application name.
func (a *Application) SetName(name string) <span class="cov1" title="1">{ a.Name = name }</span>

// SetNamespace updates the target namespace.
func (a *Application) SetNamespace(ns string) <span class="cov1" title="1">{ a.Namespace = ns }</span>

// SetConfig replaces the application configuration.
func (a *Application) SetConfig(cfg ApplicationConfig) <span class="cov4" title="2">{ a.Config = cfg }</span>

// Generate returns the resources for this application.
func (a *Application) Generate() ([]*client.Object, error) <span class="cov4" title="2">{
        if a.Config == nil </span><span class="cov1" title="1">{
                return nil, errors.NewValidationError("application.config", "nil", "Required", []string{"non-nil application config"})
        }</span>
        <span class="cov1" title="1">return a.Config.Generate(a)</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package stack

import (
        "fmt"

        "gopkg.in/yaml.v3"

        "github.com/go-kure/kure/internal/gvk"
)

// applicationConfigRegistry is the stack package's registry for ApplicationConfig types
var applicationConfigRegistry = gvk.NewRegistry[ApplicationConfig]()

// RegisterApplicationConfig registers an ApplicationConfig type with the stack registry
func RegisterApplicationConfig(gvk gvk.GVK, factory func() ApplicationConfig) <span class="cov4" title="2">{
        applicationConfigRegistry.Register(gvk, factory)
}</span>

// CreateApplicationConfig creates a new ApplicationConfig instance for the given apiVersion and kind
func CreateApplicationConfig(apiVersion, kind string) (ApplicationConfig, error) <span class="cov9" title="6">{
        parsed := gvk.ParseAPIVersion(apiVersion, kind)
        return applicationConfigRegistry.Create(parsed)
}</span>

// ApplicationWrapper provides type detection and unmarshaling for ApplicationConfig
type ApplicationWrapper struct {
        APIVersion string              `yaml:"apiVersion" json:"apiVersion"`
        Kind       string              `yaml:"kind" json:"kind"`
        Metadata   ApplicationMetadata `yaml:"metadata" json:"metadata"`
        Spec       ApplicationConfig   `yaml:"-" json:"-"`
}

// ApplicationMetadata contains common metadata fields
type ApplicationMetadata struct {
        Name      string            `yaml:"name" json:"name"`
        Namespace string            `yaml:"namespace,omitempty" json:"namespace,omitempty"`
        Labels    map[string]string `yaml:"labels,omitempty" json:"labels,omitempty"`
}

// UnmarshalYAML implements custom YAML unmarshaling with type detection
func (w *ApplicationWrapper) UnmarshalYAML(node *yaml.Node) error <span class="cov10" title="7">{
        // First pass: extract GVK and metadata
        var gvkDetect struct {
                APIVersion string              `yaml:"apiVersion"`
                Kind       string              `yaml:"kind"`
                Metadata   ApplicationMetadata `yaml:"metadata"`
        }
        if err := node.Decode(&amp;gvkDetect); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detect GVK: %w", err)
        }</span>

        <span class="cov10" title="7">if gvkDetect.APIVersion == "" || gvkDetect.Kind == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("apiVersion and kind are required fields")
        }</span>

        // Create appropriate config instance
        <span class="cov9" title="6">config, err := CreateApplicationConfig(gvkDetect.APIVersion, gvkDetect.Kind)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create config for %s/%s: %w",
                        gvkDetect.APIVersion, gvkDetect.Kind, err)
        }</span>

        // Decode full content with spec field
        <span class="cov8" title="5">var raw struct {
                APIVersion string              `yaml:"apiVersion"`
                Kind       string              `yaml:"kind"`
                Metadata   ApplicationMetadata `yaml:"metadata"`
                Spec       yaml.Node           `yaml:"spec"`
        }

        if err := node.Decode(&amp;raw); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode wrapper: %w", err)
        }</span>

        // Decode spec into the specific config type
        <span class="cov8" title="5">if err := raw.Spec.Decode(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode spec for %s/%s: %w",
                        raw.APIVersion, raw.Kind, err)
        }</span>

        <span class="cov8" title="5">w.APIVersion = raw.APIVersion
        w.Kind = raw.Kind
        w.Metadata = raw.Metadata
        w.Spec = config

        // Apply metadata to the config if it supports it
        if named, ok := config.(gvk.NamedType); ok </span><span class="cov8" title="5">{
                named.SetName(w.Metadata.Name)
        }</span>
        <span class="cov8" title="5">if namespaced, ok := config.(gvk.NamespacedType); ok </span><span class="cov8" title="5">{
                namespaced.SetNamespace(w.Metadata.Namespace)
        }</span>

        <span class="cov8" title="5">return nil</span>
}

// MarshalYAML implements custom YAML marshaling
func (w *ApplicationWrapper) MarshalYAML() (interface{}, error) <span class="cov1" title="1">{
        // Create a map representation for clean YAML output
        result := map[string]interface{}{
                "apiVersion": w.APIVersion,
                "kind":       w.Kind,
                "metadata":   w.Metadata,
        }

        if w.Spec != nil </span><span class="cov0" title="0">{
                result["spec"] = w.Spec
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// ToApplication converts the wrapper to a stack.Application
func (w *ApplicationWrapper) ToApplication() *Application <span class="cov6" title="3">{
        return NewApplication(w.Metadata.Name, w.Metadata.Namespace, w.Spec)
}</span>

// ApplicationWrappers is a slice of ApplicationWrapper for unmarshaling multiple configs
type ApplicationWrappers []ApplicationWrapper

// ToApplications converts all wrappers to Applications
func (ws ApplicationWrappers) ToApplications() []*Application <span class="cov1" title="1">{
        apps := make([]*Application, 0, len(ws))
        for _, w := range ws </span><span class="cov4" title="2">{
                apps = append(apps, w.ToApplication())
        }</span>
        <span class="cov1" title="1">return apps</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package argocd

import (
        "fmt"
        "path/filepath"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/layout"
)

// Ensure WorkflowEngine implements the stack.Workflow interface
var _ stack.Workflow = (*WorkflowEngine)(nil)

func init() <span class="cov1" title="1">{
        // Register the ArgoCD workflow factory with the stack package
        stack.RegisterArgoWorkflow(func() stack.Workflow </span><span class="cov0" title="0">{
                return Engine()
        }</span>)
}

// WorkflowEngine implements the stack.Workflow interface for ArgoCD.
type WorkflowEngine struct {
        // RepoURL is used as the source repo for generated Applications
        RepoURL string
        // DefaultNamespace is the default namespace for ArgoCD Applications
        DefaultNamespace string
}

// Engine creates an ArgoCD workflow engine.
func Engine() *WorkflowEngine <span class="cov10" title="26">{
        return &amp;WorkflowEngine{
                RepoURL:          "https://github.com/example/manifests.git",
                DefaultNamespace: "argocd",
        }
}</span>

// ResourceGenerator interface implementation

// GenerateFromCluster creates ArgoCD Applications from a cluster definition.
func (w *WorkflowEngine) GenerateFromCluster(c *stack.Cluster) ([]client.Object, error) <span class="cov4" title="4">{
        if c == nil || c.Node == nil </span><span class="cov2" title="2">{
                return nil, nil
        }</span>
        <span class="cov2" title="2">return w.GenerateFromNode(c.Node)</span>
}

// GenerateFromNode creates ArgoCD Applications from a node and its children.
func (w *WorkflowEngine) GenerateFromNode(n *stack.Node) ([]client.Object, error) <span class="cov6" title="7">{
        if n == nil </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov5" title="6">var objs []client.Object

        // Generate application for this node's bundle
        if n.Bundle != nil </span><span class="cov5" title="6">{
                bundleApps, err := w.GenerateFromBundle(n.Bundle)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="6">objs = append(objs, bundleApps...)</span>
        }

        // Generate applications for child nodes
        <span class="cov5" title="6">for _, child := range n.Children </span><span class="cov2" title="2">{
                childApps, err := w.GenerateFromNode(child)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov2" title="2">objs = append(objs, childApps...)</span>
        }

        <span class="cov5" title="6">return objs, nil</span>
}

// GenerateFromBundle creates an ArgoCD Application from a bundle definition.
func (w *WorkflowEngine) GenerateFromBundle(b *stack.Bundle) ([]client.Object, error) <span class="cov7" title="10">{
        if b == nil </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov7" title="9">app := &amp;unstructured.Unstructured{}
        app.SetAPIVersion("argoproj.io/v1alpha1")
        app.SetKind("Application")
        app.SetName(b.Name)
        app.SetNamespace(w.DefaultNamespace)

        // Set labels if provided
        if len(b.Labels) &gt; 0 </span><span class="cov2" title="2">{
                app.SetLabels(b.Labels)
        }</span>

        // Configure source
        <span class="cov7" title="9">source := map[string]interface{}{
                "repoURL": w.RepoURL,
                "path":    w.bundlePath(b),
        }

        // Configure destination
        dest := map[string]interface{}{
                "server":    "https://kubernetes.default.svc",
                "namespace": "default",
        }

        // Set spec fields
        _ = unstructured.SetNestedField(app.Object, source, "spec", "source")
        _ = unstructured.SetNestedField(app.Object, dest, "spec", "destination")

        // Add dependencies if present
        if len(b.DependsOn) &gt; 0 </span><span class="cov1" title="1">{
                var deps []string
                for _, d := range b.DependsOn </span><span class="cov2" title="2">{
                        deps = append(deps, d.Name)
                }</span>
                <span class="cov1" title="1">_ = unstructured.SetNestedStringSlice(app.Object, deps, "spec", "dependencies")</span>
        }

        <span class="cov7" title="9">var obj client.Object = app
        return []client.Object{obj}, nil</span>
}

// LayoutIntegrator interface implementation

// IntegrateWithLayout adds ArgoCD Applications to an existing manifest layout.
// For ArgoCD, this is typically not needed as Applications reference external repos.
func (w *WorkflowEngine) IntegrateWithLayout(ml *layout.ManifestLayout, c *stack.Cluster, rules layout.LayoutRules) error <span class="cov1" title="1">{
        // ArgoCD Applications typically don't need layout integration
        // as they reference external repositories
        return nil
}</span>

// CreateLayoutWithResources creates a new layout that includes ArgoCD Applications.
func (w *WorkflowEngine) CreateLayoutWithResources(c *stack.Cluster, rulesInterface interface{}) (interface{}, error) <span class="cov2" title="2">{
        rules, ok := rulesInterface.(layout.LayoutRules)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("rules must be of type layout.LayoutRules")
        }</span>
        // Generate the base manifest layout
        <span class="cov1" title="1">ml, err := layout.WalkCluster(c, rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // For ArgoCD, we typically create a separate argocd directory for Applications
        <span class="cov1" title="1">apps, err := w.GenerateFromCluster(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if len(apps) &gt; 0 </span><span class="cov1" title="1">{
                argoCDLayout := &amp;layout.ManifestLayout{
                        Name:      "argocd",
                        Namespace: filepath.Join(ml.Namespace, "argocd"),
                        FilePer:   layout.FilePerResource,
                        Resources: apps,
                }
                ml.Children = append(ml.Children, argoCDLayout)
        }</span>

        <span class="cov1" title="1">return ml, nil</span>
}

// BootstrapGenerator interface implementation

// GenerateBootstrap creates bootstrap resources for setting up ArgoCD.
func (w *WorkflowEngine) GenerateBootstrap(config *stack.BootstrapConfig, rootNode *stack.Node) ([]client.Object, error) <span class="cov4" title="3">{
        if config == nil || !config.Enabled </span><span class="cov2" title="2">{
                return nil, nil
        }</span>

        // Mock implementation - returns empty for now
        // TODO: Implement ArgoCD bootstrap with:
        // - ArgoCD namespace
        // - ArgoCD CRDs and deployment manifests
        // - App-of-apps pattern setup
        // - Root application pointing to the cluster manifests
        <span class="cov1" title="1">return []client.Object{}, nil</span>
}

// SupportedBootstrapModes returns the bootstrap modes supported by ArgoCD.
func (w *WorkflowEngine) SupportedBootstrapModes() []string <span class="cov1" title="1">{
        return []string{"argocd", "app-of-apps"}
}</span>

// WorkflowEngine interface implementation

// GetName returns a human-readable name for this workflow engine.
func (w *WorkflowEngine) GetName() string <span class="cov1" title="1">{
        return "ArgoCD Workflow Engine"
}</span>

// GetVersion returns the version of this workflow engine.
func (w *WorkflowEngine) GetVersion() string <span class="cov1" title="1">{
        return "v1.0.0"
}</span>

// Configuration methods

// SetRepoURL configures the repository URL for generated Applications.
func (w *WorkflowEngine) SetRepoURL(repoURL string) <span class="cov2" title="2">{
        w.RepoURL = repoURL
}</span>

// SetDefaultNamespace configures the default namespace for ArgoCD Applications.
func (w *WorkflowEngine) SetDefaultNamespace(namespace string) <span class="cov2" title="2">{
        w.DefaultNamespace = namespace
}</span>

// bundlePath builds a repository path for the bundle based on its ancestry.
func (w *WorkflowEngine) bundlePath(b *stack.Bundle) string <span class="cov7" title="11">{
        var parts []string
        for p := b; p != nil; p = p.GetParent() </span><span class="cov7" title="11">{
                if p.Name != "" </span><span class="cov7" title="10">{
                        parts = append([]string{p.Name}, parts...)
                }</span>
        }
        <span class="cov7" title="11">return filepath.ToSlash(filepath.Join(parts...))</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package stack

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// FluentBuilder interfaces for method chaining with immutable pattern

// ClusterBuilder provides fluent interface for building Cluster configurations
type ClusterBuilder interface {
        WithNode(name string) NodeBuilder
        WithGitOps(gitops *GitOpsConfig) ClusterBuilder
        Build() *Cluster
}

// NodeBuilder provides fluent interface for building Node configurations
type NodeBuilder interface {
        WithChild(name string) NodeBuilder
        WithBundle(name string) BundleBuilder
        WithPackageRef(ref *schema.GroupVersionKind) NodeBuilder
        End() ClusterBuilder
        Build() *Cluster
}

// BundleBuilder provides fluent interface for building Bundle configurations  
type BundleBuilder interface {
        WithApplication(name string, appConfig ApplicationConfig) BundleBuilder
        WithDependency(bundle *Bundle) BundleBuilder
        WithSourceRef(sourceRef *SourceRef) BundleBuilder
        End() NodeBuilder
        Build() *Cluster
}

// ApplicationConfig is already defined in application.go - using existing interface

// ClusterBuilderImpl implements ClusterBuilder with immutable pattern
type ClusterBuilderImpl struct {
        cluster *Cluster
        errors  []error
}

// NodeBuilderImpl implements NodeBuilder with immutable pattern
type NodeBuilderImpl struct {
        cluster *Cluster
        currentNode *Node
        parentBuilder ClusterBuilder
        errors []error
}

// BundleBuilderImpl implements BundleBuilder with immutable pattern  
type BundleBuilderImpl struct {
        cluster *Cluster
        currentNode *Node
        currentBundle *Bundle
        parentBuilder NodeBuilder
        errors []error
}

// NewClusterBuilder creates a new fluent cluster builder
func NewClusterBuilder(name string) ClusterBuilder <span class="cov7" title="11">{
        cluster := &amp;Cluster{
                Name: name,
        }
        return &amp;ClusterBuilderImpl{
                cluster: cluster,
                errors: []error{},
        }
}</span>

// WithNode adds a child node and returns a NodeBuilder for chaining
func (cb *ClusterBuilderImpl) WithNode(name string) NodeBuilder <span class="cov7" title="11">{
        // Create immutable copy
        newCluster := cb.copyCluster()
        
        node := &amp;Node{
                Name: name,
                Children: []*Node{},
        }
        
        newCluster.Node = node
        
        return &amp;NodeBuilderImpl{
                cluster: newCluster,
                currentNode: node,
                parentBuilder: &amp;ClusterBuilderImpl{cluster: newCluster, errors: cb.errors},
                errors: cb.errors,
        }
}</span>

// WithGitOps sets GitOps configuration
func (cb *ClusterBuilderImpl) WithGitOps(gitops *GitOpsConfig) ClusterBuilder <span class="cov2" title="2">{
        newCluster := cb.copyCluster()
        newCluster.GitOps = gitops
        
        return &amp;ClusterBuilderImpl{
                cluster: newCluster,
                errors: cb.errors,
        }
}</span>

// Build finalizes the cluster construction
func (cb *ClusterBuilderImpl) Build() *Cluster <span class="cov8" title="14">{
        if len(cb.errors) &gt; 0 </span>{<span class="cov0" title="0">
                // In a real implementation, you'd want to handle errors appropriately
                // For now, we'll return the cluster even with errors
        }</span>
        
        // Initialize path maps if we have a root node
        <span class="cov8" title="14">if cb.cluster.Node != nil </span><span class="cov7" title="11">{
                cb.cluster.Node.InitializePathMap()
        }</span>
        
        <span class="cov8" title="14">return cb.cluster</span>
}

// copyCluster creates a deep copy of the cluster
func (cb *ClusterBuilderImpl) copyCluster() *Cluster <span class="cov10" title="24">{
        newCluster := &amp;Cluster{
                Name: cb.cluster.Name,
                GitOps: cb.cluster.GitOps,
        }
        
        if cb.cluster.Node != nil </span><span class="cov7" title="11">{
                newCluster.Node = cb.copyNode(cb.cluster.Node)
        }</span>
        
        <span class="cov10" title="24">return newCluster</span>
}

// copyNode creates a deep copy of a node
func (cb *ClusterBuilderImpl) copyNode(node *Node) *Node <span class="cov8" title="14">{
        newNode := &amp;Node{
                Name: node.Name,
                ParentPath: node.ParentPath,
                PackageRef: node.PackageRef,
        }
        
        if node.Bundle != nil </span><span class="cov4" title="4">{
                newNode.Bundle = cb.copyBundle(node.Bundle)
        }</span>
        
        <span class="cov8" title="14">if node.Children != nil </span><span class="cov8" title="14">{
                newNode.Children = make([]*Node, len(node.Children))
                for i, child := range node.Children </span><span class="cov4" title="3">{
                        newNode.Children[i] = cb.copyNode(child)
                }</span>
        }
        
        <span class="cov8" title="14">return newNode</span>
}

// copyBundle creates a deep copy of a bundle
func (cb *ClusterBuilderImpl) copyBundle(bundle *Bundle) *Bundle <span class="cov4" title="4">{
        newBundle := &amp;Bundle{
                Name: bundle.Name,
                ParentPath: bundle.ParentPath,
                SourceRef: bundle.SourceRef,
        }
        
        if bundle.Applications != nil </span><span class="cov4" title="4">{
                newBundle.Applications = make([]*Application, len(bundle.Applications))
                copy(newBundle.Applications, bundle.Applications)
        }</span>
        
        <span class="cov4" title="4">if bundle.DependsOn != nil </span><span class="cov4" title="4">{
                newBundle.DependsOn = make([]*Bundle, len(bundle.DependsOn))
                copy(newBundle.DependsOn, bundle.DependsOn)
        }</span>
        
        <span class="cov4" title="4">return newBundle</span>
}

// NodeBuilder implementation

// WithChild adds a child node
func (nb *NodeBuilderImpl) WithChild(name string) NodeBuilder <span class="cov4" title="3">{
        newCluster := nb.copyClusterFromNode()
        
        // Create the child with proper parent path
        parentPath := nb.currentNode.GetPath()
        childNode := &amp;Node{
                Name: name,
                ParentPath: parentPath,
                Children: []*Node{},
        }
        
        // Find the current node in the new cluster and add child
        if newCluster.Node != nil </span><span class="cov4" title="3">{
                currentNodeInCopy := nb.findNodeByPath(newCluster.Node, parentPath)
                if currentNodeInCopy != nil </span><span class="cov4" title="3">{
                        currentNodeInCopy.Children = append(currentNodeInCopy.Children, childNode)
                }</span>
        }
        
        <span class="cov4" title="3">return &amp;NodeBuilderImpl{
                cluster: newCluster,
                currentNode: childNode,
                parentBuilder: &amp;ClusterBuilderImpl{cluster: newCluster, errors: nb.errors},
                errors: nb.errors,
        }</span>
}

// WithBundle adds a bundle to the current node
func (nb *NodeBuilderImpl) WithBundle(name string) BundleBuilder <span class="cov4" title="3">{
        newCluster := nb.copyClusterFromNode()
        
        bundle := &amp;Bundle{
                Name: name,
                ParentPath: nb.currentNode.GetPath(),
                Applications: []*Application{},
                DependsOn: []*Bundle{},
        }
        
        // Find the current node in the new cluster and set bundle
        if newCluster.Node != nil </span><span class="cov4" title="3">{
                currentNodeInCopy := nb.findNodeByPath(newCluster.Node, nb.currentNode.GetPath())
                if currentNodeInCopy != nil </span><span class="cov4" title="3">{
                        currentNodeInCopy.Bundle = bundle
                }</span>
        }
        
        // Find the current node in the new cluster to keep references consistent
        <span class="cov4" title="3">currentNodeInCopy := nb.findNodeByPath(newCluster.Node, nb.currentNode.GetPath())
        
        return &amp;BundleBuilderImpl{
                cluster: newCluster,
                currentNode: currentNodeInCopy, // Use the node from the new cluster
                currentBundle: bundle,
                parentBuilder: &amp;NodeBuilderImpl{
                        cluster: newCluster,
                        currentNode: currentNodeInCopy, // Use the node from the new cluster
                        parentBuilder: &amp;ClusterBuilderImpl{cluster: newCluster, errors: nb.errors},
                        errors: nb.errors,
                },
                errors: nb.errors,
        }</span>
}

// WithPackageRef sets the package reference
func (nb *NodeBuilderImpl) WithPackageRef(ref *schema.GroupVersionKind) NodeBuilder <span class="cov1" title="1">{
        newCluster := nb.copyClusterFromNode()
        
        // Find the current node in the new cluster and set package ref
        if newCluster.Node != nil </span><span class="cov1" title="1">{
                currentNodeInCopy := nb.findNodeByPath(newCluster.Node, nb.currentNode.GetPath())
                if currentNodeInCopy != nil </span><span class="cov1" title="1">{
                        currentNodeInCopy.PackageRef = ref
                }</span>
        }
        
        <span class="cov1" title="1">return &amp;NodeBuilderImpl{
                cluster: newCluster,
                currentNode: nb.currentNode,
                parentBuilder: &amp;ClusterBuilderImpl{cluster: newCluster, errors: nb.errors},
                errors: nb.errors,
        }</span>
}

// End returns to the parent ClusterBuilder
func (nb *NodeBuilderImpl) End() ClusterBuilder <span class="cov7" title="9">{
        // Return a parent builder with the updated cluster state
        return &amp;ClusterBuilderImpl{
                cluster: nb.cluster,
                errors: nb.errors,
        }
}</span>

// Build finalizes the cluster construction
func (nb *NodeBuilderImpl) Build() *Cluster <span class="cov2" title="2">{
        // Use the updated cluster state
        clusterBuilder := &amp;ClusterBuilderImpl{cluster: nb.cluster, errors: nb.errors}
        return clusterBuilder.Build()
}</span>

// Helper methods for NodeBuilder

func (nb *NodeBuilderImpl) copyClusterFromNode() *Cluster <span class="cov6" title="7">{
        cb := &amp;ClusterBuilderImpl{cluster: nb.cluster, errors: nb.errors}
        return cb.copyCluster()
}</span>

func (nb *NodeBuilderImpl) findNodeByPath(root *Node, path string) *Node <span class="cov8" title="12">{
        if root.GetPath() == path </span><span class="cov7" title="10">{
                return root
        }</span>
        
        <span class="cov2" title="2">for _, child := range root.Children </span><span class="cov2" title="2">{
                if found := nb.findNodeByPath(child, path); found != nil </span><span class="cov2" title="2">{
                        return found
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// BundleBuilder implementation

// WithApplication adds an application to the bundle
func (bb *BundleBuilderImpl) WithApplication(name string, appConfig ApplicationConfig) BundleBuilder <span class="cov2" title="2">{
        // Create deep copy of cluster
        newCluster := bb.copyClusterFromBundle()
        
        // Create the application
        app := &amp;Application{
                Name: name,
                Config: appConfig,
        }
        
        // Create new bundle with the application added
        newCurrentBundle := &amp;Bundle{
                Name: bb.currentBundle.Name,
                ParentPath: bb.currentBundle.ParentPath,
                SourceRef: bb.currentBundle.SourceRef,
                Applications: make([]*Application, 0, len(bb.currentBundle.Applications)+1),
                DependsOn: bb.currentBundle.DependsOn,
        }
        
        // Copy existing applications and add the new one
        copy(newCurrentBundle.Applications, bb.currentBundle.Applications)
        newCurrentBundle.Applications = append(newCurrentBundle.Applications, app)
        
        // Update the bundle in the cluster
        if newCluster.Node != nil </span><span class="cov2" title="2">{
                targetPath := bb.currentNode.GetPath()
                currentNodeInCopy := bb.findNodeByPath(newCluster.Node, targetPath)
                if currentNodeInCopy != nil </span><span class="cov2" title="2">{
                        currentNodeInCopy.Bundle = newCurrentBundle
                }</span>
        }
        
        <span class="cov2" title="2">return &amp;BundleBuilderImpl{
                cluster: newCluster,
                currentNode: bb.currentNode,
                currentBundle: newCurrentBundle,
                parentBuilder: bb.parentBuilder,
                errors: bb.errors,
        }</span>
}

// WithDependency adds a bundle dependency
func (bb *BundleBuilderImpl) WithDependency(bundle *Bundle) BundleBuilder <span class="cov0" title="0">{
        newCluster := bb.copyClusterFromBundle()
        
        // Find the current bundle in the new cluster and add dependency
        if newCluster.Node != nil </span><span class="cov0" title="0">{
                currentNodeInCopy := bb.findNodeByPath(newCluster.Node, bb.currentNode.GetPath())
                if currentNodeInCopy != nil &amp;&amp; currentNodeInCopy.Bundle != nil </span><span class="cov0" title="0">{
                        currentNodeInCopy.Bundle.DependsOn = append(currentNodeInCopy.Bundle.DependsOn, bundle)
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;BundleBuilderImpl{
                cluster: newCluster,
                currentNode: bb.currentNode,
                currentBundle: bb.currentBundle,
                parentBuilder: bb.parentBuilder,
                errors: bb.errors,
        }</span>
}

// WithSourceRef sets the source reference
func (bb *BundleBuilderImpl) WithSourceRef(sourceRef *SourceRef) BundleBuilder <span class="cov2" title="2">{
        // Create deep copy of cluster
        newCluster := bb.copyClusterFromBundle()
        
        // Create new bundle with the source ref set
        newCurrentBundle := &amp;Bundle{
                Name: bb.currentBundle.Name,
                ParentPath: bb.currentBundle.ParentPath,
                SourceRef: sourceRef,  // Set the new source ref
                Applications: bb.currentBundle.Applications,
                DependsOn: bb.currentBundle.DependsOn,
        }
        
        // Update the bundle in the cluster
        if newCluster.Node != nil </span><span class="cov2" title="2">{
                targetPath := bb.currentNode.GetPath()
                currentNodeInCopy := bb.findNodeByPath(newCluster.Node, targetPath)
                if currentNodeInCopy != nil </span><span class="cov2" title="2">{
                        currentNodeInCopy.Bundle = newCurrentBundle
                }</span>
        }
        
        <span class="cov2" title="2">return &amp;BundleBuilderImpl{
                cluster: newCluster,
                currentNode: bb.currentNode,
                currentBundle: newCurrentBundle,
                parentBuilder: bb.parentBuilder,
                errors: bb.errors,
        }</span>
}

// End returns to the parent NodeBuilder
func (bb *BundleBuilderImpl) End() NodeBuilder <span class="cov4" title="3">{
        // Return a parent builder with the updated cluster state
        return &amp;NodeBuilderImpl{
                cluster: bb.cluster,
                currentNode: bb.currentNode,
                parentBuilder: &amp;ClusterBuilderImpl{cluster: bb.cluster, errors: bb.errors},
                errors: bb.errors,
        }
}</span>

// Build finalizes the cluster construction
func (bb *BundleBuilderImpl) Build() *Cluster <span class="cov0" title="0">{
        // Use the updated cluster state
        clusterBuilder := &amp;ClusterBuilderImpl{cluster: bb.cluster, errors: bb.errors}
        return clusterBuilder.Build()
}</span>

// Helper methods for BundleBuilder

func (bb *BundleBuilderImpl) copyClusterFromBundle() *Cluster <span class="cov4" title="4">{
        cb := &amp;ClusterBuilderImpl{cluster: bb.cluster, errors: bb.errors}
        return cb.copyCluster()
}</span>

func (bb *BundleBuilderImpl) findNodeByPath(root *Node, path string) *Node <span class="cov6" title="6">{
        if root.GetPath() == path </span><span class="cov4" title="4">{
                return root
        }</span>
        
        <span class="cov2" title="2">for _, child := range root.Children </span><span class="cov2" title="2">{
                if found := bb.findNodeByPath(child, path); found != nil </span><span class="cov2" title="2">{
                        return found
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file98" style="display: none">package stack

import (
        "fmt"

        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/errors"
)

// Bundle represents a unit of deployment, typically the resources that
// are reconciled by a single Flux Kustomization.
type Bundle struct {
        // Name identifies the application set.
        Name string
        // ParentPath is the hierarchical path to the parent bundle (e.g., "cluster/infrastructure")
        // Empty for root bundles. This avoids circular references while maintaining hierarchy.
        ParentPath string
        // DependsOn lists other bundles this bundle depends on
        DependsOn []*Bundle
        // Interval controls how often Flux reconciles the bundle.
        Interval string
        // SourceRef specifies the source for the bundle.
        SourceRef *SourceRef
        // Applications holds the Kubernetes objects that belong to the application.
        Applications []*Application
        // Labels are common labels that should be applied to each resource.
        Labels map[string]string

        // Internal fields for runtime hierarchy navigation (not serialized)
        parent  *Bundle            `yaml:"-"` // Runtime parent reference for efficient traversal
        pathMap map[string]*Bundle `yaml:"-"` // Runtime path lookup map (shared across tree)
}

// SourceRef defines a reference to a Flux source.
type SourceRef struct {
        Kind      string
        Name      string
        Namespace string
}

// NewBundle constructs a Bundle with the given name, resources and labels.
// It returns an error if validation fails.
func NewBundle(name string, resources []*Application, labels map[string]string) (*Bundle, error) <span class="cov0" title="0">{
        a := &amp;Bundle{Name: name, Applications: resources, Labels: labels}
        if err := a.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return a, nil</span>
}

// Validate performs basic sanity checks on the Bundle.
func (a *Bundle) Validate() error <span class="cov10" title="4">{
        if a == nil </span><span class="cov1" title="1">{
                return errors.ErrNilBundle
        }</span>
        <span class="cov8" title="3">if a.Name == "" </span><span class="cov1" title="1">{
                return errors.NewValidationError("name", "", "Bundle", nil)
        }</span>
        <span class="cov5" title="2">for i, r := range a.Applications </span><span class="cov5" title="2">{
                if r == nil </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Bundle", a.Name, "applications", fmt.Sprintf("application at index %d is nil", i), nil)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (a *Bundle) Generate() ([]*client.Object, error) <span class="cov0" title="0">{
        var resources []*client.Object
        for _, app := range a.Applications </span><span class="cov0" title="0">{
                addresources, err := app.Generate()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">resources = append(resources, addresources...)</span>
        }
        <span class="cov0" title="0">return resources, nil</span>
}

// GetParent returns the runtime parent reference (may be nil).
func (b *Bundle) GetParent() *Bundle <span class="cov10" title="4">{
        return b.parent
}</span>

// GetParentPath returns the hierarchical path to the parent bundle.
func (b *Bundle) GetParentPath() string <span class="cov0" title="0">{
        return b.ParentPath
}</span>

// SetParent sets the parent bundle and updates the ParentPath accordingly.
// This method maintains both the serializable path and runtime reference.
func (b *Bundle) SetParent(parent *Bundle) <span class="cov0" title="0">{
        b.parent = parent
        if parent == nil </span><span class="cov0" title="0">{
                b.ParentPath = ""
        }</span> else<span class="cov0" title="0"> {
                b.ParentPath = parent.GetPath()
        }</span>
}

// GetPath returns the full hierarchical path of this bundle.
func (b *Bundle) GetPath() string <span class="cov0" title="0">{
        if b.ParentPath == "" </span><span class="cov0" title="0">{
                return b.Name
        }</span>
        <span class="cov0" title="0">return b.ParentPath + "/" + b.Name</span>
}

// InitializePathMap builds the runtime path lookup map for efficient hierarchy navigation.
// This should be called on the root bundle after the tree structure is complete.
func (b *Bundle) InitializePathMap(allBundles []*Bundle) <span class="cov0" title="0">{
        pathMap := make(map[string]*Bundle)

        // Build path map for all bundles
        for _, bundle := range allBundles </span><span class="cov0" title="0">{
                if bundle.Name != "" </span><span class="cov0" title="0">{
                        pathMap[bundle.GetPath()] = bundle
                }</span>
        }

        // Set path map and parent references on all bundles
        <span class="cov0" title="0">for _, bundle := range allBundles </span><span class="cov0" title="0">{
                bundle.pathMap = pathMap
                if bundle.ParentPath != "" </span><span class="cov0" title="0">{
                        if parent, exists := pathMap[bundle.ParentPath]; exists </span><span class="cov0" title="0">{
                                bundle.parent = parent
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package stack

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Cluster describes a cluster configuration.
// A cluster configuration is a set of configurations that are packaged in one or more package units
type Cluster struct {
        Name   string        `yaml:"name"`
        Node   *Node         `yaml:"node,omitempty"`
        GitOps *GitOpsConfig `yaml:"gitops,omitempty"`
}

// GitOpsConfig defines the GitOps tool configuration for the cluster
type GitOpsConfig struct {
        Type      string           `yaml:"type"` // "flux" or "argocd"
        Bootstrap *BootstrapConfig `yaml:"bootstrap,omitempty"`
}

// BootstrapConfig defines the bootstrap configuration for GitOps tools
type BootstrapConfig struct {
        // Common fields
        Enabled bool `yaml:"enabled"`

        // Flux-specific
        FluxMode        string   `yaml:"fluxMode,omitempty"` // "gitops-toolkit" or "flux-operator"
        FluxVersion     string   `yaml:"fluxVersion,omitempty"`
        Components      []string `yaml:"components,omitempty"`
        Registry        string   `yaml:"registry,omitempty"`
        ImagePullSecret string   `yaml:"imagePullSecret,omitempty"`

        // Source configuration
        SourceURL string `yaml:"sourceURL,omitempty"` // OCI/Git repository URL
        SourceRef string `yaml:"sourceRef,omitempty"` // Tag/branch/ref

        // ArgoCD-specific (mock for now)
        ArgoCDVersion   string `yaml:"argoCDVersion,omitempty"`
        ArgoCDNamespace string `yaml:"argoCDNamespace,omitempty"`
}

// Node represents a hierarchic structure holding all deployment bundles
// each tree has a list of children, which can be a deployment, or a subtree
// It could match a kubernetes cluster's full configuration, or it could be just
// a part of that, when parts are e.g. packaged in different OCI artifacts
// Tree's with a common PackageRef are packaged together
type Node struct {
        // Name identifies the application set.
        Name string `yaml:"name"`
        // ParentPath is the hierarchical path to the parent node (e.g., "cluster/infrastructure")
        // Empty for root nodes. This avoids circular references while maintaining hierarchy.
        ParentPath string `yaml:"parentPath,omitempty"`
        // Children list child bundles
        Children []*Node `yaml:"children,omitempty"`
        // PackageRef identifies in which package the tree of resources get bundled together
        // If undefined, the PackageRef of the parent is inherited
        PackageRef *schema.GroupVersionKind `yaml:"packageref,omitempty"`
        // Bundle holds the applications that get deployed on this level
        Bundle *Bundle `yaml:"bundle,omitempty"`

        // Internal fields for runtime hierarchy navigation (not serialized)
        parent  *Node            `yaml:"-"` // Runtime parent reference for efficient traversal
        pathMap map[string]*Node `yaml:"-"` // Runtime path lookup map (shared across tree)
}

// NewCluster creates a Cluster with the provided metadata.
func NewCluster(name string, tree *Node) *Cluster <span class="cov0" title="0">{
        return &amp;Cluster{Name: name, Node: tree}
}</span>

// GetName Helper getters.
func (c *Cluster) GetName() string          <span class="cov0" title="0">{ return c.Name }</span>
func (c *Cluster) GetNode() *Node           <span class="cov0" title="0">{ return c.Node }</span>
func (c *Cluster) GetGitOps() *GitOpsConfig <span class="cov0" title="0">{ return c.GitOps }</span>

// SetName Setters for metadata fields.
func (c *Cluster) SetName(n string)          <span class="cov0" title="0">{ c.Name = n }</span>
func (c *Cluster) SetNode(t *Node)           <span class="cov0" title="0">{ c.Node = t }</span>
func (c *Cluster) SetGitOps(g *GitOpsConfig) <span class="cov0" title="0">{ c.GitOps = g }</span>

func (n *Node) GetName() string                         <span class="cov0" title="0">{ return n.Name }</span>
func (n *Node) GetParent() *Node                        <span class="cov0" title="0">{ return n.parent }</span>
func (n *Node) GetParentPath() string                   <span class="cov0" title="0">{ return n.ParentPath }</span>
func (n *Node) GetChildren() []*Node                    <span class="cov0" title="0">{ return n.Children }</span>
func (n *Node) GetPackageRef() *schema.GroupVersionKind <span class="cov0" title="0">{ return n.PackageRef }</span>
func (n *Node) GetBundle() *Bundle                      <span class="cov0" title="0">{ return n.Bundle }</span>

func (n *Node) SetName(name string)                        <span class="cov0" title="0">{ n.Name = name }</span>
func (n *Node) SetParentPath(path string)                  <span class="cov0" title="0">{ n.ParentPath = path }</span>
func (n *Node) SetChildren(children []*Node)               <span class="cov0" title="0">{ n.Children = children }</span>
func (n *Node) SetPackageRef(ref *schema.GroupVersionKind) <span class="cov0" title="0">{ n.PackageRef = ref }</span>
func (n *Node) SetBundle(bundle *Bundle)                   <span class="cov0" title="0">{ n.Bundle = bundle }</span>

// SetParent sets the parent node and updates the ParentPath accordingly.
// This method maintains both the serializable path and runtime reference.
func (n *Node) SetParent(parent *Node) <span class="cov0" title="0">{
        n.parent = parent
        if parent == nil </span><span class="cov0" title="0">{
                n.ParentPath = ""
        }</span> else<span class="cov0" title="0"> {
                n.ParentPath = parent.GetPath()
        }</span>
}

// GetPath returns the full hierarchical path of this node.
func (n *Node) GetPath() string <span class="cov10" title="36">{
        if n.ParentPath == "" </span><span class="cov9" title="26">{
                return n.Name
        }</span>
        <span class="cov6" title="10">return n.ParentPath + "/" + n.Name</span>
}

// InitializePathMap builds the runtime path lookup map for efficient hierarchy navigation.
// This should be called on the root node after the tree structure is complete.
func (n *Node) InitializePathMap() <span class="cov7" title="11">{
        pathMap := make(map[string]*Node)
        n.buildPathMap(pathMap, "")
        n.setPathMapRecursive(pathMap)
}</span>

// buildPathMap recursively builds the path to node mapping.
func (n *Node) buildPathMap(pathMap map[string]*Node, parentPath string) <span class="cov7" title="14">{
        currentPath := n.Name
        if parentPath != "" </span><span class="cov3" title="3">{
                currentPath = parentPath + "/" + n.Name
        }</span>

        <span class="cov7" title="14">pathMap[currentPath] = n

        for _, child := range n.Children </span><span class="cov3" title="3">{
                child.buildPathMap(pathMap, currentPath)
        }</span>
}

// setPathMapRecursive sets the path map reference on all nodes in the tree.
func (n *Node) setPathMapRecursive(pathMap map[string]*Node) <span class="cov7" title="14">{
        n.pathMap = pathMap

        // Set parent runtime reference from path
        if n.ParentPath != "" </span><span class="cov3" title="3">{
                if parent, exists := pathMap[n.ParentPath]; exists </span><span class="cov3" title="3">{
                        n.parent = parent
                }</span>
        }

        <span class="cov7" title="14">for _, child := range n.Children </span><span class="cov3" title="3">{
                child.setPathMapRecursive(pathMap)
        }</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package fluxcd

import (
        "fmt"
        "path/filepath"
        "time"

        fluxv1 "github.com/controlplaneio-fluxcd/flux-operator/api/v1"
        "github.com/fluxcd/flux2/v2/pkg/manifestgen/install"
        kustv1 "github.com/fluxcd/kustomize-controller/api/v1"
        sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        intfluxcd "github.com/go-kure/kure/internal/fluxcd"
        "github.com/go-kure/kure/pkg/errors"
        kio "github.com/go-kure/kure/pkg/io"
        "github.com/go-kure/kure/pkg/stack"
)

// BootstrapGenerator implements the workflow.BootstrapGenerator interface for Flux.
// It handles the generation of bootstrap resources for setting up Flux.
type BootstrapGenerator struct {
        // DefaultNamespace is the namespace where bootstrap resources are created
        DefaultNamespace string
        // DefaultInterval is the default reconciliation interval
        DefaultInterval time.Duration
}

// NewBootstrapGenerator creates a FluxCD bootstrap generator.
func NewBootstrapGenerator() *BootstrapGenerator <span class="cov10" title="2">{
        return &amp;BootstrapGenerator{
                DefaultNamespace: "flux-system",
                DefaultInterval:  10 * time.Minute,
        }
}</span>

// GenerateBootstrap creates bootstrap resources for setting up Flux.
func (bg *BootstrapGenerator) GenerateBootstrap(config *stack.BootstrapConfig, rootNode *stack.Node) ([]client.Object, error) <span class="cov0" title="0">{
        if config == nil || !config.Enabled </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">switch config.FluxMode </span>{
        case "gotk":<span class="cov0" title="0">
                return bg.generateGotkBootstrap(config, rootNode)</span>
        case "flux-operator":<span class="cov0" title="0">
                return bg.generateFluxOperatorBootstrap(config, rootNode)</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewValidationError("fluxMode", config.FluxMode, "BootstrapConfig",
                        []string{"gotk", "flux-operator"})</span>
        }
}

// SupportedBootstrapModes returns the bootstrap modes supported by this generator.
func (bg *BootstrapGenerator) SupportedBootstrapModes() []string <span class="cov0" title="0">{
        return []string{"gotk", "flux-operator"}
}</span>

// generateGotkBootstrap generates bootstrap resources using the standard Flux toolkit.
func (bg *BootstrapGenerator) generateGotkBootstrap(config *stack.BootstrapConfig, rootNode *stack.Node) ([]client.Object, error) <span class="cov0" title="0">{
        var resources []client.Object

        // Generate core Flux components
        gotkResources, err := bg.generateGotkComponents(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.ResourceValidationError("BootstrapConfig", "gotk", "components",
                        fmt.Sprintf("failed to generate gotk components: %v", err), err)
        }</span>
        <span class="cov0" title="0">resources = append(resources, gotkResources...)

        // Generate flux-system Kustomization
        fluxSystemKust := bg.generateFluxSystemKustomization(rootNode)
        resources = append(resources, fluxSystemKust)

        // Generate OCI source for the root node
        if config.SourceURL != "" </span><span class="cov0" title="0">{
                source := bg.generateOCISource(config, rootNode)
                if source != nil </span><span class="cov0" title="0">{
                        resources = append(resources, source)
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// generateFluxOperatorBootstrap generates bootstrap resources using the Flux Operator.
func (bg *BootstrapGenerator) generateFluxOperatorBootstrap(config *stack.BootstrapConfig, rootNode *stack.Node) ([]client.Object, error) <span class="cov0" title="0">{
        // Generate FluxInstance resource
        fluxInstance := bg.generateFluxInstance(config, rootNode)

        return []client.Object{fluxInstance}, nil
}</span>

// generateGotkComponents generates the standard Flux toolkit components.
func (bg *BootstrapGenerator) generateGotkComponents(config *stack.BootstrapConfig) ([]client.Object, error) <span class="cov0" title="0">{
        // Create install options with defaults
        opts := install.MakeDefaultOptions()

        // Set version if specified
        if config.FluxVersion != "" </span><span class="cov0" title="0">{
                opts.Version = config.FluxVersion
        }</span>

        // Set registry if specified
        <span class="cov0" title="0">if config.Registry != "" </span><span class="cov0" title="0">{
                opts.Registry = config.Registry
        }</span>

        // Set image pull secret if specified
        <span class="cov0" title="0">if config.ImagePullSecret != "" </span><span class="cov0" title="0">{
                opts.ImagePullSecret = config.ImagePullSecret
        }</span>

        // Set components if specified
        <span class="cov0" title="0">if len(config.Components) &gt; 0 </span><span class="cov0" title="0">{
                opts.Components = config.Components
        }</span>

        // Generate manifests
        <span class="cov0" title="0">content, err := install.Generate(opts, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.ResourceValidationError("BootstrapConfig", "gotk", "install",
                        fmt.Sprintf("failed to generate Flux installation manifests: %v", err), err)
        }</span>

        // Parse the generated manifests
        <span class="cov0" title="0">objects, err := kio.ParseYAML([]byte(content.Content))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewParseError("gotk manifests", "failed to parse generated manifests", 0, 0, err)
        }</span>

        <span class="cov0" title="0">return objects, nil</span>
}

// generateFluxSystemKustomization creates a Kustomization for the flux-system.
func (bg *BootstrapGenerator) generateFluxSystemKustomization(rootNode *stack.Node) client.Object <span class="cov0" title="0">{
        kust := &amp;kustv1.Kustomization{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: kustv1.GroupVersion.String(),
                        Kind:       "Kustomization",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      "flux-system",
                        Namespace: bg.DefaultNamespace,
                },
                Spec: kustv1.KustomizationSpec{
                        Interval: metav1.Duration{Duration: bg.DefaultInterval},
                        Path:     filepath.ToSlash(filepath.Join("manifests", rootNode.Name)),
                        Prune:    true,
                        SourceRef: kustv1.CrossNamespaceSourceReference{
                                Kind: "GitRepository",
                                Name: "flux-system",
                        },
                },
        }

        return kust
}</span>

// generateOCISource creates an OCI source for bootstrap from config.
func (bg *BootstrapGenerator) generateOCISource(config *stack.BootstrapConfig, rootNode *stack.Node) client.Object <span class="cov0" title="0">{
        // Default values
        url := "oci://registry.example.com/flux-system"
        ref := "latest"
        sourceName := "flux-system"

        // Use configuration from BootstrapConfig if available
        if config.SourceURL != "" </span><span class="cov0" title="0">{
                url = config.SourceURL
        }</span>
        <span class="cov0" title="0">if config.SourceRef != "" </span><span class="cov0" title="0">{
                ref = config.SourceRef
        }</span>

        // Create source name based on node
        <span class="cov0" title="0">if rootNode != nil &amp;&amp; rootNode.Name != "" </span><span class="cov0" title="0">{
                sourceName = rootNode.Name
        }</span>

        <span class="cov0" title="0">spec := sourcev1beta2.OCIRepositorySpec{
                URL:      url,
                Interval: metav1.Duration{Duration: bg.DefaultInterval},
                Reference: &amp;sourcev1beta2.OCIRepositoryRef{
                        Tag: ref,
                },
        }

        return intfluxcd.CreateOCIRepository(sourceName, bg.DefaultNamespace, spec)</span>
}

// generateFluxInstance creates a FluxInstance for flux-operator mode.
func (bg *BootstrapGenerator) generateFluxInstance(config *stack.BootstrapConfig, rootNode *stack.Node) client.Object <span class="cov0" title="0">{
        spec := fluxv1.FluxInstanceSpec{
                Distribution: fluxv1.Distribution{
                        Version:  config.FluxVersion,
                        Registry: config.Registry,
                },
        }

        // Add components if specified
        for _, comp := range config.Components </span><span class="cov0" title="0">{
                spec.Components = append(spec.Components, fluxv1.Component(comp))
        }</span>

        // Add sync configuration if source is provided
        <span class="cov0" title="0">if config.SourceURL != "" </span><span class="cov0" title="0">{
                path := "./"
                if rootNode != nil &amp;&amp; rootNode.Name != "" </span><span class="cov0" title="0">{
                        path = "./" + rootNode.Name
                }</span>

                <span class="cov0" title="0">spec.Sync = &amp;fluxv1.Sync{
                        Kind:     "OCIRepository",
                        URL:      config.SourceURL,
                        Ref:      config.SourceRef,
                        Path:     path,
                        Interval: &amp;metav1.Duration{Duration: bg.DefaultInterval},
                }</span>
        }

        <span class="cov0" title="0">return intfluxcd.CreateFluxInstance("flux-system", bg.DefaultNamespace, spec)</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package fluxcd

import (
        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/layout"
)

func init() <span class="cov8" title="1">{
        // Register the Flux workflow factory with the stack package
        stack.RegisterFluxWorkflow(func() stack.Workflow </span><span class="cov0" title="0">{
                return Engine()
        }</span>)
}

// Engine returns a WorkflowEngine initialized with defaults.
// This is the primary entry point for FluxCD workflow functionality.
func Engine() *WorkflowEngine <span class="cov8" title="1">{
        return NewWorkflowEngine()
}</span>

// EngineWithMode returns a WorkflowEngine with a specific kustomization mode.
func EngineWithMode(mode layout.KustomizationMode) *WorkflowEngine <span class="cov8" title="1">{
        engine := NewWorkflowEngine()
        engine.SetKustomizationMode(mode)
        return engine
}</span>

// EngineWithConfig returns a WorkflowEngine with custom configuration.
func EngineWithConfig(mode layout.KustomizationMode, placement layout.FluxPlacement) *WorkflowEngine <span class="cov0" title="0">{
        return NewWorkflowEngineWithConfig(mode, placement)
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">package fluxcd

import (
        "fmt"
        "path/filepath"

        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/layout"
)

// LayoutIntegrator implements the workflow.LayoutIntegrator interface for Flux.
// It handles integration of Flux resources with manifest layouts.
type LayoutIntegrator struct {
        // ResourceGenerator generates the Flux resources
        Generator *ResourceGenerator
        // FluxPlacement controls where Flux resources are placed in the layout
        FluxPlacement layout.FluxPlacement
}

// NewLayoutIntegrator creates a FluxCD layout integrator.
func NewLayoutIntegrator(generator *ResourceGenerator) *LayoutIntegrator <span class="cov10" title="2">{
        return &amp;LayoutIntegrator{
                Generator:     generator,
                FluxPlacement: layout.FluxIntegrated,
        }
}</span>

// IntegrateWithLayout adds Flux resources to an existing manifest layout.
func (li *LayoutIntegrator) IntegrateWithLayout(ml *layout.ManifestLayout, c *stack.Cluster, rules layout.LayoutRules) error <span class="cov0" title="0">{
        if ml == nil || c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch li.FluxPlacement </span>{
        case layout.FluxIntegrated:<span class="cov0" title="0">
                return li.addIntegratedFluxToLayout(ml, c, rules)</span>
        case layout.FluxSeparate:<span class="cov0" title="0">
                return li.addSeparateFluxToLayout(ml, c, rules)</span>
        default:<span class="cov0" title="0">
                return errors.NewValidationError("fluxPlacement", string(li.FluxPlacement), "LayoutIntegrator",
                        []string{string(layout.FluxIntegrated), string(layout.FluxSeparate)})</span>
        }
}

// CreateLayoutWithResources creates a new layout that includes Flux resources.
func (li *LayoutIntegrator) CreateLayoutWithResources(c *stack.Cluster, rules layout.LayoutRules) (*layout.ManifestLayout, error) <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Generate the base manifest layout first
        <span class="cov0" title="0">ml, err := layout.WalkCluster(c, rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.ResourceValidationError("Cluster", c.Name, "layout",
                        fmt.Sprintf("failed to create base layout: %v", err), err)
        }</span>

        // Integrate Flux resources into the layout
        <span class="cov0" title="0">if err := li.IntegrateWithLayout(ml, c, rules); err != nil </span><span class="cov0" title="0">{
                return nil, errors.ResourceValidationError("Cluster", c.Name, "flux-integration",
                        fmt.Sprintf("failed to integrate Flux resources: %v", err), err)
        }</span>

        <span class="cov0" title="0">return ml, nil</span>
}

// addIntegratedFluxToLayout places Flux Kustomizations alongside their target manifests.
func (li *LayoutIntegrator) addIntegratedFluxToLayout(ml *layout.ManifestLayout, c *stack.Cluster, rules layout.LayoutRules) error <span class="cov0" title="0">{
        return li.processNodeForIntegratedFlux(ml, c.Node, c.Name)
}</span>

// processNodeForIntegratedFlux recursively processes nodes to add integrated Flux resources.
func (li *LayoutIntegrator) processNodeForIntegratedFlux(ml *layout.ManifestLayout, node *stack.Node, clusterName string) error <span class="cov0" title="0">{
        // Find the corresponding layout node
        layoutNode := li.findLayoutNode(ml, node)
        if layoutNode == nil </span><span class="cov0" title="0">{
                return errors.ResourceValidationError("Node", node.Name, "layout",
                        "corresponding layout node not found", nil)
        }</span>

        // Generate Flux resources for this node
        <span class="cov0" title="0">if node.Bundle != nil </span><span class="cov0" title="0">{
                fluxResources, err := li.Generator.GenerateFromBundle(node.Bundle)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.ResourceValidationError("Node", node.Name, "flux-resources",
                                fmt.Sprintf("failed to generate Flux resources: %v", err), err)
                }</span>

                // Add Flux resources to the layout node
                <span class="cov0" title="0">layoutNode.Resources = append(layoutNode.Resources, fluxResources...)</span>
        }

        // Process child nodes
        <span class="cov0" title="0">for _, child := range node.Children </span><span class="cov0" title="0">{
                if err := li.processNodeForIntegratedFlux(layoutNode, child, clusterName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// addSeparateFluxToLayout creates a separate flux-system directory for Flux resources.
func (li *LayoutIntegrator) addSeparateFluxToLayout(ml *layout.ManifestLayout, c *stack.Cluster, rules layout.LayoutRules) error <span class="cov0" title="0">{
        // Generate all Flux resources for the cluster
        fluxResources, err := li.Generator.GenerateFromCluster(c)
        if err != nil </span><span class="cov0" title="0">{
                return errors.ResourceValidationError("Cluster", c.Name, "flux-resources",
                        fmt.Sprintf("failed to generate Flux resources: %v", err), err)
        }</span>

        <span class="cov0" title="0">if len(fluxResources) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create a separate flux-system layout
        <span class="cov0" title="0">fluxLayout := &amp;layout.ManifestLayout{
                Name:      "flux-system",
                Namespace: filepath.Join(ml.Namespace, "flux-system"),
                FilePer:   layout.FilePerResource,
                Mode:      layout.KustomizationExplicit,
                Resources: fluxResources,
        }

        // Add to the main layout
        ml.Children = append(ml.Children, fluxLayout)

        return nil</span>
}

// findLayoutNode finds the layout node corresponding to a stack node.
func (li *LayoutIntegrator) findLayoutNode(ml *layout.ManifestLayout, node *stack.Node) *layout.ManifestLayout <span class="cov0" title="0">{
        // Check if this is the target node
        if ml.Name == node.Name </span><span class="cov0" title="0">{
                return ml
        }</span>

        // Search in children
        <span class="cov0" title="0">for _, child := range ml.Children </span><span class="cov0" title="0">{
                if found := li.findLayoutNode(child, node); found != nil </span><span class="cov0" title="0">{
                        return found
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// SetFluxPlacement configures where Flux resources should be placed in layouts.
func (li *LayoutIntegrator) SetFluxPlacement(placement layout.FluxPlacement) <span class="cov0" title="0">{
        li.FluxPlacement = placement
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">package fluxcd

import (
        "fmt"
        "path/filepath"
        "time"

        kustv1 "github.com/fluxcd/kustomize-controller/api/v1"
        metaapi "github.com/fluxcd/pkg/apis/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/layout"
)

// ResourceGenerator implements the workflow.ResourceGenerator interface for Flux.
// It focuses purely on generating Flux CRDs from stack components.
type ResourceGenerator struct {
        // Mode controls how spec.path is generated in Kustomizations
        Mode layout.KustomizationMode
        // DefaultInterval is the default reconciliation interval for generated resources
        DefaultInterval time.Duration
        // DefaultNamespace is the default namespace for generated Flux resources
        DefaultNamespace string
}

// NewResourceGenerator creates a FluxCD resource generator with sensible defaults.
func NewResourceGenerator() *ResourceGenerator <span class="cov4" title="2">{
        return &amp;ResourceGenerator{
                Mode:             layout.KustomizationExplicit,
                DefaultInterval:  5 * time.Minute,
                DefaultNamespace: "flux-system",
        }
}</span>

// GenerateFromCluster creates Flux Kustomizations and Sources from a cluster definition.
func (g *ResourceGenerator) GenerateFromCluster(c *stack.Cluster) ([]client.Object, error) <span class="cov0" title="0">{
        if c == nil || c.Node == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return g.GenerateFromNode(c.Node)</span>
}

// GenerateFromNode creates Flux resources from a node and its children.
func (g *ResourceGenerator) GenerateFromNode(n *stack.Node) ([]client.Object, error) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var resources []client.Object

        // Generate resources for this node's bundle
        if n.Bundle != nil </span><span class="cov0" title="0">{
                bundleResources, err := g.GenerateFromBundle(n.Bundle)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.ResourceValidationError("Node", n.Name, "bundle",
                                fmt.Sprintf("failed to generate bundle resources: %v", err), err)
                }</span>
                <span class="cov0" title="0">resources = append(resources, bundleResources...)</span>
        }

        // Generate resources for child nodes
        <span class="cov0" title="0">for _, child := range n.Children </span><span class="cov0" title="0">{
                childResources, err := g.GenerateFromNode(child)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.ResourceValidationError("Node", n.Name, "children",
                                fmt.Sprintf("failed to generate child node resources: %v", err), err)
                }</span>
                <span class="cov0" title="0">resources = append(resources, childResources...)</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// GenerateFromBundle creates a Flux Kustomization from a bundle definition.
func (g *ResourceGenerator) GenerateFromBundle(b *stack.Bundle) ([]client.Object, error) <span class="cov6" title="3">{
        if b == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Create the main Kustomization for this bundle
        <span class="cov6" title="3">kustomization := g.createKustomization(b)
        resources := []client.Object{kustomization}

        // Create source if specified
        if b.SourceRef != nil </span><span class="cov1" title="1">{
                source, err := g.createSource(b.SourceRef, b.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.ResourceValidationError("Bundle", b.Name, "source",
                                fmt.Sprintf("failed to create source: %v", err), err)
                }</span>
                <span class="cov1" title="1">if source != nil </span><span class="cov0" title="0">{
                        resources = append(resources, source)
                }</span>
        }

        <span class="cov6" title="3">return resources, nil</span>
}

// createKustomization creates a Flux Kustomization resource from a bundle.
func (g *ResourceGenerator) createKustomization(b *stack.Bundle) client.Object <span class="cov6" title="3">{
        interval := g.DefaultInterval
        if b.Interval != "" </span><span class="cov1" title="1">{
                if d, err := time.ParseDuration(b.Interval); err == nil </span><span class="cov1" title="1">{
                        interval = d
                }</span>
        }

        <span class="cov6" title="3">kust := &amp;kustv1.Kustomization{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: kustv1.GroupVersion.String(),
                        Kind:       "Kustomization",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      b.Name,
                        Namespace: g.DefaultNamespace,
                        Labels:    b.Labels,
                },
                Spec: kustv1.KustomizationSpec{
                        Interval: metav1.Duration{Duration: interval},
                        Path:     g.generatePath(b),
                        Prune:    true,
                },
        }

        // Set source reference
        if b.SourceRef != nil </span><span class="cov1" title="1">{
                kust.Spec.SourceRef = kustv1.CrossNamespaceSourceReference{
                        Kind: b.SourceRef.Kind,
                        Name: b.SourceRef.Name,
                }
                if b.SourceRef.Namespace != "" </span><span class="cov1" title="1">{
                        kust.Spec.SourceRef.Namespace = b.SourceRef.Namespace
                }</span>
        }

        // Add dependencies
        <span class="cov6" title="3">for _, dep := range b.DependsOn </span><span class="cov1" title="1">{
                kust.Spec.DependsOn = append(kust.Spec.DependsOn, metaapi.NamespacedObjectReference{
                        Name: dep.Name,
                })
        }</span>

        <span class="cov6" title="3">return kust</span>
}

// createSource creates a Flux source resource based on the source reference.
func (g *ResourceGenerator) createSource(ref *stack.SourceRef, name string) (client.Object, error) <span class="cov1" title="1">{
        switch ref.Kind </span>{
        case "GitRepository":<span class="cov1" title="1">
                // For now, return nil - GitRepository creation would need additional parameters
                // This could be extended to create actual GitRepository resources
                return nil, nil</span>
        case "OCIRepository":<span class="cov0" title="0">
                // For now, return nil - OCIRepository creation would need additional parameters
                return nil, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewValidationError("kind", ref.Kind, "SourceRef",
                        []string{"GitRepository", "OCIRepository"})</span>
        }
}

// generatePath generates the path for a Kustomization based on the bundle hierarchy.
// This replicates the logic from the original bundlePath function to maintain compatibility.
func (g *ResourceGenerator) generatePath(b *stack.Bundle) string <span class="cov6" title="3">{
        path := g.bundlePath(b)
        if g.Mode == layout.KustomizationRecursive &amp;&amp; b.GetParent() != nil </span><span class="cov1" title="1">{
                path = g.bundlePath(b.GetParent())
        }</span>
        <span class="cov6" title="3">return path</span>
}

// bundlePath builds a repository path for the bundle based on its ancestry.
// This is copied from the original implementation to maintain compatibility.
func (g *ResourceGenerator) bundlePath(b *stack.Bundle) string <span class="cov7" title="4">{
        var parts []string
        for p := b; p != nil; p = p.GetParent() </span><span class="cov10" title="7">{
                if p.Name != "" </span><span class="cov10" title="7">{
                        parts = append([]string{p.Name}, parts...)
                }</span>
        }
        <span class="cov7" title="4">return filepath.ToSlash(filepath.Join(parts...))</span>
}

// GetName returns the name of this resource generator.
func (g *ResourceGenerator) GetName() string <span class="cov0" title="0">{
        return "FluxCD Resource Generator"
}</span>

// GetVersion returns the version of this resource generator.
func (g *ResourceGenerator) GetVersion() string <span class="cov0" title="0">{
        return "v1.0.0"
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package fluxcd

import (
        "fmt"

        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/layout"
)

// Ensure WorkflowEngine implements the stack.Workflow interface
var _ stack.Workflow = (*WorkflowEngine)(nil)

// WorkflowEngine implements the stack.Workflow interface by composing
// the specialized generator components. This provides a complete FluxCD workflow
// implementation with clear separation of concerns.
type WorkflowEngine struct {
        // ResourceGen handles core resource generation
        ResourceGen *ResourceGenerator
        // LayoutInteg handles layout integration
        LayoutInteg *LayoutIntegrator
        // BootstrapGen handles bootstrap resource generation
        BootstrapGen *BootstrapGenerator
}

// NewWorkflowEngine creates a FluxCD workflow engine with default components.
func NewWorkflowEngine() *WorkflowEngine <span class="cov6" title="2">{
        resourceGen := NewResourceGenerator()
        layoutInteg := NewLayoutIntegrator(resourceGen)
        bootstrapGen := NewBootstrapGenerator()

        return &amp;WorkflowEngine{
                ResourceGen:  resourceGen,
                LayoutInteg:  layoutInteg,
                BootstrapGen: bootstrapGen,
        }
}</span>

// NewWorkflowEngineWithConfig creates a workflow engine with custom configuration.
func NewWorkflowEngineWithConfig(mode layout.KustomizationMode, placement layout.FluxPlacement) *WorkflowEngine <span class="cov0" title="0">{
        resourceGen := NewResourceGenerator()
        resourceGen.Mode = mode

        layoutInteg := NewLayoutIntegrator(resourceGen)
        layoutInteg.FluxPlacement = placement

        bootstrapGen := NewBootstrapGenerator()

        return &amp;WorkflowEngine{
                ResourceGen:  resourceGen,
                LayoutInteg:  layoutInteg,
                BootstrapGen: bootstrapGen,
        }
}</span>

// ResourceGenerator interface implementation

// GenerateFromCluster creates Flux resources from a cluster definition.
func (we *WorkflowEngine) GenerateFromCluster(c *stack.Cluster) ([]client.Object, error) <span class="cov0" title="0">{
        return we.ResourceGen.GenerateFromCluster(c)
}</span>

// GenerateFromNode creates Flux resources from a node definition.
func (we *WorkflowEngine) GenerateFromNode(n *stack.Node) ([]client.Object, error) <span class="cov0" title="0">{
        return we.ResourceGen.GenerateFromNode(n)
}</span>

// GenerateFromBundle creates Flux resources from a bundle definition.
func (we *WorkflowEngine) GenerateFromBundle(b *stack.Bundle) ([]client.Object, error) <span class="cov10" title="3">{
        return we.ResourceGen.GenerateFromBundle(b)
}</span>

// LayoutIntegrator interface implementation

// IntegrateWithLayout adds Flux resources to an existing manifest layout.
func (we *WorkflowEngine) IntegrateWithLayout(ml *layout.ManifestLayout, c *stack.Cluster, rules layout.LayoutRules) error <span class="cov0" title="0">{
        return we.LayoutInteg.IntegrateWithLayout(ml, c, rules)
}</span>

// CreateLayoutWithResources creates a new layout that includes Flux resources.
func (we *WorkflowEngine) CreateLayoutWithResources(c *stack.Cluster, rules interface{}) (interface{}, error) <span class="cov0" title="0">{
        layoutRules, ok := rules.(layout.LayoutRules)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rules must be of type layout.LayoutRules")
        }</span>
        <span class="cov0" title="0">return we.LayoutInteg.CreateLayoutWithResources(c, layoutRules)</span>
}

// BootstrapGenerator interface implementation

// GenerateBootstrap creates bootstrap resources for setting up Flux.
func (we *WorkflowEngine) GenerateBootstrap(config *stack.BootstrapConfig, rootNode *stack.Node) ([]client.Object, error) <span class="cov0" title="0">{
        return we.BootstrapGen.GenerateBootstrap(config, rootNode)
}</span>

// SupportedBootstrapModes returns the bootstrap modes supported by this engine.
func (we *WorkflowEngine) SupportedBootstrapModes() []string <span class="cov0" title="0">{
        return we.BootstrapGen.SupportedBootstrapModes()
}</span>

// WorkflowEngine interface implementation

// GetName returns a human-readable name for this workflow engine.
func (we *WorkflowEngine) GetName() string <span class="cov0" title="0">{
        return "FluxCD Workflow Engine"
}</span>

// GetVersion returns the version of this workflow engine.
func (we *WorkflowEngine) GetVersion() string <span class="cov0" title="0">{
        return "v2.0.0"
}</span>

// Configuration methods

// SetKustomizationMode configures how Kustomization paths are generated.
func (we *WorkflowEngine) SetKustomizationMode(mode layout.KustomizationMode) <span class="cov6" title="2">{
        we.ResourceGen.Mode = mode
}</span>

// SetFluxPlacement configures where Flux resources are placed in layouts.
func (we *WorkflowEngine) SetFluxPlacement(placement layout.FluxPlacement) <span class="cov0" title="0">{
        we.LayoutInteg.SetFluxPlacement(placement)
}</span>

// GetResourceGenerator returns the underlying resource generator for advanced configuration.
func (we *WorkflowEngine) GetResourceGenerator() *ResourceGenerator <span class="cov0" title="0">{
        return we.ResourceGen
}</span>

// GetLayoutIntegrator returns the underlying layout integrator for advanced configuration.
func (we *WorkflowEngine) GetLayoutIntegrator() *LayoutIntegrator <span class="cov0" title="0">{
        return we.LayoutInteg
}</span>

// GetBootstrapGenerator returns the underlying bootstrap generator for advanced configuration.
func (we *WorkflowEngine) GetBootstrapGenerator() *BootstrapGenerator <span class="cov0" title="0">{
        return we.BootstrapGen
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package internal

import (
        "fmt"

        corev1 "k8s.io/api/core/v1"
        netv1 "k8s.io/api/networking/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        "k8s.io/apimachinery/pkg/util/intstr"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/internal/kubernetes"
        "github.com/go-kure/kure/pkg/errors"
        pkgkubernetes "github.com/go-kure/kure/pkg/kubernetes"
        "github.com/go-kure/kure/pkg/stack"
)

// WorkloadType enumerates the supported Kubernetes workload kinds.
type WorkloadType string

const (
        DeploymentWorkload  WorkloadType = "Deployment"
        StatefulSetWorkload WorkloadType = "StatefulSet"
        DaemonSetWorkload   WorkloadType = "DaemonSet"
)

// ResourceRequirements wraps corev1.ResourceRequirements with custom YAML unmarshaling
type ResourceRequirements struct {
        Limits   map[string]string `json:"limits,omitempty" yaml:"limits,omitempty"`
        Requests map[string]string `json:"requests,omitempty" yaml:"requests,omitempty"`
}

// ToKubernetesResources converts to standard Kubernetes ResourceRequirements
func (r *ResourceRequirements) ToKubernetesResources() (*corev1.ResourceRequirements, error) <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">result := &amp;corev1.ResourceRequirements{}

        if len(r.Limits) &gt; 0 </span><span class="cov0" title="0">{
                result.Limits = make(corev1.ResourceList)
                for k, v := range r.Limits </span><span class="cov0" title="0">{
                        qty, err := resource.ParseQuantity(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.NewValidationError("limits", fmt.Sprintf("%s=%s", k, v), "ResourceRequirements", nil)
                        }</span>
                        <span class="cov0" title="0">result.Limits[corev1.ResourceName(k)] = qty</span>
                }
        }

        <span class="cov0" title="0">if len(r.Requests) &gt; 0 </span><span class="cov0" title="0">{
                result.Requests = make(corev1.ResourceList)
                for k, v := range r.Requests </span><span class="cov0" title="0">{
                        qty, err := resource.ParseQuantity(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.NewValidationError("requests", fmt.Sprintf("%s=%s", k, v), "ResourceRequirements", nil)
                        }</span>
                        <span class="cov0" title="0">result.Requests[corev1.ResourceName(k)] = qty</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// VolumeClaimTemplate wraps PersistentVolumeClaim with custom resource parsing
type VolumeClaimTemplate struct {
        Metadata struct {
                Name string `json:"name" yaml:"name"`
        } `json:"metadata" yaml:"metadata"`
        Spec struct {
                AccessModes      []string              `json:"accessModes,omitempty" yaml:"accessModes,omitempty"`
                StorageClassName *string               `json:"storageClassName,omitempty" yaml:"storageClassName,omitempty"`
                Resources        *ResourceRequirements `json:"resources,omitempty" yaml:"resources,omitempty"`
        } `json:"spec" yaml:"spec"`
}

// ToKubernetesPVC converts to standard Kubernetes PersistentVolumeClaim
func (vct *VolumeClaimTemplate) ToKubernetesPVC() (*corev1.PersistentVolumeClaim, error) <span class="cov0" title="0">{
        pvc := &amp;corev1.PersistentVolumeClaim{}
        pvc.Name = vct.Metadata.Name

        // Convert access modes
        for _, mode := range vct.Spec.AccessModes </span><span class="cov0" title="0">{
                pvc.Spec.AccessModes = append(pvc.Spec.AccessModes, corev1.PersistentVolumeAccessMode(mode))
        }</span>

        // Set storage class
        <span class="cov0" title="0">pvc.Spec.StorageClassName = vct.Spec.StorageClassName

        // Convert resources
        if vct.Spec.Resources != nil </span><span class="cov0" title="0">{
                k8sResources, err := vct.Spec.Resources.ToKubernetesResources()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if k8sResources != nil </span><span class="cov0" title="0">{
                        // Convert ResourceRequirements to VolumeResourceRequirements
                        pvc.Spec.Resources = corev1.VolumeResourceRequirements{
                                Limits:   k8sResources.Limits,
                                Requests: k8sResources.Requests,
                        }
                }</span>
        }

        <span class="cov0" title="0">return pvc, nil</span>
}

// Config describes a single deployable application.
type Config struct {
        Name      string            `json:"name" yaml:"name"`
        Namespace string            `json:"namespace,omitempty" yaml:"namespace,omitempty"`
        Workload  WorkloadType      `yaml:"workload,omitempty"`
        Replicas  int32             `json:"replicas,omitempty" yaml:"replicas,omitempty"`
        Labels    map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`

        Containers           []ContainerConfig     `json:"containers" yaml:"containers"`
        Volumes              []Volume              `json:"volumes,omitempty" yaml:"volumes,omitempty"`
        VolumeClaimTemplates []VolumeClaimTemplate `json:"volumeClaimTemplates,omitempty" yaml:"volumeClaimTemplates,omitempty"`

        Services []ServiceConfig `json:"services,omitempty" yaml:"services,omitempty"`
        Ingress  *IngressConfig  `json:"ingress,omitempty" yaml:"ingress,omitempty"`
}

// Custom types for proper YAML parsing

type ContainerPort struct {
        Name          string `json:"name,omitempty" yaml:"name,omitempty"`
        ContainerPort int32  `json:"containerPort" yaml:"containerPort"`
        Protocol      string `json:"protocol,omitempty" yaml:"protocol,omitempty"`
}

func (cp ContainerPort) ToKubernetesPort() corev1.ContainerPort <span class="cov8" title="3">{
        protocol := corev1.ProtocolTCP
        if cp.Protocol != "" </span><span class="cov0" title="0">{
                protocol = corev1.Protocol(cp.Protocol)
        }</span>
        <span class="cov8" title="3">return corev1.ContainerPort{
                Name:          cp.Name,
                ContainerPort: cp.ContainerPort,
                Protocol:      protocol,
        }</span>
}

type VolumeMount struct {
        Name      string `json:"name" yaml:"name"`
        MountPath string `json:"mountPath" yaml:"mountPath"`
        ReadOnly  bool   `json:"readOnly,omitempty" yaml:"readOnly,omitempty"`
        SubPath   string `json:"subPath,omitempty" yaml:"subPath,omitempty"`
}

func (vm VolumeMount) ToKubernetesVolumeMount() corev1.VolumeMount <span class="cov1" title="1">{
        return corev1.VolumeMount{
                Name:      vm.Name,
                MountPath: vm.MountPath,
                ReadOnly:  vm.ReadOnly,
                SubPath:   vm.SubPath,
        }
}</span>

type EnvVarSource struct {
        SecretKeyRef    *SecretKeySelector    `json:"secretKeyRef,omitempty" yaml:"secretKeyRef,omitempty"`
        ConfigMapKeyRef *ConfigMapKeySelector `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty"`
        FieldRef        *ObjectFieldSelector  `json:"fieldRef,omitempty" yaml:"fieldRef,omitempty"`
}

type SecretKeySelector struct {
        Name string `json:"name" yaml:"name"`
        Key  string `json:"key" yaml:"key"`
}

type ConfigMapKeySelector struct {
        Name string `json:"name" yaml:"name"`
        Key  string `json:"key" yaml:"key"`
}

type ObjectFieldSelector struct {
        FieldPath string `json:"fieldPath" yaml:"fieldPath"`
}

type EnvVar struct {
        Name      string        `json:"name" yaml:"name"`
        Value     string        `json:"value,omitempty" yaml:"value,omitempty"`
        ValueFrom *EnvVarSource `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty"`
}

func (env EnvVar) ToKubernetesEnvVar() corev1.EnvVar <span class="cov0" title="0">{
        k8sEnv := corev1.EnvVar{
                Name:  env.Name,
                Value: env.Value,
        }

        if env.ValueFrom != nil </span><span class="cov0" title="0">{
                k8sEnv.ValueFrom = &amp;corev1.EnvVarSource{}
                if env.ValueFrom.SecretKeyRef != nil </span><span class="cov0" title="0">{
                        k8sEnv.ValueFrom.SecretKeyRef = &amp;corev1.SecretKeySelector{
                                LocalObjectReference: corev1.LocalObjectReference{
                                        Name: env.ValueFrom.SecretKeyRef.Name,
                                },
                                Key: env.ValueFrom.SecretKeyRef.Key,
                        }
                }</span>
                <span class="cov0" title="0">if env.ValueFrom.ConfigMapKeyRef != nil </span><span class="cov0" title="0">{
                        k8sEnv.ValueFrom.ConfigMapKeyRef = &amp;corev1.ConfigMapKeySelector{
                                LocalObjectReference: corev1.LocalObjectReference{
                                        Name: env.ValueFrom.ConfigMapKeyRef.Name,
                                },
                                Key: env.ValueFrom.ConfigMapKeyRef.Key,
                        }
                }</span>
                <span class="cov0" title="0">if env.ValueFrom.FieldRef != nil </span><span class="cov0" title="0">{
                        k8sEnv.ValueFrom.FieldRef = &amp;corev1.ObjectFieldSelector{
                                FieldPath: env.ValueFrom.FieldRef.FieldPath,
                        }
                }</span>
        }

        <span class="cov0" title="0">return k8sEnv</span>
}

type HTTPGetAction struct {
        Path   string `json:"path,omitempty" yaml:"path,omitempty"`
        Port   int32  `json:"port" yaml:"port"`
        Scheme string `json:"scheme,omitempty" yaml:"scheme,omitempty"`
}

type ExecAction struct {
        Command []string `json:"command,omitempty" yaml:"command,omitempty"`
}

type Probe struct {
        HTTPGet             *HTTPGetAction `json:"httpGet,omitempty" yaml:"httpGet,omitempty"`
        Exec                *ExecAction    `json:"exec,omitempty" yaml:"exec,omitempty"`
        InitialDelaySeconds int32          `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
        TimeoutSeconds      int32          `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty"`
        PeriodSeconds       int32          `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
        SuccessThreshold    int32          `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty"`
        FailureThreshold    int32          `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
}

func (p Probe) ToKubernetesProbe() *corev1.Probe <span class="cov0" title="0">{
        if p.HTTPGet == nil &amp;&amp; p.Exec == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">k8sProbe := &amp;corev1.Probe{
                InitialDelaySeconds: p.InitialDelaySeconds,
                TimeoutSeconds:      p.TimeoutSeconds,
                PeriodSeconds:       p.PeriodSeconds,
                SuccessThreshold:    p.SuccessThreshold,
                FailureThreshold:    p.FailureThreshold,
        }

        if p.HTTPGet != nil </span><span class="cov0" title="0">{
                k8sProbe.ProbeHandler.HTTPGet = &amp;corev1.HTTPGetAction{
                        Path: p.HTTPGet.Path,
                        Port: intstr.FromInt32(p.HTTPGet.Port),
                }
                if p.HTTPGet.Scheme != "" </span><span class="cov0" title="0">{
                        k8sProbe.ProbeHandler.HTTPGet.Scheme = corev1.URIScheme(p.HTTPGet.Scheme)
                }</span>
        }

        <span class="cov0" title="0">if p.Exec != nil </span><span class="cov0" title="0">{
                k8sProbe.ProbeHandler.Exec = &amp;corev1.ExecAction{
                        Command: p.Exec.Command,
                }
        }</span>

        <span class="cov0" title="0">return k8sProbe</span>
}

type VolumeSource struct {
        EmptyDir  *EmptyDirVolumeSource  `json:"emptyDir,omitempty" yaml:"emptyDir,omitempty"`
        ConfigMap *ConfigMapVolumeSource `json:"configMap,omitempty" yaml:"configMap,omitempty"`
        Secret    *SecretVolumeSource    `json:"secret,omitempty" yaml:"secret,omitempty"`
        HostPath  *HostPathVolumeSource  `json:"hostPath,omitempty" yaml:"hostPath,omitempty"`
}

type EmptyDirVolumeSource struct {
        SizeLimit string `json:"sizeLimit,omitempty" yaml:"sizeLimit,omitempty"`
}

type ConfigMapVolumeSource struct {
        Name string `json:"name" yaml:"name"`
}

type SecretVolumeSource struct {
        SecretName string `json:"secretName" yaml:"secretName"`
}

type HostPathVolumeSource struct {
        Path string `json:"path" yaml:"path"`
}

type Volume struct {
        Name         string        `json:"name" yaml:"name"`
        VolumeSource *VolumeSource `json:",inline" yaml:",inline"`
}

func (v Volume) ToKubernetesVolume() corev1.Volume <span class="cov0" title="0">{
        k8sVol := corev1.Volume{
                Name: v.Name,
        }

        if v.VolumeSource != nil </span><span class="cov0" title="0">{
                if v.VolumeSource.EmptyDir != nil </span><span class="cov0" title="0">{
                        k8sVol.VolumeSource.EmptyDir = &amp;corev1.EmptyDirVolumeSource{}
                        if v.VolumeSource.EmptyDir.SizeLimit != "" </span><span class="cov0" title="0">{
                                qty, err := resource.ParseQuantity(v.VolumeSource.EmptyDir.SizeLimit)
                                if err == nil </span><span class="cov0" title="0">{
                                        k8sVol.VolumeSource.EmptyDir.SizeLimit = &amp;qty
                                }</span>
                        }
                }
                <span class="cov0" title="0">if v.VolumeSource.ConfigMap != nil </span><span class="cov0" title="0">{
                        k8sVol.VolumeSource.ConfigMap = &amp;corev1.ConfigMapVolumeSource{
                                LocalObjectReference: corev1.LocalObjectReference{
                                        Name: v.VolumeSource.ConfigMap.Name,
                                },
                        }
                }</span>
                <span class="cov0" title="0">if v.VolumeSource.Secret != nil </span><span class="cov0" title="0">{
                        k8sVol.VolumeSource.Secret = &amp;corev1.SecretVolumeSource{
                                SecretName: v.VolumeSource.Secret.SecretName,
                        }
                }</span>
                <span class="cov0" title="0">if v.VolumeSource.HostPath != nil </span><span class="cov0" title="0">{
                        k8sVol.VolumeSource.HostPath = &amp;corev1.HostPathVolumeSource{
                                Path: v.VolumeSource.HostPath.Path,
                        }
                }</span>
        }

        <span class="cov0" title="0">return k8sVol</span>
}

type ContainerConfig struct {
        Name         string          `json:"name" yaml:"name"`
        Image        string          `json:"image" yaml:"image"`
        Ports        []ContainerPort `json:"ports,omitempty" yaml:"ports,omitempty"`
        Env          []EnvVar        `json:"env,omitempty" yaml:"env,omitempty"`
        VolumeMounts []VolumeMount   `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty"`

        Resources *ResourceRequirements `json:"resources,omitempty" yaml:"resources,omitempty"`

        StartupProbe   *Probe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty"`
        LivenessProbe  *Probe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty"`
        ReadinessProbe *Probe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
}

type ServiceConfig struct {
        Name       string             `json:"name" yaml:"name"`
        Type       corev1.ServiceType `json:"type,omitempty" yaml:"type,omitempty"`
        Port       int32              `json:"port" yaml:"port"`             // service port
        TargetPort int32              `json:"targetPort" yaml:"targetPort"` // container port
        Protocol   corev1.Protocol    `json:"protocol,omitempty" yaml:"protocol,omitempty"`

        // Optional explicit selector override (else falls back to Deployment labels)
        Selector map[string]string `json:"selector,omitempty" yaml:"selector,omitempty"`
}

type IngressConfig struct {
        Host            string `json:"host" yaml:"host"`
        Path            string `json:"path" yaml:"path"`
        ServiceName     string `json:"serviceName" yaml:"serviceName"`
        ServicePortName string `json:"servicePortName" yaml:"servicePortName"`
}

// Generate builds Kubernetes resources for the application workload.
// GenerateResources creates Kubernetes resources from the Config
func GenerateResources(cfg *Config, app *stack.Application) ([]*client.Object, error) <span class="cov8" title="3">{
        var objs []*client.Object
        var allports []corev1.ContainerPort

        var containers []*corev1.Container
        for _, c := range cfg.Containers </span><span class="cov8" title="3">{
                container, ports, err := c.Generate()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="3">containers = append(containers, container)
                allports = append(allports, ports...)</span>
        }
        // Determine workload type
        <span class="cov8" title="3">switch cfg.Workload </span>{
        case StatefulSetWorkload:<span class="cov1" title="1">
                sts := kubernetes.CreateStatefulSet(app.Name, app.Namespace)
                for _, c := range containers </span><span class="cov1" title="1">{
                        if err := kubernetes.AddStatefulSetContainer(sts, c); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov1" title="1">for _, v := range cfg.Volumes </span><span class="cov0" title="0">{
                        k8sVol := v.ToKubernetesVolume()
                        if err := kubernetes.AddStatefulSetVolume(sts, &amp;k8sVol); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov1" title="1">for _, vct := range cfg.VolumeClaimTemplates </span><span class="cov0" title="0">{
                        k8sPVC, err := vct.ToKubernetesPVC()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if err := kubernetes.AddStatefulSetVolumeClaimTemplate(sts, *k8sPVC); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov1" title="1">_ = kubernetes.SetStatefulSetReplicas(sts, cfg.Replicas)
                objs = append(objs, pkgkubernetes.ToClientObject(sts))</span>
        case DaemonSetWorkload:<span class="cov1" title="1">
                ds := kubernetes.CreateDaemonSet(app.Name, app.Namespace)
                for _, c := range containers </span><span class="cov1" title="1">{
                        if err := kubernetes.AddDaemonSetContainer(ds, c); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov1" title="1">for _, v := range cfg.Volumes </span><span class="cov0" title="0">{
                        k8sVol := v.ToKubernetesVolume()
                        if err := kubernetes.AddDaemonSetVolume(ds, &amp;k8sVol); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov1" title="1">objs = append(objs, pkgkubernetes.ToClientObject(ds))</span>
        case DeploymentWorkload:<span class="cov1" title="1">
                dep := kubernetes.CreateDeployment(app.Name, app.Namespace)
                for _, c := range containers </span><span class="cov1" title="1">{
                        if err := kubernetes.AddDeploymentContainer(dep, c); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov1" title="1">for _, v := range cfg.Volumes </span><span class="cov0" title="0">{
                        k8sVol := v.ToKubernetesVolume()
                        if err := kubernetes.AddDeploymentVolume(dep, &amp;k8sVol); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov1" title="1">_ = kubernetes.SetDeploymentReplicas(dep, cfg.Replicas)
                objs = append(objs, pkgkubernetes.ToClientObject(dep))</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewValidationError("workload", string(cfg.Workload), "AppWorkloadConfig", []string{"Deployment", "StatefulSet", "DaemonSet"})</span>
        }

        // Service creation when ports are specified
        <span class="cov8" title="3">var svc *corev1.Service
        if len(allports) &gt; 0 </span><span class="cov5" title="2">{
                svc = kubernetes.CreateService(app.Name, app.Namespace)
                _ = kubernetes.SetServiceSelector(svc, map[string]string{"app": app.Name})
                for _, p := range allports </span><span class="cov5" title="2">{
                        _ = kubernetes.AddServicePort(svc, corev1.ServicePort{
                                Name:       p.Name,
                                Port:       p.ContainerPort,
                                TargetPort: intstr.FromInt32(p.ContainerPort),
                        })
                }</span>
                <span class="cov5" title="2">objs = append(objs, pkgkubernetes.ToClientObject(svc))</span>
        }

        <span class="cov8" title="3">if cfg.Ingress != nil &amp;&amp; svc != nil </span><span class="cov1" title="1">{
                ing := kubernetes.CreateIngress(app.Name, app.Namespace, "")
                rule := kubernetes.CreateIngressRule(cfg.Ingress.Host)
                pt := netv1.PathTypeImplementationSpecific
                path := cfg.Ingress.Path
                if path == "" </span><span class="cov1" title="1">{
                        path = "/"
                }</span>
                <span class="cov1" title="1">port := cfg.Ingress.ServicePortName
                kubernetes.AddIngressRulePath(rule, kubernetes.CreateIngressPath(path, &amp;pt, svc.Name, port))
                kubernetes.AddIngressRule(ing, rule)
                kubernetes.AddIngressTLS(ing, netv1.IngressTLS{Hosts: []string{cfg.Ingress.Host}, SecretName: fmt.Sprintf("%s-tls", app.Name)})
                objs = append(objs, pkgkubernetes.ToClientObject(ing))</span>
        }

        <span class="cov8" title="3">return objs, nil</span>
}

func (cfg ContainerConfig) Generate() (*corev1.Container, []corev1.ContainerPort, error) <span class="cov10" title="4">{
        container := kubernetes.CreateContainer(cfg.Name, cfg.Image, nil, nil)
        var ports []corev1.ContainerPort

        // Add ports
        for _, p := range cfg.Ports </span><span class="cov8" title="3">{
                k8sPort := p.ToKubernetesPort()
                _ = kubernetes.AddContainerPort(container, k8sPort)
                ports = append(ports, k8sPort)
        }</span>

        // Add environment variables
        <span class="cov10" title="4">for _, env := range cfg.Env </span><span class="cov0" title="0">{
                k8sEnv := env.ToKubernetesEnvVar()
                _ = kubernetes.AddContainerEnv(container, k8sEnv)
        }</span>

        // Add volume mounts
        <span class="cov10" title="4">for _, vm := range cfg.VolumeMounts </span><span class="cov1" title="1">{
                k8sMount := vm.ToKubernetesVolumeMount()
                _ = kubernetes.AddContainerVolumeMount(container, k8sMount)
        }</span>

        // Set resources if provided
        <span class="cov10" title="4">if cfg.Resources != nil </span><span class="cov0" title="0">{
                k8sResources, err := cfg.Resources.ToKubernetesResources()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">if k8sResources != nil </span><span class="cov0" title="0">{
                        _ = kubernetes.SetContainerResources(container, *k8sResources)
                }</span>
        }

        // Set probes if provided
        <span class="cov10" title="4">if cfg.LivenessProbe != nil </span><span class="cov0" title="0">{
                k8sProbe := cfg.LivenessProbe.ToKubernetesProbe()
                if k8sProbe != nil </span><span class="cov0" title="0">{
                        _ = kubernetes.SetContainerLivenessProbe(container, *k8sProbe)
                }</span>
        }
        <span class="cov10" title="4">if cfg.ReadinessProbe != nil </span><span class="cov0" title="0">{
                k8sProbe := cfg.ReadinessProbe.ToKubernetesProbe()
                if k8sProbe != nil </span><span class="cov0" title="0">{
                        _ = kubernetes.SetContainerReadinessProbe(container, *k8sProbe)
                }</span>
        }
        <span class="cov10" title="4">if cfg.StartupProbe != nil </span><span class="cov0" title="0">{
                k8sProbe := cfg.StartupProbe.ToKubernetesProbe()
                if k8sProbe != nil </span><span class="cov0" title="0">{
                        _ = kubernetes.SetContainerStartupProbe(container, *k8sProbe)
                }</span>
        }

        <span class="cov10" title="4">return container, ports, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package appworkload

import (
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/internal/gvk"
        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/generators"
        "github.com/go-kure/kure/pkg/stack/generators/appworkload/internal"
)

func init() <span class="cov1" title="1">{
        // Register the AppWorkload v1alpha1 generator with both registries
        gvkObj := gvk.GVK{
                Group:   "generators.gokure.dev",
                Version: "v1alpha1",
                Kind:    "AppWorkload",
        }

        factory := func() stack.ApplicationConfig </span><span class="cov3" title="2">{
                return &amp;ConfigV1Alpha1{}
        }</span>

        // Register with generators package for backward compatibility
        <span class="cov1" title="1">generators.Register(generators.GVK(gvkObj), factory)

        // Register with stack package for direct usage
        stack.RegisterApplicationConfig(gvkObj, factory)</span>
}

// ConfigV1Alpha1 describes a single deployable application with GVK support
type ConfigV1Alpha1 struct {
        generators.BaseMetadata `yaml:",inline" json:",inline"`

        Workload internal.WorkloadType `yaml:"workload,omitempty" json:"workload,omitempty"`
        Replicas int32                 `yaml:"replicas,omitempty" json:"replicas,omitempty"`
        Labels   map[string]string     `yaml:"labels,omitempty" json:"labels,omitempty"`

        Containers           []internal.ContainerConfig     `yaml:"containers" json:"containers"`
        Volumes              []internal.Volume              `yaml:"volumes,omitempty" json:"volumes,omitempty"`
        VolumeClaimTemplates []internal.VolumeClaimTemplate `yaml:"volumeClaimTemplates,omitempty" json:"volumeClaimTemplates,omitempty"`

        Services []internal.ServiceConfig `yaml:"services,omitempty" json:"services,omitempty"`
        Ingress  *internal.IngressConfig  `yaml:"ingress,omitempty" json:"ingress,omitempty"`
}

// GetAPIVersion returns the API version for this config
func (c *ConfigV1Alpha1) GetAPIVersion() string <span class="cov3" title="2">{
        return "generators.gokure.dev/v1alpha1"
}</span>

// GetKind returns the kind for this config
func (c *ConfigV1Alpha1) GetKind() string <span class="cov3" title="2">{
        return "AppWorkload"
}</span>

// Generate creates Kubernetes objects from the AppWorkloadConfig
func (c *ConfigV1Alpha1) Generate(app *stack.Application) ([]*client.Object, error) <span class="cov10" title="12">{
        // Delegate to the internal implementation
        return internal.GenerateResources(&amp;internal.Config{
                Name:                 c.Name,
                Namespace:            c.Namespace,
                Workload:             c.Workload,
                Replicas:             c.Replicas,
                Labels:               c.Labels,
                Containers:           c.Containers,
                Volumes:              c.Volumes,
                VolumeClaimTemplates: c.VolumeClaimTemplates,
                Services:             c.Services,
                Ingress:              c.Ingress,
        }, app)
}</span>
</pre>
		
		<pre class="file" id="file107" style="display: none">package internal

import (
        "fmt"
        "time"

        helmv2 "github.com/fluxcd/helm-controller/api/v2"
        "github.com/fluxcd/pkg/apis/kustomize"
        "github.com/fluxcd/pkg/apis/meta"
        sourcev1 "github.com/fluxcd/source-controller/api/v1"
        "gopkg.in/yaml.v3"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// SourceType represents the type of Helm chart source
type SourceType string

const (
        // HelmRepositorySource indicates a Helm repository source
        HelmRepositorySource SourceType = "HelmRepository"
        // GitRepositorySource indicates a Git repository source
        GitRepositorySource SourceType = "GitRepository"
        // BucketSource indicates an S3-compatible bucket source
        BucketSource SourceType = "Bucket"
        // OCIRepositorySource indicates an OCI registry source
        OCIRepositorySource SourceType = "OCIRepository"
)

// Config represents the FluxHelm generator configuration
type Config struct {
        Name      string `yaml:"name" json:"name"`
        Namespace string `yaml:"namespace,omitempty" json:"namespace,omitempty"`

        // Chart configuration
        Chart   ChartConfig `yaml:"chart" json:"chart"`
        Version string      `yaml:"version,omitempty" json:"version,omitempty"`
        Values  interface{} `yaml:"values,omitempty" json:"values,omitempty"`

        // Source configuration
        Source SourceConfig `yaml:"source" json:"source"`

        // Release configuration
        Release ReleaseConfig `yaml:"release,omitempty" json:"release,omitempty"`

        // Advanced options
        Interval       string         `yaml:"interval,omitempty" json:"interval,omitempty"`
        Timeout        string         `yaml:"timeout,omitempty" json:"timeout,omitempty"`
        MaxHistory     int            `yaml:"maxHistory,omitempty" json:"maxHistory,omitempty"`
        ServiceAccount string         `yaml:"serviceAccount,omitempty" json:"serviceAccount,omitempty"`
        Suspend        bool           `yaml:"suspend,omitempty" json:"suspend,omitempty"`
        DependsOn      []string       `yaml:"dependsOn,omitempty" json:"dependsOn,omitempty"`
        PostRenderers  []PostRenderer `yaml:"postRenderers,omitempty" json:"postRenderers,omitempty"`
}

// ChartConfig defines the Helm chart to deploy
type ChartConfig struct {
        Name    string `yaml:"name" json:"name"`
        Version string `yaml:"version,omitempty" json:"version,omitempty"`
}

// SourceConfig defines where to fetch the Helm chart from
type SourceConfig struct {
        Type SourceType `yaml:"type" json:"type"`

        // HelmRepository specific
        URL string `yaml:"url,omitempty" json:"url,omitempty"`

        // GitRepository specific
        GitURL  string `yaml:"gitUrl,omitempty" json:"gitUrl,omitempty"`
        GitRef  string `yaml:"gitRef,omitempty" json:"gitRef,omitempty"`
        GitPath string `yaml:"gitPath,omitempty" json:"gitPath,omitempty"`

        // OCIRepository specific
        OCIUrl string `yaml:"ociUrl,omitempty" json:"ociUrl,omitempty"`

        // Bucket specific
        BucketName string `yaml:"bucketName,omitempty" json:"bucketName,omitempty"`
        Endpoint   string `yaml:"endpoint,omitempty" json:"endpoint,omitempty"`
        Region     string `yaml:"region,omitempty" json:"region,omitempty"`

        // Authentication
        SecretRef string `yaml:"secretRef,omitempty" json:"secretRef,omitempty"`

        // Common
        Interval string `yaml:"interval,omitempty" json:"interval,omitempty"`
}

// ReleaseConfig defines Helm release options
type ReleaseConfig struct {
        CreateNamespace          bool `yaml:"createNamespace,omitempty" json:"createNamespace,omitempty"`
        DisableWait              bool `yaml:"disableWait,omitempty" json:"disableWait,omitempty"`
        DisableWaitForJobs       bool `yaml:"disableWaitForJobs,omitempty" json:"disableWaitForJobs,omitempty"`
        DisableHooks             bool `yaml:"disableHooks,omitempty" json:"disableHooks,omitempty"`
        DisableOpenAPIValidation bool `yaml:"disableOpenAPIValidation,omitempty" json:"disableOpenAPIValidation,omitempty"`
        ResetValues              bool `yaml:"resetValues,omitempty" json:"resetValues,omitempty"`
        ForceUpgrade             bool `yaml:"forceUpgrade,omitempty" json:"forceUpgrade,omitempty"`
        PreserveValues           bool `yaml:"preserveValues,omitempty" json:"preserveValues,omitempty"`
        CleanupOnFail            bool `yaml:"cleanupOnFail,omitempty" json:"cleanupOnFail,omitempty"`
        Replace                  bool `yaml:"replace,omitempty" json:"replace,omitempty"`
}

// PostRenderer defines a post-renderer for the Helm release
type PostRenderer struct {
        Kustomize *KustomizePostRenderer `yaml:"kustomize,omitempty" json:"kustomize,omitempty"`
}

// KustomizePostRenderer applies Kustomize patches as a post-render step
type KustomizePostRenderer struct {
        Patches []KustomizePatch `yaml:"patches,omitempty" json:"patches,omitempty"`
        Images  []KustomizeImage `yaml:"images,omitempty" json:"images,omitempty"`
}

// KustomizePatch defines a Kustomize patch
type KustomizePatch struct {
        Target *kustomize.Selector `yaml:"target,omitempty" json:"target,omitempty"`
        Patch  string              `yaml:"patch" json:"patch"`
}

// KustomizeImage defines a Kustomize image substitution
type KustomizeImage struct {
        Name    string `yaml:"name" json:"name"`
        NewName string `yaml:"newName,omitempty" json:"newName,omitempty"`
        NewTag  string `yaml:"newTag,omitempty" json:"newTag,omitempty"`
}

// GenerateResources creates Flux HelmRelease and source resources
func GenerateResources(c *Config) ([]*client.Object, error) <span class="cov0" title="0">{
        var objects []*client.Object

        // Generate the source resource
        source, err := c.generateSource()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate source: %w", err)
        }</span>
        <span class="cov0" title="0">if source != nil </span><span class="cov0" title="0">{
                objects = append(objects, source)
        }</span>

        // Generate the HelmRelease
        <span class="cov0" title="0">release, err := c.generateHelmRelease()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate HelmRelease: %w", err)
        }</span>
        <span class="cov0" title="0">objects = append(objects, &amp;release)

        return objects, nil</span>
}

// generateSource creates the appropriate source resource based on type
func (c *Config) generateSource() (*client.Object, error) <span class="cov0" title="0">{
        switch c.Source.Type </span>{
        case HelmRepositorySource:<span class="cov0" title="0">
                return c.generateHelmRepository()</span>
        case GitRepositorySource:<span class="cov0" title="0">
                return c.generateGitRepository()</span>
        case OCIRepositorySource:<span class="cov0" title="0">
                return c.generateOCIRepository()</span>
        case BucketSource:<span class="cov0" title="0">
                return c.generateBucket()</span>
        default:<span class="cov0" title="0">
                // If no source type specified, try to infer from URL
                if c.Source.URL != "" </span><span class="cov0" title="0">{
                        return c.generateHelmRepository()
                }</span>
                <span class="cov0" title="0">if c.Source.OCIUrl != "" </span><span class="cov0" title="0">{
                        return c.generateOCIRepository()
                }</span>
                // No source needed (might be using an existing source)
                <span class="cov0" title="0">return nil, nil</span>
        }
}

// generateHelmRepository creates a HelmRepository resource
func (c *Config) generateHelmRepository() (*client.Object, error) <span class="cov0" title="0">{
        interval := c.Source.Interval
        if interval == "" </span><span class="cov0" title="0">{
                interval = "10m"
        }</span>

        <span class="cov0" title="0">duration, err := time.ParseDuration(interval)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid interval: %w", err)
        }</span>

        <span class="cov0" title="0">repo := &amp;sourcev1.HelmRepository{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "source.toolkit.fluxcd.io/v1",
                        Kind:       "HelmRepository",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      c.Name + "-source",
                        Namespace: c.Namespace,
                },
                Spec: sourcev1.HelmRepositorySpec{
                        URL:      c.Source.URL,
                        Interval: metav1.Duration{Duration: duration},
                },
        }

        if c.Source.SecretRef != "" </span><span class="cov0" title="0">{
                repo.Spec.SecretRef = &amp;meta.LocalObjectReference{
                        Name: c.Source.SecretRef,
                }
        }</span>

        <span class="cov0" title="0">var obj client.Object = repo
        return &amp;obj, nil</span>
}

// generateGitRepository creates a GitRepository resource
func (c *Config) generateGitRepository() (*client.Object, error) <span class="cov0" title="0">{
        interval := c.Source.Interval
        if interval == "" </span><span class="cov0" title="0">{
                interval = "10m"
        }</span>

        <span class="cov0" title="0">duration, err := time.ParseDuration(interval)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid interval: %w", err)
        }</span>

        <span class="cov0" title="0">repo := &amp;sourcev1.GitRepository{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "source.toolkit.fluxcd.io/v1",
                        Kind:       "GitRepository",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      c.Name + "-source",
                        Namespace: c.Namespace,
                },
                Spec: sourcev1.GitRepositorySpec{
                        URL:      c.Source.GitURL,
                        Interval: metav1.Duration{Duration: duration},
                },
        }

        if c.Source.GitRef != "" </span><span class="cov0" title="0">{
                repo.Spec.Reference = &amp;sourcev1.GitRepositoryRef{
                        Branch: c.Source.GitRef,
                }
        }</span>

        <span class="cov0" title="0">if c.Source.SecretRef != "" </span><span class="cov0" title="0">{
                repo.Spec.SecretRef = &amp;meta.LocalObjectReference{
                        Name: c.Source.SecretRef,
                }
        }</span>

        <span class="cov0" title="0">var obj client.Object = repo
        return &amp;obj, nil</span>
}

// generateOCIRepository creates an OCIRepository resource
func (c *Config) generateOCIRepository() (*client.Object, error) <span class="cov0" title="0">{
        interval := c.Source.Interval
        if interval == "" </span><span class="cov0" title="0">{
                interval = "10m"
        }</span>

        <span class="cov0" title="0">duration, err := time.ParseDuration(interval)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid interval: %w", err)
        }</span>

        <span class="cov0" title="0">repo := &amp;sourcev1.OCIRepository{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "source.toolkit.fluxcd.io/v1beta2",
                        Kind:       "OCIRepository",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      c.Name + "-source",
                        Namespace: c.Namespace,
                },
                Spec: sourcev1.OCIRepositorySpec{
                        URL:      c.Source.OCIUrl,
                        Interval: metav1.Duration{Duration: duration},
                },
        }

        if c.Source.SecretRef != "" </span><span class="cov0" title="0">{
                repo.Spec.SecretRef = &amp;meta.LocalObjectReference{
                        Name: c.Source.SecretRef,
                }
        }</span>

        <span class="cov0" title="0">var obj client.Object = repo
        return &amp;obj, nil</span>
}

// generateBucket creates a Bucket resource
func (c *Config) generateBucket() (*client.Object, error) <span class="cov0" title="0">{
        interval := c.Source.Interval
        if interval == "" </span><span class="cov0" title="0">{
                interval = "10m"
        }</span>

        <span class="cov0" title="0">duration, err := time.ParseDuration(interval)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid interval: %w", err)
        }</span>

        <span class="cov0" title="0">bucket := &amp;sourcev1.Bucket{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "source.toolkit.fluxcd.io/v1beta2",
                        Kind:       "Bucket",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      c.Name + "-source",
                        Namespace: c.Namespace,
                },
                Spec: sourcev1.BucketSpec{
                        BucketName: c.Source.BucketName,
                        Endpoint:   c.Source.Endpoint,
                        Region:     c.Source.Region,
                        Interval:   metav1.Duration{Duration: duration},
                },
        }

        if c.Source.SecretRef != "" </span><span class="cov0" title="0">{
                bucket.Spec.SecretRef = &amp;meta.LocalObjectReference{
                        Name: c.Source.SecretRef,
                }
        }</span>

        <span class="cov0" title="0">var obj client.Object = bucket
        return &amp;obj, nil</span>
}

// generateHelmRelease creates a HelmRelease resource
func (c *Config) generateHelmRelease() (client.Object, error) <span class="cov0" title="0">{
        interval := c.Interval
        if interval == "" </span><span class="cov0" title="0">{
                interval = "10m"
        }</span>

        <span class="cov0" title="0">duration, err := time.ParseDuration(interval)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid interval: %w", err)
        }</span>

        <span class="cov0" title="0">hr := &amp;helmv2.HelmRelease{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "helm.toolkit.fluxcd.io/v2",
                        Kind:       "HelmRelease",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      c.Name,
                        Namespace: c.Namespace,
                },
                Spec: helmv2.HelmReleaseSpec{
                        Interval: metav1.Duration{Duration: duration},
                        Chart: &amp;helmv2.HelmChartTemplate{
                                Spec: helmv2.HelmChartTemplateSpec{
                                        Chart:   c.Chart.Name,
                                        Version: c.Chart.Version,
                                        SourceRef: helmv2.CrossNamespaceObjectReference{
                                                Name: c.Name + "-source",
                                        },
                                },
                        },
                },
        }

        // Set source reference kind based on source type
        switch c.Source.Type </span>{
        case HelmRepositorySource:<span class="cov0" title="0">
                hr.Spec.Chart.Spec.SourceRef.Kind = "HelmRepository"</span>
        case GitRepositorySource:<span class="cov0" title="0">
                hr.Spec.Chart.Spec.SourceRef.Kind = "GitRepository"</span>
        case OCIRepositorySource:<span class="cov0" title="0">
                hr.Spec.Chart.Spec.SourceRef.Kind = "OCIRepository"</span>
        case BucketSource:<span class="cov0" title="0">
                hr.Spec.Chart.Spec.SourceRef.Kind = "Bucket"</span>
        default:<span class="cov0" title="0">
                // Default to HelmRepository if not specified
                hr.Spec.Chart.Spec.SourceRef.Kind = "HelmRepository"</span>
        }

        // Set values if provided
        <span class="cov0" title="0">if c.Values != nil </span><span class="cov0" title="0">{
                // Convert values to JSON
                valuesJSON := &amp;apiextensionsv1.JSON{}
                valuesJSON.Raw, _ = yaml.Marshal(c.Values)
                hr.Spec.Values = valuesJSON
        }</span>

        // Set timeout if provided
        <span class="cov0" title="0">if c.Timeout != "" </span><span class="cov0" title="0">{
                timeout, err := time.ParseDuration(c.Timeout)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid timeout: %w", err)
                }</span>
                <span class="cov0" title="0">hr.Spec.Timeout = &amp;metav1.Duration{Duration: timeout}</span>
        }

        // Set max history
        <span class="cov0" title="0">if c.MaxHistory &gt; 0 </span><span class="cov0" title="0">{
                hr.Spec.MaxHistory = &amp;c.MaxHistory
        }</span>

        // Set service account
        <span class="cov0" title="0">if c.ServiceAccount != "" </span><span class="cov0" title="0">{
                hr.Spec.ServiceAccountName = c.ServiceAccount
        }</span>

        // Set suspend
        <span class="cov0" title="0">hr.Spec.Suspend = c.Suspend

        // Set release options
        if c.Release.CreateNamespace </span><span class="cov0" title="0">{
                hr.Spec.Install = &amp;helmv2.Install{
                        CreateNamespace: c.Release.CreateNamespace,
                }
        }</span>

        // Set install/upgrade options
        <span class="cov0" title="0">hr.Spec.Install = &amp;helmv2.Install{
                CreateNamespace:          c.Release.CreateNamespace,
                DisableWait:              c.Release.DisableWait,
                DisableWaitForJobs:       c.Release.DisableWaitForJobs,
                DisableHooks:             c.Release.DisableHooks,
                DisableOpenAPIValidation: c.Release.DisableOpenAPIValidation,
                Replace:                  c.Release.Replace,
        }

        hr.Spec.Upgrade = &amp;helmv2.Upgrade{
                DisableWait:              c.Release.DisableWait,
                DisableWaitForJobs:       c.Release.DisableWaitForJobs,
                DisableHooks:             c.Release.DisableHooks,
                DisableOpenAPIValidation: c.Release.DisableOpenAPIValidation,
                Force:                    c.Release.ForceUpgrade,
                PreserveValues:           c.Release.PreserveValues,
                CleanupOnFail:            c.Release.CleanupOnFail,
        }

        // Set dependencies
        if len(c.DependsOn) &gt; 0 </span><span class="cov0" title="0">{
                hr.Spec.DependsOn = make([]meta.NamespacedObjectReference, 0, len(c.DependsOn))
                for _, dep := range c.DependsOn </span><span class="cov0" title="0">{
                        hr.Spec.DependsOn = append(hr.Spec.DependsOn, meta.NamespacedObjectReference{
                                Name: dep,
                        })
                }</span>
        }

        // Set post-renderers
        <span class="cov0" title="0">if len(c.PostRenderers) &gt; 0 </span><span class="cov0" title="0">{
                hr.Spec.PostRenderers = make([]helmv2.PostRenderer, 0, len(c.PostRenderers))
                for _, pr := range c.PostRenderers </span><span class="cov0" title="0">{
                        if pr.Kustomize != nil </span><span class="cov0" title="0">{
                                kustomizeObj := &amp;helmv2.Kustomize{}

                                // Add patches
                                for _, patch := range pr.Kustomize.Patches </span><span class="cov0" title="0">{
                                        kustomizeObj.Patches = append(kustomizeObj.Patches, kustomize.Patch{
                                                Target: patch.Target,
                                                Patch:  patch.Patch,
                                        })
                                }</span>

                                // Add images
                                <span class="cov0" title="0">for _, img := range pr.Kustomize.Images </span><span class="cov0" title="0">{
                                        kustomizeObj.Images = append(kustomizeObj.Images, kustomize.Image{
                                                Name:    img.Name,
                                                NewName: img.NewName,
                                                NewTag:  img.NewTag,
                                        })
                                }</span>

                                <span class="cov0" title="0">hr.Spec.PostRenderers = append(hr.Spec.PostRenderers, helmv2.PostRenderer{
                                        Kustomize: kustomizeObj,
                                })</span>
                        }
                }
        }

        <span class="cov0" title="0">return hr, nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package fluxhelm

import (
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/internal/gvk"
        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/generators"
        "github.com/go-kure/kure/pkg/stack/generators/fluxhelm/internal"
)

func init() <span class="cov1" title="1">{
        // Register the FluxHelm v1alpha1 generator with both registries
        gvkObj := gvk.GVK{
                Group:   "generators.gokure.dev",
                Version: "v1alpha1",
                Kind:    "FluxHelm",
        }

        factory := func() stack.ApplicationConfig </span><span class="cov3" title="2">{
                return &amp;ConfigV1Alpha1{}
        }</span>

        // Register with generators package for backward compatibility
        <span class="cov1" title="1">generators.Register(generators.GVK(gvkObj), factory)

        // Register with stack package for direct usage
        stack.RegisterApplicationConfig(gvkObj, factory)</span>
}

// ConfigV1Alpha1 generates Flux HelmRelease and source resources
type ConfigV1Alpha1 struct {
        generators.BaseMetadata `yaml:",inline" json:",inline"`

        // Chart configuration
        Chart   internal.ChartConfig `yaml:"chart" json:"chart"`
        Version string               `yaml:"version,omitempty" json:"version,omitempty"`
        Values  interface{}          `yaml:"values,omitempty" json:"values,omitempty"`

        // Source configuration
        Source internal.SourceConfig `yaml:"source" json:"source"`

        // Release configuration
        Release internal.ReleaseConfig `yaml:"release,omitempty" json:"release,omitempty"`

        // Advanced options
        Interval       string                  `yaml:"interval,omitempty" json:"interval,omitempty"`
        Timeout        string                  `yaml:"timeout,omitempty" json:"timeout,omitempty"`
        MaxHistory     int                     `yaml:"maxHistory,omitempty" json:"maxHistory,omitempty"`
        ServiceAccount string                  `yaml:"serviceAccount,omitempty" json:"serviceAccount,omitempty"`
        Suspend        bool                    `yaml:"suspend,omitempty" json:"suspend,omitempty"`
        DependsOn      []string                `yaml:"dependsOn,omitempty" json:"dependsOn,omitempty"`
        PostRenderers  []internal.PostRenderer `yaml:"postRenderers,omitempty" json:"postRenderers,omitempty"`
}

// GetAPIVersion returns the API version for this config
func (c *ConfigV1Alpha1) GetAPIVersion() string <span class="cov3" title="2">{
        return "generators.gokure.dev/v1alpha1"
}</span>

// GetKind returns the kind for this config
func (c *ConfigV1Alpha1) GetKind() string <span class="cov3" title="2">{
        return "FluxHelm"
}</span>

// Generate creates Flux HelmRelease and source resources
func (c *ConfigV1Alpha1) Generate(app *stack.Application) ([]*client.Object, error) <span class="cov10" title="15">{
        // Delegate to the internal implementation
        return internal.GenerateResources(&amp;internal.Config{
                Name:           c.Name,
                Namespace:      c.Namespace,
                Chart:          c.Chart,
                Version:        c.Version,
                Values:         c.Values,
                Source:         c.Source,
                Release:        c.Release,
                Interval:       c.Interval,
                Timeout:        c.Timeout,
                MaxHistory:     c.MaxHistory,
                ServiceAccount: c.ServiceAccount,
                Suspend:        c.Suspend,
                DependsOn:      c.DependsOn,
                PostRenderers:  c.PostRenderers,
        })
}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">package kurelpackage

import (
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/yaml"

        "github.com/go-kure/kure/internal/gvk"
        "github.com/go-kure/kure/pkg/errors"
        "github.com/go-kure/kure/pkg/stack"
        "github.com/go-kure/kure/pkg/stack/generators"
)

func init() <span class="cov1" title="1">{
        // Register the KurelPackage v1alpha1 generator
        gvkObj := gvk.GVK{
                Group:   "generators.gokure.dev",
                Version: "v1alpha1",
                Kind:    "KurelPackage",
        }

        factory := func() stack.ApplicationConfig </span><span class="cov5" title="4">{
                return &amp;ConfigV1Alpha1{}
        }</span>

        // Register with generators package for backward compatibility
        <span class="cov1" title="1">generators.Register(generators.GVK(gvkObj), factory)

        // Register with stack package for direct usage
        stack.RegisterApplicationConfig(gvkObj, factory)</span>
}

// ConfigV1Alpha1 generates a kurel package structure
type ConfigV1Alpha1 struct {
        generators.BaseMetadata `yaml:",inline" json:",inline"`

        // Package metadata
        Package PackageMetadata `yaml:"package" json:"package"`

        // Resources to include in the package
        Resources []ResourceSource `yaml:"resources,omitempty" json:"resources,omitempty"`

        // Patches to apply to resources
        Patches []PatchDefinition `yaml:"patches,omitempty" json:"patches,omitempty"`

        // Values configuration
        Values *ValuesConfig `yaml:"values,omitempty" json:"values,omitempty"`

        // Extensions for conditional features
        Extensions []Extension `yaml:"extensions,omitempty" json:"extensions,omitempty"`

        // Package dependencies
        Dependencies []Dependency `yaml:"dependencies,omitempty" json:"dependencies,omitempty"`

        // Build configuration
        Build *BuildConfig `yaml:"build,omitempty" json:"build,omitempty"`
}

// PackageMetadata contains kurel package metadata
type PackageMetadata struct {
        Name        string            `yaml:"name" json:"name"`
        Version     string            `yaml:"version" json:"version"`
        Description string            `yaml:"description,omitempty" json:"description,omitempty"`
        Authors     []string          `yaml:"authors,omitempty" json:"authors,omitempty"`
        License     string            `yaml:"license,omitempty" json:"license,omitempty"`
        Homepage    string            `yaml:"homepage,omitempty" json:"homepage,omitempty"`
        Repository  string            `yaml:"repository,omitempty" json:"repository,omitempty"`
        Keywords    []string          `yaml:"keywords,omitempty" json:"keywords,omitempty"`
        Labels      map[string]string `yaml:"labels,omitempty" json:"labels,omitempty"`
}

// ResourceSource defines where to find resources
type ResourceSource struct {
        Source   string   `yaml:"source" json:"source"`                         // Directory or file path
        Includes []string `yaml:"includes,omitempty" json:"includes,omitempty"` // Include patterns
        Excludes []string `yaml:"excludes,omitempty" json:"excludes,omitempty"` // Exclude patterns
        Recurse  bool     `yaml:"recurse,omitempty" json:"recurse,omitempty"`   // Recurse into subdirectories
}

// PatchDefinition defines a patch to apply
type PatchDefinition struct {
        Target PatchTarget `yaml:"target" json:"target"`
        Patch  string      `yaml:"patch" json:"patch"`                   // JSONPatch or strategic merge patch
        Type   string      `yaml:"type,omitempty" json:"type,omitempty"` // "json" or "strategic", default "json"
}

// PatchTarget identifies what to patch
type PatchTarget struct {
        APIVersion string            `yaml:"apiVersion,omitempty" json:"apiVersion,omitempty"`
        Kind       string            `yaml:"kind" json:"kind"`
        Name       string            `yaml:"name" json:"name"`
        Namespace  string            `yaml:"namespace,omitempty" json:"namespace,omitempty"`
        Labels     map[string]string `yaml:"labels,omitempty" json:"labels,omitempty"`
}

// ValuesConfig defines values schema and defaults
type ValuesConfig struct {
        Schema   string      `yaml:"schema,omitempty" json:"schema,omitempty"`     // Path to JSON schema
        Defaults string      `yaml:"defaults,omitempty" json:"defaults,omitempty"` // Path to default values
        Values   interface{} `yaml:"values,omitempty" json:"values,omitempty"`     // Inline default values
}

// Extension defines a conditional extension
type Extension struct {
        Name      string            `yaml:"name" json:"name"`
        When      string            `yaml:"when,omitempty" json:"when,omitempty"`           // CEL expression
        Resources []ResourceSource  `yaml:"resources,omitempty" json:"resources,omitempty"` // Additional resources
        Patches   []PatchDefinition `yaml:"patches,omitempty" json:"patches,omitempty"`     // Additional patches
}

// Dependency defines a package dependency
type Dependency struct {
        Name       string `yaml:"name" json:"name"`
        Version    string `yaml:"version" json:"version"`                           // Semantic version constraint
        Repository string `yaml:"repository,omitempty" json:"repository,omitempty"` // OCI repository
        Optional   bool   `yaml:"optional,omitempty" json:"optional,omitempty"`
}

// BuildConfig defines build-time configuration
type BuildConfig struct {
        OutputDir   string            `yaml:"outputDir,omitempty" json:"outputDir,omitempty"`     // Output directory for built package
        Format      string            `yaml:"format,omitempty" json:"format,omitempty"`           // "directory" or "oci"
        Registry    string            `yaml:"registry,omitempty" json:"registry,omitempty"`       // OCI registry for push
        Repository  string            `yaml:"repository,omitempty" json:"repository,omitempty"`   // OCI repository name
        Tags        []string          `yaml:"tags,omitempty" json:"tags,omitempty"`               // Additional tags
        Annotations map[string]string `yaml:"annotations,omitempty" json:"annotations,omitempty"` // OCI annotations
}

// GetAPIVersion returns the API version for this config
func (c *ConfigV1Alpha1) GetAPIVersion() string <span class="cov0" title="0">{
        return "generators.gokure.dev/v1alpha1"
}</span>

// GetKind returns the kind for this config
func (c *ConfigV1Alpha1) GetKind() string <span class="cov0" title="0">{
        return "KurelPackage"
}</span>

// Generate creates the kurel package structure
func (c *ConfigV1Alpha1) Generate(app *stack.Application) ([]*client.Object, error) <span class="cov1" title="1">{
        // For now, this is a placeholder implementation
        // The actual implementation would:
        // 1. Generate kurel.yaml with package metadata
        // 2. Copy/process resources according to ResourceSource definitions
        // 3. Generate patches in the appropriate format
        // 4. Create values schema and defaults
        // 5. Process extensions
        // 6. Validate dependencies
        // 7. Build the package according to BuildConfig

        // Since kurel packages aren't Kubernetes resources, we might need to
        // rethink this interface or create a separate generation path for
        // file-based outputs rather than client.Object outputs

        return nil, fmt.Errorf("KurelPackage generator not yet implemented")
}</span>

// GeneratePackageFiles generates the kurel package file structure
// This is a more appropriate interface for this generator type
func (c *ConfigV1Alpha1) GeneratePackageFiles(app *stack.Application) (map[string][]byte, error) <span class="cov1" title="1">{
        files := make(map[string][]byte)

        // Process resources first
        resourceFiles, err := c.gatherResources()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to gather resources")
        }</span>
        
        // Add resources to package under resources/ directory
        <span class="cov1" title="1">for path, content := range resourceFiles </span><span class="cov0" title="0">{
                files[filepath.Join("resources", path)] = content
        }</span>

        // Generate patches
        <span class="cov1" title="1">patchFiles, err := c.generatePatches()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to generate patches")
        }</span>
        
        // Add patches to package under patches/ directory
        <span class="cov1" title="1">for path, content := range patchFiles </span><span class="cov0" title="0">{
                files[filepath.Join("patches", path)] = content
        }</span>

        // Generate values files
        <span class="cov1" title="1">if c.Values != nil </span><span class="cov0" title="0">{
                valuesFiles, err := c.generateValues()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to generate values")
                }</span>
                
                // Add values to package under values/ directory
                <span class="cov0" title="0">for path, content := range valuesFiles </span><span class="cov0" title="0">{
                        files[filepath.Join("values", path)] = content
                }</span>
        }

        // Process extensions
        <span class="cov1" title="1">for i, ext := range c.Extensions </span><span class="cov0" title="0">{
                extFiles, err := c.processExtension(ext, i)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to process extension %s", ext.Name)
                }</span>
                
                // Add extension files under extensions/&lt;name&gt;/ directory
                <span class="cov0" title="0">for path, content := range extFiles </span><span class="cov0" title="0">{
                        files[filepath.Join("extensions", ext.Name, path)] = content
                }</span>
        }

        // Generate kurel.yaml (after processing all components)
        <span class="cov1" title="1">kurelYAML, err := c.generateKurelYAML(files)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to generate kurel.yaml")
        }</span>
        <span class="cov1" title="1">files["kurel.yaml"] = kurelYAML

        return files, nil</span>
}

// gatherResources collects resources from filesystem according to ResourceSource definitions
func (c *ConfigV1Alpha1) gatherResources() (map[string][]byte, error) <span class="cov1" title="1">{
        files := make(map[string][]byte)
        
        for _, resource := range c.Resources </span><span class="cov0" title="0">{
                resourceFiles, err := c.gatherResourcesFromSource(resource)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to gather resources from source %s", resource.Source)
                }</span>
                
                // Merge collected files, handling potential conflicts
                <span class="cov0" title="0">for path, content := range resourceFiles </span><span class="cov0" title="0">{
                        if _, exists := files[path]; exists </span><span class="cov0" title="0">{
                                return nil, errors.Errorf("duplicate resource file: %s (conflicts between sources)", path)
                        }</span>
                        <span class="cov0" title="0">files[path] = content</span>
                }
        }
        
        <span class="cov1" title="1">return files, nil</span>
}

// gatherResourcesFromSource collects resources from a single ResourceSource
func (c *ConfigV1Alpha1) gatherResourcesFromSource(resource ResourceSource) (map[string][]byte, error) <span class="cov0" title="0">{
        files := make(map[string][]byte)
        
        // Check if source exists
        info, err := os.Stat(resource.Source)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "resource source not found: %s", resource.Source)
        }</span>
        
        <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                // Collect from directory
                err = c.walkDirectory(resource.Source, resource, files)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to walk directory %s", resource.Source)
                }</span>
        } else<span class="cov0" title="0"> {
                // Single file
                if c.shouldIncludeFile(resource.Source, resource) </span><span class="cov0" title="0">{
                        content, err := os.ReadFile(resource.Source)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrapf(err, "failed to read file %s", resource.Source)
                        }</span>
                        
                        // Validate it's a Kubernetes resource
                        <span class="cov0" title="0">if c.isKubernetesResource(content) </span><span class="cov0" title="0">{
                                // Use relative path from source directory
                                relPath := filepath.Base(resource.Source)
                                files[relPath] = content
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return files, nil</span>
}

// walkDirectory recursively walks a directory collecting matching files
func (c *ConfigV1Alpha1) walkDirectory(root string, resource ResourceSource, files map[string][]byte) error <span class="cov0" title="0">{
        return filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // Skip directories
                <span class="cov0" title="0">if d.IsDir() </span><span class="cov0" title="0">{
                        // Check if we should recurse
                        if !resource.Recurse &amp;&amp; path != root </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                
                // Check if file should be included
                <span class="cov0" title="0">if !c.shouldIncludeFile(path, resource) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                // Read and validate file
                <span class="cov0" title="0">content, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to read file %s", path)
                }</span>
                
                // Validate it's a Kubernetes resource
                <span class="cov0" title="0">if !c.isKubernetesResource(content) </span><span class="cov0" title="0">{
                        return nil // Skip non-Kubernetes files
                }</span>
                
                // Get relative path from root
                <span class="cov0" title="0">relPath, err := filepath.Rel(root, path)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to get relative path for %s", path)
                }</span>
                
                <span class="cov0" title="0">files[relPath] = content
                return nil</span>
        })
}

// shouldIncludeFile checks if a file matches include/exclude patterns
func (c *ConfigV1Alpha1) shouldIncludeFile(path string, resource ResourceSource) bool <span class="cov0" title="0">{
        fileName := filepath.Base(path)
        
        // Check excludes first
        for _, exclude := range resource.Excludes </span><span class="cov0" title="0">{
                if matched, _ := filepath.Match(exclude, fileName); matched </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        // Check includes (if any specified)
        <span class="cov0" title="0">if len(resource.Includes) == 0 </span><span class="cov0" title="0">{
                // No includes specified, include by default (unless excluded)
                return true
        }</span>
        
        <span class="cov0" title="0">for _, include := range resource.Includes </span><span class="cov0" title="0">{
                if matched, _ := filepath.Match(include, fileName); matched </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

// isKubernetesResource validates that content contains a Kubernetes resource
func (c *ConfigV1Alpha1) isKubernetesResource(content []byte) bool <span class="cov0" title="0">{
        var resource struct {
                APIVersion string `yaml:"apiVersion"`
                Kind       string `yaml:"kind"`
        }
        
        err := yaml.Unmarshal(content, &amp;resource)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return resource.APIVersion != "" &amp;&amp; resource.Kind != ""</span>
}

// generatePatches creates patch files from PatchDefinitions
func (c *ConfigV1Alpha1) generatePatches() (map[string][]byte, error) <span class="cov1" title="1">{
        files := make(map[string][]byte)
        
        for i, patch := range c.Patches </span><span class="cov0" title="0">{
                patchContent, err := c.generatePatchFile(patch, i)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to generate patch %d", i)
                }</span>
                
                <span class="cov0" title="0">patchFile := fmt.Sprintf("patch-%03d.yaml", i)
                files[patchFile] = patchContent</span>
        }
        
        <span class="cov1" title="1">return files, nil</span>
}

// generatePatchFile creates a single patch file from PatchDefinition
func (c *ConfigV1Alpha1) generatePatchFile(patch PatchDefinition, index int) ([]byte, error) <span class="cov0" title="0">{
        patchDoc := map[string]interface{}{
                "apiVersion": "kurel.gokure.dev/v1alpha1",
                "kind":       "Patch",
                "metadata": map[string]interface{}{
                        "name": fmt.Sprintf("patch-%03d", index),
                },
                "spec": map[string]interface{}{
                        "target": patch.Target,
                        "patch":  patch.Patch,
                        "type":   patch.Type,
                },
        }
        
        return yaml.Marshal(patchDoc)
}</span>

// generateValues creates values files from ValuesConfig
func (c *ConfigV1Alpha1) generateValues() (map[string][]byte, error) <span class="cov0" title="0">{
        files := make(map[string][]byte)
        
        // Generate default values
        if c.Values.Defaults != "" </span><span class="cov0" title="0">{
                // Read defaults file
                defaultsContent, err := os.ReadFile(c.Values.Defaults)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to read defaults file %s", c.Values.Defaults)
                }</span>
                <span class="cov0" title="0">files["values.yaml"] = defaultsContent</span>
        } else<span class="cov0" title="0"> if c.Values.Values != nil </span><span class="cov0" title="0">{
                // Generate from inline values
                valuesContent, err := yaml.Marshal(c.Values.Values)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal inline values")
                }</span>
                <span class="cov0" title="0">files["values.yaml"] = valuesContent</span>
        }
        
        // Generate schema
        <span class="cov0" title="0">if c.Values.Schema != "" </span><span class="cov0" title="0">{
                schemaContent, err := os.ReadFile(c.Values.Schema)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to read schema file %s", c.Values.Schema)
                }</span>
                <span class="cov0" title="0">files["values.schema.json"] = schemaContent</span>
        }
        
        <span class="cov0" title="0">return files, nil</span>
}

// processExtension processes a single extension
func (c *ConfigV1Alpha1) processExtension(ext Extension, index int) (map[string][]byte, error) <span class="cov0" title="0">{
        files := make(map[string][]byte)
        
        // Process extension resources
        if len(ext.Resources) &gt; 0 </span><span class="cov0" title="0">{
                for i, resource := range ext.Resources </span><span class="cov0" title="0">{
                        resourceFiles, err := c.gatherResourcesFromSource(resource)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrapf(err, "failed to gather extension resources from source %s", resource.Source)
                        }</span>
                        
                        // Add with prefix to avoid conflicts
                        <span class="cov0" title="0">for path, content := range resourceFiles </span><span class="cov0" title="0">{
                                prefixedPath := fmt.Sprintf("resources-%d/%s", i, path)
                                files[prefixedPath] = content
                        }</span>
                }
        }
        
        // Process extension patches
        <span class="cov0" title="0">if len(ext.Patches) &gt; 0 </span><span class="cov0" title="0">{
                for i, patch := range ext.Patches </span><span class="cov0" title="0">{
                        patchContent, err := c.generatePatchFile(patch, i)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrapf(err, "failed to generate extension patch %d", i)
                        }</span>
                        
                        <span class="cov0" title="0">patchFile := fmt.Sprintf("patches/patch-%03d.yaml", i)
                        files[patchFile] = patchContent</span>
                }
        }
        
        // Generate extension manifest
        <span class="cov0" title="0">extManifest := map[string]interface{}{
                "apiVersion": "kurel.gokure.dev/v1alpha1",
                "kind":       "Extension",
                "metadata": map[string]interface{}{
                        "name": ext.Name,
                },
                "spec": map[string]interface{}{
                        "when": ext.When,
                },
        }
        
        manifestContent, err := yaml.Marshal(extManifest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to marshal extension manifest")
        }</span>
        <span class="cov0" title="0">files["extension.yaml"] = manifestContent
        
        return files, nil</span>
}

// generateKurelYAML creates the main package manifest
func (c *ConfigV1Alpha1) generateKurelYAML(packageFiles map[string][]byte) ([]byte, error) <span class="cov1" title="1">{
        // Build file inventory
        var resourceFiles, patchFiles, valueFiles, extensionDirs []string
        
        for path := range packageFiles </span><span class="cov0" title="0">{
                switch </span>{
                case strings.HasPrefix(path, "resources/"):<span class="cov0" title="0">
                        resourceFiles = append(resourceFiles, strings.TrimPrefix(path, "resources/"))</span>
                case strings.HasPrefix(path, "patches/"):<span class="cov0" title="0">
                        patchFiles = append(patchFiles, strings.TrimPrefix(path, "patches/"))</span>
                case strings.HasPrefix(path, "values/"):<span class="cov0" title="0">
                        valueFiles = append(valueFiles, strings.TrimPrefix(path, "values/"))</span>
                case strings.HasPrefix(path, "extensions/"):<span class="cov0" title="0">
                        parts := strings.Split(strings.TrimPrefix(path, "extensions/"), "/")
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                extDir := parts[0]
                                found := false
                                for _, existing := range extensionDirs </span><span class="cov0" title="0">{
                                        if existing == extDir </span><span class="cov0" title="0">{
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        extensionDirs = append(extensionDirs, extDir)
                                }</span>
                        }
                }
        }
        
        <span class="cov1" title="1">kurelDoc := map[string]interface{}{
                "apiVersion": "kurel.gokure.dev/v1alpha1",
                "kind":       "Package",
                "metadata": map[string]interface{}{
                        "name":        c.Package.Name,
                        "version":     c.Package.Version,
                        "description": c.Package.Description,
                        "authors":     c.Package.Authors,
                        "license":     c.Package.License,
                        "homepage":    c.Package.Homepage,
                        "repository":  c.Package.Repository,
                        "keywords":    c.Package.Keywords,
                        "labels":      c.Package.Labels,
                },
                "spec": map[string]interface{}{
                        "resources":  resourceFiles,
                        "patches":    patchFiles,
                        "values":     valueFiles,
                        "extensions": extensionDirs,
                },
        }
        
        // Add dependencies if any
        if len(c.Dependencies) &gt; 0 </span><span class="cov0" title="0">{
                deps := make([]map[string]interface{}, len(c.Dependencies))
                for i, dep := range c.Dependencies </span><span class="cov0" title="0">{
                        deps[i] = map[string]interface{}{
                                "name":       dep.Name,
                                "version":    dep.Version,
                                "repository": dep.Repository,
                                "optional":   dep.Optional,
                        }
                }</span>
                <span class="cov0" title="0">kurelDoc["spec"].(map[string]interface{})["dependencies"] = deps</span>
        }
        
        // Add build config if any
        <span class="cov1" title="1">if c.Build != nil </span><span class="cov0" title="0">{
                kurelDoc["spec"].(map[string]interface{})["build"] = map[string]interface{}{
                        "outputDir":   c.Build.OutputDir,
                        "format":      c.Build.Format,
                        "registry":    c.Build.Registry,
                        "repository":  c.Build.Repository,
                        "tags":        c.Build.Tags,
                        "annotations": c.Build.Annotations,
                }
        }</span>
        
        <span class="cov1" title="1">return yaml.Marshal(kurelDoc)</span>
}

// Validate checks if the configuration is valid
func (c *ConfigV1Alpha1) Validate() error <span class="cov5" title="4">{
        // Validate required fields
        if c.Package.Name == "" </span><span class="cov1" title="1">{
                return errors.New("package name is required")
        }</span>
        <span class="cov4" title="3">if c.Package.Version == "" </span><span class="cov0" title="0">{
                return errors.New("package version is required")
        }</span>

        // Validate package name format (kubernetes resource name rules)
        <span class="cov4" title="3">if err := c.validatePackageName(c.Package.Name); err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, "invalid package name")
        }</span>

        // Validate version format (semantic versioning)
        <span class="cov3" title="2">if err := c.validateVersionFormat(c.Package.Version); err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, "invalid package version")
        }</span>

        // Validate resource sources exist
        <span class="cov1" title="1">for i, resource := range c.Resources </span><span class="cov0" title="0">{
                if err := c.validateResourceSource(resource); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "invalid resource source %d", i)
                }</span>
        }

        // Validate patch syntax
        <span class="cov1" title="1">for i, patch := range c.Patches </span><span class="cov0" title="0">{
                if err := c.validatePatchDefinition(patch); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "invalid patch definition %d", i)
                }</span>
        }

        // Validate values configuration
        <span class="cov1" title="1">if c.Values != nil </span><span class="cov0" title="0">{
                if err := c.validateValuesConfig(*c.Values); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "invalid values configuration")
                }</span>
        }

        // Validate extensions
        <span class="cov1" title="1">for i, ext := range c.Extensions </span><span class="cov0" title="0">{
                if err := c.validateExtension(ext); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "invalid extension %d (%s)", i, ext.Name)
                }</span>
        }

        // Validate dependencies
        <span class="cov1" title="1">for i, dep := range c.Dependencies </span><span class="cov0" title="0">{
                if err := c.validateDependency(dep); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "invalid dependency %d (%s)", i, dep.Name)
                }</span>
        }

        // Validate build configuration
        <span class="cov1" title="1">if c.Build != nil </span><span class="cov0" title="0">{
                if err := c.validateBuildConfig(*c.Build); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "invalid build configuration")
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// validatePackageName checks if package name follows Kubernetes naming rules
func (c *ConfigV1Alpha1) validatePackageName(name string) error <span class="cov4" title="3">{
        // Kubernetes resource names must be DNS compatible
        if len(name) == 0 || len(name) &gt; 253 </span><span class="cov0" title="0">{
                return errors.New("name must be 1-253 characters")
        }</span>

        // Must start and end with alphanumeric
        <span class="cov4" title="3">nameRegex := regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`)
        if !nameRegex.MatchString(name) </span><span class="cov1" title="1">{
                return errors.New("name must start and end with alphanumeric characters and contain only lowercase letters, numbers, and hyphens")
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// validateVersionFormat checks if version follows semantic versioning
func (c *ConfigV1Alpha1) validateVersionFormat(version string) error <span class="cov10" title="15">{
        // Basic semantic versioning pattern
        semverRegex := regexp.MustCompile(`^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-[a-zA-Z0-9]+([-.]?[a-zA-Z0-9]+)*)?(\+[a-zA-Z0-9]+([-.]?[a-zA-Z0-9]+)*)?$`)
        if !semverRegex.MatchString(version) </span><span class="cov7" title="8">{
                return errors.New("version must follow semantic versioning format (e.g., 1.0.0, 1.0.0-alpha.1)")
        }</span>

        <span class="cov7" title="7">return nil</span>
}

// validateResourceSource checks if resource source is valid
func (c *ConfigV1Alpha1) validateResourceSource(resource ResourceSource) error <span class="cov0" title="0">{
        if resource.Source == "" </span><span class="cov0" title="0">{
                return errors.New("resource source path is required")
        }</span>

        // Check if source path exists
        <span class="cov0" title="0">if _, err := os.Stat(resource.Source); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "resource source path does not exist: %s", resource.Source)
        }</span>

        // Validate include/exclude patterns
        <span class="cov0" title="0">for _, pattern := range resource.Includes </span><span class="cov0" title="0">{
                if _, err := filepath.Match(pattern, "test"); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "invalid include pattern: %s", pattern)
                }</span>
        }

        <span class="cov0" title="0">for _, pattern := range resource.Excludes </span><span class="cov0" title="0">{
                if _, err := filepath.Match(pattern, "test"); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "invalid exclude pattern: %s", pattern)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validatePatchDefinition checks if patch definition is valid
func (c *ConfigV1Alpha1) validatePatchDefinition(patch PatchDefinition) error <span class="cov4" title="3">{
        // Validate target
        if patch.Target.Kind == "" </span><span class="cov0" title="0">{
                return errors.New("patch target kind is required")
        }</span>
        <span class="cov4" title="3">if patch.Target.Name == "" </span><span class="cov0" title="0">{
                return errors.New("patch target name is required")
        }</span>

        // Validate patch content
        <span class="cov4" title="3">if patch.Patch == "" </span><span class="cov0" title="0">{
                return errors.New("patch content is required")
        }</span>

        // Validate patch type
        <span class="cov4" title="3">patchType := patch.Type
        if patchType == "" </span><span class="cov0" title="0">{
                patchType = "json" // default
        }</span>

        <span class="cov4" title="3">switch patchType </span>{
        case "json":<span class="cov3" title="2">
                // Validate JSON patch syntax
                if err := c.validateJSONPatch(patch.Patch); err != nil </span><span class="cov1" title="1">{
                        return errors.Wrap(err, "invalid JSON patch")
                }</span>
        case "strategic":<span class="cov1" title="1">
                // Validate strategic merge patch syntax (basic YAML validation)
                if err := c.validateStrategicMergePatch(patch.Patch); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "invalid strategic merge patch")
                }</span>
        default:<span class="cov0" title="0">
                return errors.New("patch type must be 'json' or 'strategic'")</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// validateJSONPatch validates JSON patch syntax
func (c *ConfigV1Alpha1) validateJSONPatch(patchContent string) error <span class="cov3" title="2">{
        // Try to parse as YAML first (since patches are often written in YAML)
        var jsonPatch []map[string]interface{}
        if err := yaml.Unmarshal([]byte(patchContent), &amp;jsonPatch); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "patch content is not valid YAML/JSON")
        }</span>

        // Validate each operation
        <span class="cov3" title="2">for i, op := range jsonPatch </span><span class="cov3" title="2">{
                operation, ok := op["op"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return errors.Errorf("operation %d missing 'op' field", i)
                }</span>

                <span class="cov3" title="2">path, ok := op["path"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return errors.Errorf("operation %d missing 'path' field", i)
                }</span>

                // Validate operation type
                <span class="cov3" title="2">switch operation </span>{
                case "add", "replace", "test":<span class="cov1" title="1">
                        if _, ok := op["value"]; !ok </span><span class="cov0" title="0">{
                                return errors.Errorf("operation %d (%s) missing 'value' field", i, operation)
                        }</span>
                case "remove":<span class="cov0" title="0"></span>
                        // Remove doesn't need value
                case "move", "copy":<span class="cov0" title="0">
                        if _, ok := op["from"].(string); !ok </span><span class="cov0" title="0">{
                                return errors.Errorf("operation %d (%s) missing 'from' field", i, operation)
                        }</span>
                default:<span class="cov1" title="1">
                        return errors.Errorf("operation %d has invalid op '%s'", i, operation)</span>
                }

                // Basic path validation (must start with /)
                <span class="cov1" title="1">if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                        return errors.Errorf("operation %d path must start with '/'", i)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// validateStrategicMergePatch validates strategic merge patch syntax
func (c *ConfigV1Alpha1) validateStrategicMergePatch(patchContent string) error <span class="cov1" title="1">{
        // Strategic merge patches are just YAML documents
        var patch map[string]interface{}
        if err := yaml.Unmarshal([]byte(patchContent), &amp;patch); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "patch content is not valid YAML")
        }</span>

        // Basic validation - should be a non-empty map
        <span class="cov1" title="1">if len(patch) == 0 </span><span class="cov0" title="0">{
                return errors.New("strategic merge patch cannot be empty")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// validateValuesConfig checks if values configuration is valid
func (c *ConfigV1Alpha1) validateValuesConfig(values ValuesConfig) error <span class="cov0" title="0">{
        // At least one of defaults file, schema file, or inline values should be provided
        if values.Defaults == "" &amp;&amp; values.Schema == "" &amp;&amp; values.Values == nil </span><span class="cov0" title="0">{
                return errors.New("values configuration must specify at least one of: defaults file, schema file, or inline values")
        }</span>

        // Check if defaults file exists
        <span class="cov0" title="0">if values.Defaults != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(values.Defaults); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "defaults file does not exist: %s", values.Defaults)
                }</span>
        }

        // Check if schema file exists
        <span class="cov0" title="0">if values.Schema != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(values.Schema); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "schema file does not exist: %s", values.Schema)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateExtension checks if extension configuration is valid
func (c *ConfigV1Alpha1) validateExtension(ext Extension) error <span class="cov0" title="0">{
        if ext.Name == "" </span><span class="cov0" title="0">{
                return errors.New("extension name is required")
        }</span>

        // Validate extension name format
        <span class="cov0" title="0">if err := c.validatePackageName(ext.Name); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "invalid extension name")
        }</span>

        // Validate CEL expression (basic syntax check)
        <span class="cov0" title="0">if ext.When != "" </span><span class="cov0" title="0">{
                if err := c.validateCELExpression(ext.When); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "invalid CEL expression in when clause")
                }</span>
        }

        // Validate extension resources
        <span class="cov0" title="0">for i, resource := range ext.Resources </span><span class="cov0" title="0">{
                if err := c.validateResourceSource(resource); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "invalid extension resource %d", i)
                }</span>
        }

        // Validate extension patches
        <span class="cov0" title="0">for i, patch := range ext.Patches </span><span class="cov0" title="0">{
                if err := c.validatePatchDefinition(patch); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "invalid extension patch %d", i)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateCELExpression performs basic CEL expression validation
func (c *ConfigV1Alpha1) validateCELExpression(expr string) error <span class="cov7" title="8">{
        // Basic validation - should not be empty and should contain valid identifiers
        if strings.TrimSpace(expr) == "" </span><span class="cov3" title="2">{
                return errors.New("CEL expression cannot be empty")
        }</span>

        // Check for common CEL patterns (.Values, operators, etc.)
        <span class="cov6" title="6">if !strings.Contains(expr, ".Values") </span><span class="cov3" title="2">{
                return errors.New("CEL expression should reference .Values")
        }</span>

        // TODO: Add proper CEL validation using cel-go library
        // For now, just do basic syntax checks
        <span class="cov5" title="4">invalidChars := regexp.MustCompile(`[^a-zA-Z0-9_.()[\]&lt;&gt;=!&amp;|+\-*/%\s"']`)
        if invalidChars.MatchString(expr) </span><span class="cov0" title="0">{
                return errors.New("CEL expression contains invalid characters")
        }</span>

        <span class="cov5" title="4">return nil</span>
}

// validateDependency checks if dependency specification is valid
func (c *ConfigV1Alpha1) validateDependency(dep Dependency) error <span class="cov0" title="0">{
        if dep.Name == "" </span><span class="cov0" title="0">{
                return errors.New("dependency name is required")
        }</span>

        <span class="cov0" title="0">if dep.Version == "" </span><span class="cov0" title="0">{
                return errors.New("dependency version is required")
        }</span>

        // Validate dependency name format
        <span class="cov0" title="0">if err := c.validatePackageName(dep.Name); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "invalid dependency name")
        }</span>

        // Validate version constraint format (basic semantic versioning or constraint)
        <span class="cov0" title="0">if err := c.validateVersionConstraint(dep.Version); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "invalid dependency version constraint")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateVersionConstraint validates semantic version constraints
func (c *ConfigV1Alpha1) validateVersionConstraint(constraint string) error <span class="cov0" title="0">{
        // Allow version constraints like "&gt;=1.0.0", "~1.2.0", "^1.0.0", etc.
        constraintRegex := regexp.MustCompile(`^([\^~&gt;=&lt;]+)?(\d+\.\d+\.\d+)(-[a-zA-Z0-9]+([-.]?[a-zA-Z0-9]+)*)?(\+[a-zA-Z0-9]+([-.]?[a-zA-Z0-9]+)*)?$`)
        if !constraintRegex.MatchString(constraint) </span><span class="cov0" title="0">{
                return errors.New("version constraint must be a valid semantic version or constraint (e.g., '1.0.0', '&gt;=1.0.0', '^1.2.0')")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateBuildConfig checks if build configuration is valid
func (c *ConfigV1Alpha1) validateBuildConfig(build BuildConfig) error <span class="cov0" title="0">{
        // Validate format
        if build.Format != "" &amp;&amp; build.Format != "directory" &amp;&amp; build.Format != "oci" </span><span class="cov0" title="0">{
                return errors.New("build format must be 'directory' or 'oci'")
        }</span>

        // If OCI format, validate registry/repository
        <span class="cov0" title="0">if build.Format == "oci" </span><span class="cov0" title="0">{
                if build.Registry == "" </span><span class="cov0" title="0">{
                        return errors.New("registry is required for OCI format")
                }</span>
                <span class="cov0" title="0">if build.Repository == "" </span><span class="cov0" title="0">{
                        return errors.New("repository is required for OCI format")
                }</span>
        }

        // Validate output directory if specified
        <span class="cov0" title="0">if build.OutputDir != "" </span><span class="cov0" title="0">{
                // Check if parent directory exists
                parentDir := filepath.Dir(build.OutputDir)
                if parentDir != "." </span><span class="cov0" title="0">{
                        if _, err := os.Stat(parentDir); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrapf(err, "output directory parent does not exist: %s", parentDir)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package generators

import (
        "github.com/go-kure/kure/internal/gvk"
        "github.com/go-kure/kure/pkg/stack"
)

// Re-export GVK type for backward compatibility
type GVK = gvk.GVK

// Re-export common functions for backward compatibility
var (
        ParseAPIVersion = gvk.ParseAPIVersion
)

// ApplicationConfigFactory is a function that creates a new ApplicationConfig instance
type ApplicationConfigFactory = gvk.Factory[stack.ApplicationConfig]

// globalRegistry is the singleton registry instance for ApplicationConfig
var globalRegistry = gvk.NewRegistry[stack.ApplicationConfig]()

// Register adds a new ApplicationConfig type to the global registry
func Register(gvk GVK, factory ApplicationConfigFactory) <span class="cov10" title="3">{
        globalRegistry.Register(gvk, factory)
}</span>

// Create creates a new ApplicationConfig instance for the given apiVersion and kind
func Create(apiVersion, kind string) (stack.ApplicationConfig, error) <span class="cov0" title="0">{
        parsed := gvk.ParseAPIVersion(apiVersion, kind)
        return globalRegistry.Create(parsed)
}</span>

// CreateFromGVK creates a new ApplicationConfig instance for the given GVK
func CreateFromGVK(gvkObj GVK) (stack.ApplicationConfig, error) <span class="cov6" title="2">{
        return globalRegistry.Create(gvkObj)
}</span>

// ListKinds returns all registered GVKs from the global registry
func ListKinds() []GVK <span class="cov1" title="1">{
        return globalRegistry.ListGVKs()
}</span>

// HasKind checks if a GVK is registered in the global registry
func HasKind(apiVersion, kind string) bool <span class="cov6" title="2">{
        return globalRegistry.HasAPIVersion(apiVersion, kind)
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package layout

import (
        "fmt"
        "strings"
)

// ManifestFileNameFunc returns a file name for the given namespace, kind and resource name.
type ManifestFileNameFunc func(namespace, kind, name string, mode FileExportMode) string

// KustomizationFileNameFunc returns the file name for a Flux Kustomization manifest.
type KustomizationFileNameFunc func(name string) string

// Config LayoutConfig defines rules for generating a cluster layout.
type Config struct {
        // ManifestsDir is the directory under which Kubernetes manifests are written.
        ManifestsDir string
        // FluxDir is the directory under which Flux manifests are written.
        FluxDir string
        // FilePer determines how resources are grouped into files when writing manifests.
        FilePer FileExportMode
        // ApplicationFileMode controls whether application resources are written
        // to a single file or split per resource. Defaults to AppFilePerResource.
        ApplicationFileMode ApplicationFileMode
        // KustomizationMode controls how kustomization.yaml files are generated.
        // Defaults to KustomizationExplicit.
        KustomizationMode KustomizationMode
        // ManifestFileName formats the file name for a resource manifest.
        ManifestFileName ManifestFileNameFunc
        // KustomizationFileName formats the file name for a Flux Kustomization.
        KustomizationFileName KustomizationFileNameFunc
}

// DefaultLayoutConfig returns a configuration that matches the directory layout
// expected by FluxCD when writing manifests and Kustomizations.
func DefaultLayoutConfig() Config <span class="cov8" title="1">{
        return Config{
                ManifestsDir:          "clusters",
                FluxDir:               "clusters",
                FilePer:               FilePerResource,
                ApplicationFileMode:   AppFilePerResource,
                KustomizationMode:     KustomizationExplicit,
                ManifestFileName:      DefaultManifestFileName,
                KustomizationFileName: DefaultKustomizationFileName,
        }
}</span>

// DefaultManifestFileName implements the standard file naming convention used
// by Kure. It writes either one file per resource or groups by kind depending
// on the FileExportMode.
func DefaultManifestFileName(namespace, kind, name string, mode FileExportMode) string <span class="cov0" title="0">{
        kind = strings.ToLower(kind)
        switch mode </span>{
        case FilePerKind:<span class="cov0" title="0">
                return fmt.Sprintf("%s-%s.yaml", namespace, kind)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%s-%s-%s.yaml", namespace, kind, name)</span>
        }
}

// DefaultKustomizationFileName returns the standard Flux Kustomization file name.
func DefaultKustomizationFileName(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("kustomization-%s.yaml", name)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package layout

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "k8s.io/apimachinery/pkg/runtime/schema"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/errors"
        kio "github.com/go-kure/kure/pkg/io"
)

type ManifestLayout struct {
        Name                string
        Namespace           string
        PackageRef          *schema.GroupVersionKind
        FilePer             FileExportMode
        ApplicationFileMode ApplicationFileMode
        Mode                KustomizationMode
        FluxPlacement       FluxPlacement // Track flux placement mode for kustomization generation
        Resources           []client.Object
        Children            []*ManifestLayout
}

func (ml *ManifestLayout) FullRepoPath() string <span class="cov9" title="24">{
        ns := ml.Namespace
        if ns == "" </span><span class="cov0" title="0">{
                ns = "cluster"
        }</span>

        // Don't duplicate the name if it's already at the end of the namespace
        <span class="cov9" title="24">if ml.Name != "" &amp;&amp; strings.HasSuffix(ns, ml.Name) </span><span class="cov5" title="5">{
                return filepath.ToSlash(ns)
        }</span>

        <span class="cov9" title="19">return filepath.ToSlash(filepath.Join(ns, ml.Name))</span>
}

// FullRepoPathWithPackage returns the repository path including package-specific prefix
func (ml *ManifestLayout) FullRepoPathWithPackage() string <span class="cov0" title="0">{
        basePath := ml.FullRepoPath()
        if ml.PackageRef != nil </span><span class="cov0" title="0">{
                // Use package kind as prefix to avoid path collisions
                prefix := strings.ToLower(ml.PackageRef.Kind)
                if prefix == "ocirepository" </span><span class="cov0" title="0">{
                        prefix = "oci"
                }</span> else<span class="cov0" title="0"> if prefix == "gitrepository" </span><span class="cov0" title="0">{
                        prefix = "git"
                }</span>
                <span class="cov0" title="0">return filepath.ToSlash(filepath.Join(prefix, basePath))</span>
        }
        <span class="cov0" title="0">return basePath</span>
}

// WritePackagesToDisk writes multiple package layouts to separate directory structures
func WritePackagesToDisk(packages map[string]*ManifestLayout, basePath string) error <span class="cov7" title="11">{
        for packageKey, layout := range packages </span><span class="cov8" title="13">{
                if layout == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create package-specific subdirectory with proper sanitization
                <span class="cov8" title="13">packageDirName := sanitizePackageKey(packageKey)
                packagePath := filepath.Join(basePath, packageDirName)

                if err := layout.WriteToDisk(packagePath); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, fmt.Sprintf("write package %s to disk", packageKey))
                }</span>
        }
        <span class="cov7" title="11">return nil</span>
}

// sanitizePackageKey converts package reference strings to valid directory names
func sanitizePackageKey(packageKey string) string <span class="cov8" title="13">{
        if packageKey == "default" </span><span class="cov2" title="2">{
                return "default"
        }</span>

        // Convert common GroupVersionKind strings to meaningful names
        <span class="cov7" title="11">if strings.Contains(packageKey, "OCIRepository") </span><span class="cov2" title="2">{
                return "oci-packages"
        }</span>
        <span class="cov7" title="9">if strings.Contains(packageKey, "GitRepository") </span><span class="cov1" title="1">{
                return "git-packages"
        }</span>
        <span class="cov6" title="8">if strings.Contains(packageKey, "Bucket") </span><span class="cov0" title="0">{
                return "bucket-packages"
        }</span>

        // Fallback: sanitize the full string
        <span class="cov6" title="8">sanitized := packageKey

        // Replace problematic characters with safe alternatives
        sanitized = strings.ReplaceAll(sanitized, "/", "-")
        sanitized = strings.ReplaceAll(sanitized, "\\", "-")
        sanitized = strings.ReplaceAll(sanitized, ":", "-")
        sanitized = strings.ReplaceAll(sanitized, " ", "-")
        sanitized = strings.ReplaceAll(sanitized, ",", "-")
        sanitized = strings.ReplaceAll(sanitized, "=", "-")
        sanitized = strings.ReplaceAll(sanitized, "&amp;", "-")
        sanitized = strings.ReplaceAll(sanitized, "?", "-")
        sanitized = strings.ReplaceAll(sanitized, "#", "-")
        sanitized = strings.ReplaceAll(sanitized, "!", "-")
        sanitized = strings.ReplaceAll(sanitized, "@", "-")
        sanitized = strings.ReplaceAll(sanitized, "%", "-")
        sanitized = strings.ReplaceAll(sanitized, "^", "-")
        sanitized = strings.ReplaceAll(sanitized, "*", "-")
        sanitized = strings.ReplaceAll(sanitized, "(", "-")
        sanitized = strings.ReplaceAll(sanitized, ")", "-")
        sanitized = strings.ReplaceAll(sanitized, "+", "-")
        sanitized = strings.ReplaceAll(sanitized, "|", "-")
        sanitized = strings.ReplaceAll(sanitized, "[", "-")
        sanitized = strings.ReplaceAll(sanitized, "]", "-")
        sanitized = strings.ReplaceAll(sanitized, "{", "-")
        sanitized = strings.ReplaceAll(sanitized, "}", "-")
        sanitized = strings.ReplaceAll(sanitized, ";", "-")
        sanitized = strings.ReplaceAll(sanitized, "'", "-")
        sanitized = strings.ReplaceAll(sanitized, "\"", "-")
        sanitized = strings.ReplaceAll(sanitized, "&lt;", "-")
        sanitized = strings.ReplaceAll(sanitized, "&gt;", "-")
        sanitized = strings.ReplaceAll(sanitized, "`", "-")
        sanitized = strings.ReplaceAll(sanitized, "~", "-")
        sanitized = strings.ReplaceAll(sanitized, "$", "-")

        // Clean up multiple consecutive dashes
        for strings.Contains(sanitized, "--") </span><span class="cov7" title="10">{
                sanitized = strings.ReplaceAll(sanitized, "--", "-")
        }</span>

        // Trim leading/trailing dashes
        <span class="cov6" title="8">sanitized = strings.Trim(sanitized, "-")

        // Ensure it's not empty and doesn't contain only special characters
        if sanitized == "" || sanitized == "-" </span><span class="cov2" title="2">{
                sanitized = "unknown-package"
        }</span>

        <span class="cov6" title="8">return sanitized</span>
}

func (ml *ManifestLayout) WriteToDisk(basePath string) error <span class="cov10" title="25">{
        fileMode := ml.FilePer
        if fileMode == FilePerUnset </span><span class="cov9" title="22">{
                fileMode = FilePerResource
        }</span>
        <span class="cov10" title="25">appMode := ml.ApplicationFileMode
        if appMode == AppFileUnset </span><span class="cov9" title="23">{
                appMode = AppFilePerResource
        }</span>

        <span class="cov10" title="25">var fullPath string
        if appMode == AppFileSingle </span><span class="cov2" title="2">{
                fullPath = filepath.Join(basePath, ml.Namespace)
        }</span> else<span class="cov9" title="23"> {
                fullPath = filepath.Join(basePath, ml.FullRepoPath())
        }</span>
        <span class="cov10" title="25">if err := os.MkdirAll(fullPath, 0755); err != nil </span><span class="cov0" title="0">{
                return errors.NewFileError("create", fullPath, "directory creation failed", err)
        }</span>

        <span class="cov10" title="25">fileGroups := map[string][]client.Object{}
        for _, obj := range ml.Resources </span><span class="cov8" title="14">{
                ns := obj.GetNamespace()
                if ns == "" </span><span class="cov0" title="0">{
                        ns = "cluster"
                }</span>

                <span class="cov8" title="14">kind := strings.ToLower(obj.GetObjectKind().GroupVersionKind().Kind)
                name := obj.GetName()

                var fileName string
                if appMode == AppFileSingle </span><span class="cov4" title="4">{
                        fileName = fmt.Sprintf("%s.yaml", ml.Name)
                }</span> else<span class="cov7" title="10"> {
                        switch fileMode </span>{
                        case FilePerKind:<span class="cov0" title="0">
                                fileName = fmt.Sprintf("%s-%s.yaml", ns, kind)</span>
                        default:<span class="cov7" title="10">
                                fileName = fmt.Sprintf("%s-%s-%s.yaml", ns, kind, name)</span>
                        }
                }

                <span class="cov8" title="14">fileGroups[fileName] = append(fileGroups[fileName], obj)</span>
        }

        <span class="cov10" title="25">for fileName, objs := range fileGroups </span><span class="cov7" title="12">{
                f, err := os.Create(filepath.Join(fullPath, fileName))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Convert to []*client.Object for the kio encoder
                <span class="cov7" title="12">var objPtrs []*client.Object
                for _, obj := range objs </span><span class="cov8" title="14">{
                        objPtr := &amp;obj
                        objPtrs = append(objPtrs, objPtr)
                }</span>

                // Use proper Kubernetes YAML encoder
                <span class="cov7" title="12">data, err := kio.EncodeObjectsToYAML(objPtrs)
                if err != nil </span><span class="cov0" title="0">{
                        _ = f.Close()
                        return err
                }</span>

                <span class="cov7" title="12">if _, err = f.Write(data); err != nil </span><span class="cov0" title="0">{
                        _ = f.Close()
                        return err
                }</span>

                <span class="cov7" title="12">if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov10" title="25">kMode := ml.Mode
        if kMode == KustomizationUnset </span><span class="cov9" title="22">{
                kMode = KustomizationExplicit
        }</span>

        // Generate kustomization.yaml if there are resources or children
        // Every directory with manifests should have a kustomization.yaml for proper GitOps workflow
        <span class="cov10" title="25">if len(fileGroups) &gt; 0 || len(ml.Children) &gt; 0 </span><span class="cov8" title="14">{
                kustomPath := filepath.Join(fullPath, "kustomization.yaml")
                kf, err := os.Create(kustomPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write proper YAML header
                <span class="cov8" title="14">_, _ = kf.WriteString("apiVersion: kustomize.config.kubernetes.io/v1beta1\n")
                _, _ = kf.WriteString("kind: Kustomization\n")
                _, _ = kf.WriteString("resources:\n")

                // Add resource files if in explicit mode OR if it's a leaf directory with no children
                if kMode == KustomizationExplicit || len(ml.Children) == 0 </span><span class="cov8" title="13">{
                        for file := range fileGroups </span><span class="cov7" title="12">{
                                _, _ = kf.WriteString(fmt.Sprintf("  - %s\n", file))
                        }</span>
                }

                // Add child references
                <span class="cov8" title="14">for _, child := range ml.Children </span><span class="cov4" title="4">{
                        if child.ApplicationFileMode == AppFileSingle </span><span class="cov1" title="1">{
                                _, _ = kf.WriteString(fmt.Sprintf("  - %s.yaml\n", child.Name))
                        }</span> else<span class="cov4" title="3"> {
                                // For package-aware layouts, use relative path
                                if ml.PackageRef != nil &amp;&amp; child.PackageRef != nil &amp;&amp; ml.PackageRef != child.PackageRef </span><span class="cov0" title="0">{
                                        // Different packages - skip cross-package references in kustomization
                                        continue</span>
                                }
                                <span class="cov4" title="3">_, _ = kf.WriteString(fmt.Sprintf("  - %s\n", child.Name))</span>
                        }
                }

                <span class="cov8" title="14">if err := kf.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov10" title="25">for _, child := range ml.Children </span><span class="cov4" title="4">{
                if err := child.WriteToDisk(basePath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov10" title="25">return nil</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package layout

import "fmt"

// Profile identifies a supported layout profile.
type Profile string

const (
        // FluxProfile represents defaults matching FluxCD conventions.
        FluxProfile Profile = "flux"
        // ArgoProfile represents defaults matching Argo CD conventions.
        ArgoProfile Profile = "argocd"
)

// DefaultConfigForProfile returns a Config initialised with defaults for the
// given profile. Unknown profiles fall back to FluxProfile.
func DefaultConfigForProfile(p Profile) Config <span class="cov0" title="0">{
        switch p </span>{
        case ArgoProfile:<span class="cov0" title="0">
                return Config{
                        ManifestsDir:        "applications",
                        FluxDir:             "applications",
                        FilePer:             FilePerResource,
                        ApplicationFileMode: AppFileSingle,
                        ManifestFileName:    DefaultManifestFileName,
                        KustomizationFileName: func(name string) string </span><span class="cov0" title="0">{
                                return fmt.Sprintf("application-%s.yaml", name)
                        }</span>,
                }
        default:<span class="cov0" title="0">
                return DefaultLayoutConfig()</span>
        }
}
</pre>
		
		<pre class="file" id="file114" style="display: none">// Package api defines configuration structures used to generate
// Kubernetes manifests and Flux resources.
package layout

import (
        "github.com/go-kure/kure/pkg/errors"
)

// FileExportMode determines how resources are written to disk.
type FileExportMode string

const (
        // FilePerResource writes each resource to its own file.
        FilePerResource FileExportMode = "resource"
        // FilePerKind groups resources by kind into a single file.
        FilePerKind FileExportMode = "kind"
        // FilePerUnset indicates that no export mode is specified.
        FilePerUnset FileExportMode = ""
)

// GroupingMode controls how nodes, bundles and applications are laid out on disk.
//
// The default for all grouping modes is GroupByName which creates a directory per
// entity. GroupFlat places all entities in the same directory.
type GroupingMode string

const (
        // GroupByName creates a directory for each item in the hierarchy.
        GroupByName GroupingMode = "name"
        // GroupFlat flattens the hierarchy placing all items in the same directory.
        GroupFlat GroupingMode = "flat"
        // GroupUnset indicates that no grouping preference was specified.
        GroupUnset GroupingMode = ""
)

// ApplicationFileMode specifies how resources within an application are written.
//
// The default is AppFilePerResource which mirrors the behaviour of FilePerResource
// and writes each generated resource to its own file. AppFileSingle groups all
// resources belonging to an application into a single manifest file.
type ApplicationFileMode string

const (
        // AppFilePerResource writes each application resource to its own file.
        AppFilePerResource ApplicationFileMode = "resource"
        // AppFileSingle writes all resources for an application into one file.
        AppFileSingle ApplicationFileMode = "single"
        // AppFileUnset indicates that no application file mode was specified.
        AppFileUnset ApplicationFileMode = ""
)

// KustomizationMode determines how kustomization.yaml files reference manifests.
type KustomizationMode string

const (
        // KustomizationExplicit lists each manifest file in kustomization.yaml.
        KustomizationExplicit KustomizationMode = "explicit"
        // KustomizationRecursive references only subdirectories in kustomization.yaml.
        KustomizationRecursive KustomizationMode = "recursive"
        // KustomizationUnset indicates no kustomization mode preference.
        KustomizationUnset KustomizationMode = ""
)

// FluxPlacement determines how Flux Kustomizations are placed in the layout.
type FluxPlacement string

const (
        // FluxSeparate places all Flux Kustomizations in a separate directory.
        FluxSeparate FluxPlacement = "separate"
        // FluxIntegrated distributes Flux Kustomizations across their target nodes.
        FluxIntegrated FluxPlacement = "integrated"
        // FluxUnset indicates no flux placement preference.
        FluxUnset FluxPlacement = ""
)

// LayoutRules control how layouts are generated.
//
// Zero values are interpreted as the defaults described in the field
// documentation.
type LayoutRules struct {
        // NodeGrouping controls how nodes are written to disk. Defaults to
        // GroupByName.
        NodeGrouping GroupingMode
        // BundleGrouping controls how bundles are written to disk. Defaults to
        // GroupByName.
        BundleGrouping GroupingMode
        // ApplicationGrouping controls how applications are written to disk.
        // Defaults to GroupByName.
        ApplicationGrouping GroupingMode
        // ApplicationFileMode controls whether application resources are
        // combined into a single file or split per resource. Defaults to
        // AppFilePerResource.
        ApplicationFileMode ApplicationFileMode
        // FilePer sets the default file export mode for resources. Defaults to
        // FilePerResource.
        FilePer FileExportMode
        // ClusterName specifies a cluster name to prepend to all paths.
        // When set, creates clusters/{ClusterName}/... structure.
        ClusterName string
        // FluxPlacement determines how Flux Kustomizations are placed.
        // Defaults to FluxSeparate.
        FluxPlacement FluxPlacement
}

// DefaultLayoutRules returns a LayoutRules instance populated with the
// documented default values.
func DefaultLayoutRules() LayoutRules <span class="cov10" title="13">{
        return LayoutRules{
                NodeGrouping:        GroupByName,
                BundleGrouping:      GroupFlat, // Avoid bundle/app/app nesting
                ApplicationGrouping: GroupFlat, // Avoid double nesting
                ApplicationFileMode: AppFilePerResource,
                FilePer:             FilePerResource,
                FluxPlacement:       FluxSeparate,
        }
}</span>

// Validate ensures the LayoutRules contain known option values.
func (lr LayoutRules) Validate() error <span class="cov0" title="0">{
        validGrouping := func(g GroupingMode) bool </span><span class="cov0" title="0">{
                switch g </span>{
                case GroupByName, GroupFlat, GroupUnset:<span class="cov0" title="0">
                        return true</span>
                default:<span class="cov0" title="0">
                        return false</span>
                }
        }

        <span class="cov0" title="0">if !validGrouping(lr.NodeGrouping) </span><span class="cov0" title="0">{
                return errors.NewValidationError("NodeGrouping", string(lr.NodeGrouping), "LayoutRules", []string{string(GroupByName), string(GroupFlat)})
        }</span>
        <span class="cov0" title="0">if !validGrouping(lr.BundleGrouping) </span><span class="cov0" title="0">{
                return errors.NewValidationError("BundleGrouping", string(lr.BundleGrouping), "LayoutRules", []string{string(GroupByName), string(GroupFlat)})
        }</span>
        <span class="cov0" title="0">if !validGrouping(lr.ApplicationGrouping) </span><span class="cov0" title="0">{
                return errors.NewValidationError("ApplicationGrouping", string(lr.ApplicationGrouping), "LayoutRules", []string{string(GroupByName), string(GroupFlat)})
        }</span>

        <span class="cov0" title="0">switch lr.ApplicationFileMode </span>{
        case AppFilePerResource, AppFileSingle, AppFileUnset:<span class="cov0" title="0"></span>
                // valid
        default:<span class="cov0" title="0">
                return errors.NewValidationError("ApplicationFileMode", string(lr.ApplicationFileMode), "LayoutRules", []string{string(AppFilePerResource), string(AppFileSingle)})</span>
        }

        <span class="cov0" title="0">switch lr.FilePer </span>{
        case FilePerResource, FilePerKind, FilePerUnset:<span class="cov0" title="0"></span>
                // valid
        default:<span class="cov0" title="0">
                return errors.NewValidationError("FilePer", string(lr.FilePer), "LayoutRules", []string{string(FilePerResource), string(FilePerKind)})</span>
        }

        <span class="cov0" title="0">switch lr.FluxPlacement </span>{
        case FluxSeparate, FluxIntegrated, FluxUnset:<span class="cov0" title="0"></span>
                // valid
        default:<span class="cov0" title="0">
                return errors.NewValidationError("FluxPlacement", string(lr.FluxPlacement), "LayoutRules", []string{string(FluxSeparate), string(FluxIntegrated)})</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package layout

import (
        "path/filepath"

        "github.com/go-kure/kure/pkg/stack"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// WalkCluster traverses a stack.Cluster and builds a ManifestLayout tree that
// mirrors the node and bundle hierarchy. Behaviour is controlled via
// LayoutRules. When BundleGrouping and ApplicationGrouping are set to
// GroupFlat, all application resources are written directly to their parent
// node's directory.
func WalkCluster(c *stack.Cluster, rules LayoutRules) (*ManifestLayout, error) <span class="cov6" title="10">{
        if c == nil || c.Node == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Apply documented defaults for unset options.
        <span class="cov6" title="10">def := DefaultLayoutRules()
        if rules.NodeGrouping == GroupUnset </span><span class="cov2" title="2">{
                rules.NodeGrouping = def.NodeGrouping
        }</span>
        <span class="cov6" title="10">if rules.BundleGrouping == GroupUnset </span><span class="cov0" title="0">{
                rules.BundleGrouping = def.BundleGrouping
        }</span>
        <span class="cov6" title="10">if rules.ApplicationGrouping == GroupUnset </span><span class="cov0" title="0">{
                rules.ApplicationGrouping = def.ApplicationGrouping
        }</span>
        <span class="cov6" title="10">if rules.FilePer == FilePerUnset </span><span class="cov6" title="10">{
                rules.FilePer = def.FilePer
        }</span>
        <span class="cov6" title="10">if rules.FluxPlacement == FluxUnset </span><span class="cov6" title="10">{
                rules.FluxPlacement = def.FluxPlacement
        }</span>

        <span class="cov6" title="10">nodeOnly := rules.BundleGrouping == GroupFlat &amp;&amp; rules.ApplicationGrouping == GroupFlat
        filePer := rules.FilePer
        if nodeOnly </span><span class="cov3" title="3">{
                filePer = FilePerResource
        }</span>

        // For cluster-aware layout, we need to restructure the hierarchy
        <span class="cov6" title="10">if rules.ClusterName != "" </span><span class="cov0" title="0">{
                return walkClusterWithClusterName(c, rules, nodeOnly, filePer)
        }</span>

        // Traditional layout without cluster name
        <span class="cov6" title="10">ml, err := walkNode(c.Node, nil, nodeOnly, filePer, nil, rules.FluxPlacement)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="10">return ml, nil</span>
}

// walkClusterWithClusterName creates a cluster-aware layout where the cluster name is the root
// and all nodes (including the root node) become siblings underneath it.
func walkClusterWithClusterName(c *stack.Cluster, rules LayoutRules, nodeOnly bool, filePer FileExportMode) (*ManifestLayout, error) <span class="cov0" title="0">{
        // Create a cluster-level layout with the cluster name as the root
        clusterLayout := &amp;ManifestLayout{
                Name:      "",
                Namespace: rules.ClusterName,
                FilePer:   filePer,
                Children:  []*ManifestLayout{},
        }

        // Process the root node as a sibling (only its bundle, not children)
        if c.Node.Bundle != nil </span><span class="cov0" title="0">{
                rootLayout := &amp;ManifestLayout{
                        Name:      c.Node.Name,
                        Namespace: filepath.Join(rules.ClusterName, c.Node.Name),
                        FilePer:   filePer,
                        Children:  []*ManifestLayout{},
                }

                // Add only the root node's bundle resources (not child resources)
                for _, app := range c.Node.Bundle.Applications </span><span class="cov0" title="0">{
                        if app == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">objsPtr, err := app.Generate()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">for _, o := range objsPtr </span><span class="cov0" title="0">{
                                if o == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">rootLayout.Resources = append(rootLayout.Resources, *o)</span>
                        }
                }

                <span class="cov0" title="0">clusterLayout.Children = append(clusterLayout.Children, rootLayout)</span>
        }

        // Process all child nodes as siblings at the cluster level (with their own resources)
        <span class="cov0" title="0">for _, child := range c.Node.Children </span><span class="cov0" title="0">{
                childLayout, err := walkNode(child, []string{rules.ClusterName}, nodeOnly, filePer, nil, rules.FluxPlacement)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if childLayout != nil </span><span class="cov0" title="0">{
                        clusterLayout.Children = append(clusterLayout.Children, childLayout)
                }</span>
        }

        <span class="cov0" title="0">return clusterLayout, nil</span>
}

// WalkClusterByPackage traverses a stack.Cluster and builds separate ManifestLayout trees
// for each unique PackageRef (OCI artifact). Returns a map where keys are PackageRef GVKs
// and values are the corresponding ManifestLayout trees. Nodes without PackageRef inherit
// from their parent, with nil representing the default package.
func WalkClusterByPackage(c *stack.Cluster, rules LayoutRules) (map[string]*ManifestLayout, error) <span class="cov3" title="3">{
        if c == nil || c.Node == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Apply documented defaults for unset options.
        <span class="cov3" title="3">def := DefaultLayoutRules()
        if rules.NodeGrouping == GroupUnset </span><span class="cov3" title="3">{
                rules.NodeGrouping = def.NodeGrouping
        }</span>
        <span class="cov3" title="3">if rules.BundleGrouping == GroupUnset </span><span class="cov2" title="2">{
                rules.BundleGrouping = def.BundleGrouping
        }</span>
        <span class="cov3" title="3">if rules.ApplicationGrouping == GroupUnset </span><span class="cov2" title="2">{
                rules.ApplicationGrouping = def.ApplicationGrouping
        }</span>
        <span class="cov3" title="3">if rules.FilePer == FilePerUnset </span><span class="cov3" title="3">{
                rules.FilePer = def.FilePer
        }</span>

        <span class="cov3" title="3">nodeOnly := rules.BundleGrouping == GroupFlat &amp;&amp; rules.ApplicationGrouping == GroupFlat
        filePer := rules.FilePer
        if nodeOnly </span><span class="cov2" title="2">{
                filePer = FilePerResource
        }</span>

        // First pass: collect all unique package references
        <span class="cov3" title="3">packages := make(map[string]*schema.GroupVersionKind)
        collectPackageRefs(c.Node, nil, packages)

        // Second pass: build layouts for each package
        layouts := make(map[string]*ManifestLayout)
        for pkgKey, pkgRef := range packages </span><span class="cov5" title="6">{
                layout, err := walkNodeForPackage(c.Node, nil, nodeOnly, filePer, pkgRef, pkgKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="6">if layout != nil </span><span class="cov5" title="6">{
                        layouts[pkgKey] = layout
                }</span>
        }

        <span class="cov3" title="3">return layouts, nil</span>
}

// walkNode recursively processes a stack.Node and its children.
func walkNode(n *stack.Node, ancestors []string, nodeOnly bool, filePer FileExportMode, inheritedPackageRef *schema.GroupVersionKind, fluxPlacement FluxPlacement) (*ManifestLayout, error) <span class="cov8" title="20">{
        if n == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="20">currentPath := append([]string{}, ancestors...)
        if n.Name != "" </span><span class="cov8" title="20">{
                currentPath = append(currentPath, n.Name)
        }</span>

        <span class="cov8" title="20">ml := &amp;ManifestLayout{
                Name:          n.Name,
                Namespace:     filepath.Join(ancestors...),
                FilePer:       filePer,
                FluxPlacement: fluxPlacement, // Pass flux placement mode
        }

        if nodeOnly </span><span class="cov5" title="6">{
                if b := n.Bundle; b != nil </span><span class="cov3" title="3">{
                        for _, app := range b.Applications </span><span class="cov3" title="3">{
                                if app == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov3" title="3">objsPtr, err := app.Generate()
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov3" title="3">for _, o := range objsPtr </span><span class="cov3" title="3">{
                                        if o == nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov3" title="3">ml.Resources = append(ml.Resources, *o)</span>
                                }
                        }
                }
        } else<span class="cov7" title="14"> {
                var children []*ManifestLayout
                if b := n.Bundle; b != nil </span><span class="cov5" title="7">{
                        var bundleChildren []*ManifestLayout
                        for _, app := range b.Applications </span><span class="cov5" title="7">{
                                if app == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov5" title="7">objsPtr, err := app.Generate()
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov5" title="7">var objs []client.Object
                                for _, o := range objsPtr </span><span class="cov5" title="7">{
                                        if o == nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov5" title="7">objs = append(objs, *o)</span>
                                }
                                <span class="cov5" title="7">appLayout := &amp;ManifestLayout{
                                        Name:          app.Name,
                                        Namespace:     filepath.Join(append(currentPath, b.Name)...),
                                        Resources:     objs,
                                        Mode:          KustomizationExplicit, // Ensure applications get their own kustomization.yaml
                                        FluxPlacement: fluxPlacement,         // Pass flux placement mode
                                }
                                bundleChildren = append(bundleChildren, appLayout)</span>
                        }
                        <span class="cov5" title="7">bundleLayout := &amp;ManifestLayout{
                                Name:          b.Name,
                                Namespace:     filepath.Join(currentPath...),
                                Children:      bundleChildren,
                                Mode:          KustomizationRecursive, // Bundle directories reference subdirectories
                                FluxPlacement: fluxPlacement,          // Pass flux placement mode
                        }
                        children = append(children, bundleLayout)</span>
                }

                <span class="cov7" title="14">for _, child := range n.Children </span><span class="cov5" title="7">{
                        cl, err := walkNode(child, currentPath, nodeOnly, filePer, resolvePackageRef(n, inheritedPackageRef), fluxPlacement)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov5" title="7">if cl != nil </span><span class="cov5" title="7">{
                                children = append(children, cl)
                        }</span>
                }

                <span class="cov7" title="14">ml.Children = children</span>
        }

        <span class="cov8" title="20">if nodeOnly </span><span class="cov5" title="6">{
                for _, child := range n.Children </span><span class="cov3" title="3">{
                        cl, err := walkNode(child, currentPath, nodeOnly, filePer, resolvePackageRef(n, inheritedPackageRef), fluxPlacement)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="3">if cl != nil </span><span class="cov3" title="3">{
                                ml.Children = append(ml.Children, cl)
                        }</span>
                }
        }

        <span class="cov8" title="20">return ml, nil</span>
}

// resolvePackageRef returns the effective PackageRef for a node, using inheritance from parent
func resolvePackageRef(n *stack.Node, inheritedPackageRef *schema.GroupVersionKind) *schema.GroupVersionKind <span class="cov10" title="35">{
        if n.PackageRef != nil </span><span class="cov7" title="11">{
                return n.PackageRef
        }</span>
        <span class="cov9" title="24">return inheritedPackageRef</span>
}

// packageRefKey converts a PackageRef to a string key for map indexing
func packageRefKey(ref *schema.GroupVersionKind) string <span class="cov9" title="25">{
        if ref == nil </span><span class="cov7" title="11">{
                return "default"
        }</span>
        <span class="cov7" title="14">return ref.String()</span>
}

// collectPackageRefs recursively traverses nodes to collect all unique PackageRef values
func collectPackageRefs(n *stack.Node, inheritedPackageRef *schema.GroupVersionKind, packages map[string]*schema.GroupVersionKind) <span class="cov6" title="8">{
        if n == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="8">currentPackageRef := resolvePackageRef(n, inheritedPackageRef)
        key := packageRefKey(currentPackageRef)
        packages[key] = currentPackageRef

        for _, child := range n.Children </span><span class="cov5" title="5">{
                collectPackageRefs(child, currentPackageRef, packages)
        }</span>
}

// walkNodeForPackage walks the tree but only includes nodes that belong to the specified package
func walkNodeForPackage(n *stack.Node, ancestors []string, nodeOnly bool, filePer FileExportMode, targetPackageRef *schema.GroupVersionKind, targetKey string) (*ManifestLayout, error) <span class="cov5" title="6">{
        return walkNodeForPackageInternal(n, ancestors, nodeOnly, filePer, nil, targetPackageRef, targetKey)
}</span>

// walkNodeForPackageInternal is the internal implementation with inheritance tracking
func walkNodeForPackageInternal(n *stack.Node, ancestors []string, nodeOnly bool, filePer FileExportMode, inheritedPackageRef *schema.GroupVersionKind, targetPackageRef *schema.GroupVersionKind, targetKey string) (*ManifestLayout, error) <span class="cov8" title="17">{
        if n == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="17">currentPackageRef := resolvePackageRef(n, inheritedPackageRef)

        // Check if this node belongs to the target package
        belongsToPackage := packageRefKey(currentPackageRef) == targetKey

        currentPath := append([]string{}, ancestors...)
        if n.Name != "" &amp;&amp; belongsToPackage </span><span class="cov6" title="8">{
                currentPath = append(currentPath, n.Name)
        }</span>

        <span class="cov8" title="17">var ml *ManifestLayout
        if belongsToPackage </span><span class="cov6" title="8">{
                ml = &amp;ManifestLayout{
                        Name:      n.Name,
                        Namespace: filepath.Join(ancestors...),
                        FilePer:   filePer,
                }

                if nodeOnly </span><span class="cov5" title="5">{
                        if b := n.Bundle; b != nil </span><span class="cov3" title="3">{
                                for _, app := range b.Applications </span><span class="cov3" title="3">{
                                        if app == nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov3" title="3">objsPtr, err := app.Generate()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov3" title="3">for _, o := range objsPtr </span><span class="cov3" title="3">{
                                                if o == nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov3" title="3">ml.Resources = append(ml.Resources, *o)</span>
                                        }
                                }
                        }
                } else<span class="cov3" title="3"> {
                        var children []*ManifestLayout
                        if b := n.Bundle; b != nil </span><span class="cov2" title="2">{
                                var bundleChildren []*ManifestLayout
                                for _, app := range b.Applications </span><span class="cov2" title="2">{
                                        if app == nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov2" title="2">objsPtr, err := app.Generate()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov2" title="2">var objs []client.Object
                                        for _, o := range objsPtr </span><span class="cov2" title="2">{
                                                if o == nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov2" title="2">objs = append(objs, *o)</span>
                                        }
                                        <span class="cov2" title="2">appLayout := &amp;ManifestLayout{
                                                Name:      app.Name,
                                                Namespace: filepath.Join(append(currentPath, b.Name)...),
                                                Resources: objs,
                                        }
                                        bundleChildren = append(bundleChildren, appLayout)</span>
                                }
                                <span class="cov2" title="2">if len(bundleChildren) &gt; 0 </span><span class="cov2" title="2">{
                                        bundleLayout := &amp;ManifestLayout{
                                                Name:      b.Name,
                                                Namespace: filepath.Join(currentPath...),
                                                Children:  bundleChildren,
                                        }
                                        children = append(children, bundleLayout)
                                }</span>
                        }

                        <span class="cov3" title="3">for _, child := range n.Children </span><span class="cov2" title="2">{
                                cl, err := walkNodeForPackageInternal(child, currentPath, nodeOnly, filePer, currentPackageRef, targetPackageRef, targetKey)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov2" title="2">if cl != nil </span><span class="cov1" title="1">{
                                        children = append(children, cl)
                                }</span>
                        }

                        <span class="cov3" title="3">ml.Children = children</span>
                }

                <span class="cov6" title="8">if nodeOnly </span><span class="cov5" title="5">{
                        for _, child := range n.Children </span><span class="cov3" title="3">{
                                cl, err := walkNodeForPackageInternal(child, currentPath, nodeOnly, filePer, currentPackageRef, targetPackageRef, targetKey)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov3" title="3">if cl != nil </span><span class="cov1" title="1">{
                                        ml.Children = append(ml.Children, cl)
                                }</span>
                        }
                }
        } else<span class="cov6" title="9"> {
                // Node doesn't belong to target package, but continue traversing children
                // in case they have different PackageRef values
                for _, child := range n.Children </span><span class="cov5" title="6">{
                        cl, err := walkNodeForPackageInternal(child, ancestors, nodeOnly, filePer, currentPackageRef, targetPackageRef, targetKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov5" title="6">if cl != nil </span><span class="cov3" title="3">{
                                // If we get a valid layout from a child but this node doesn't belong to the package,
                                // we need to create a minimal parent structure
                                if ml == nil </span><span class="cov3" title="3">{
                                        ml = &amp;ManifestLayout{
                                                Name:      "",
                                                Namespace: filepath.Join(ancestors...),
                                                FilePer:   filePer,
                                                Children:  []*ManifestLayout{cl},
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        ml.Children = append(ml.Children, cl)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="17">return ml, nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package layout

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/go-kure/kure/pkg/errors"
        kio "github.com/go-kure/kure/pkg/io"
)

// WriteManifest writes a ManifestLayout to disk using the provided configuration.
func WriteManifest(basePath string, cfg Config, ml *ManifestLayout) error <span class="cov8" title="1">{
        if cfg.ManifestFileName == nil </span><span class="cov0" title="0">{
                cfg.ManifestFileName = DefaultManifestFileName
        }</span>
        <span class="cov8" title="1">if cfg.ManifestsDir == "" </span><span class="cov0" title="0">{
                cfg.ManifestsDir = "clusters"
        }</span>
        <span class="cov8" title="1">mode := ml.FilePer
        if mode == FilePerUnset </span><span class="cov8" title="1">{
                mode = cfg.FilePer
        }</span>
        <span class="cov8" title="1">appMode := ml.ApplicationFileMode
        if appMode == AppFileUnset </span><span class="cov8" title="1">{
                appMode = cfg.ApplicationFileMode
        }</span>
        <span class="cov8" title="1">kMode := ml.Mode
        if kMode == KustomizationUnset </span><span class="cov8" title="1">{
                kMode = cfg.KustomizationMode
        }</span>

        <span class="cov8" title="1">var fullPath string
        if appMode == AppFileSingle </span><span class="cov0" title="0">{
                fullPath = filepath.Join(basePath, cfg.ManifestsDir, ml.Namespace)
        }</span> else<span class="cov8" title="1"> {
                fullPath = filepath.Join(basePath, cfg.ManifestsDir, ml.FullRepoPath())
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(fullPath, 0755); err != nil </span><span class="cov0" title="0">{
                return errors.NewFileError("create", fullPath, "directory creation failed", err)
        }</span>

        <span class="cov8" title="1">fileGroups := map[string][]client.Object{}
        for _, obj := range ml.Resources </span><span class="cov8" title="1">{
                ns := obj.GetNamespace()
                if ns == "" </span><span class="cov0" title="0">{
                        ns = "cluster"
                }</span>
                <span class="cov8" title="1">kind := strings.ToLower(obj.GetObjectKind().GroupVersionKind().Kind)
                name := obj.GetName()

                var fileName string
                if appMode == AppFileSingle </span><span class="cov0" title="0">{
                        fileName = fmt.Sprintf("%s.yaml", ml.Name)
                }</span> else<span class="cov8" title="1"> {
                        fileName = cfg.ManifestFileName(ns, kind, name, mode)
                }</span>

                <span class="cov8" title="1">fileGroups[fileName] = append(fileGroups[fileName], obj)</span>
        }

        <span class="cov8" title="1">for fileName, objs := range fileGroups </span><span class="cov8" title="1">{
                f, err := os.Create(filepath.Join(fullPath, fileName))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Convert to []*client.Object for the kio encoder
                <span class="cov8" title="1">var objPtrs []*client.Object
                for _, obj := range objs </span><span class="cov8" title="1">{
                        objPtr := &amp;obj
                        objPtrs = append(objPtrs, objPtr)
                }</span>

                // Use proper Kubernetes YAML encoder
                <span class="cov8" title="1">data, err := kio.EncodeObjectsToYAML(objPtrs)
                if err != nil </span><span class="cov0" title="0">{
                        _ = f.Close()
                        return err
                }</span>

                <span class="cov8" title="1">if _, err = f.Write(data); err != nil </span><span class="cov0" title="0">{
                        _ = f.Close()
                        return err
                }</span>

                <span class="cov8" title="1">if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Don't generate root kustomization.yaml at cluster level (when namespace is just the cluster name)
        <span class="cov8" title="1">isClusterRoot := strings.Count(ml.Namespace, string(filepath.Separator)) == 0 &amp;&amp; ml.Name == ""

        // Generate kustomization.yaml if there are resources or children, but not at cluster root
        // Every directory with manifests should have a kustomization.yaml for proper GitOps workflow
        if !isClusterRoot &amp;&amp; (len(fileGroups) &gt; 0 || len(ml.Children) &gt; 0) </span><span class="cov8" title="1">{
                kustomPath := filepath.Join(fullPath, "kustomization.yaml")
                kf, err := os.Create(kustomPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write proper YAML header
                <span class="cov8" title="1">_, _ = kf.WriteString("apiVersion: kustomize.config.kubernetes.io/v1beta1\n")
                _, _ = kf.WriteString("kind: Kustomization\n")
                _, _ = kf.WriteString("resources:\n")

                // Add resource files if in explicit mode OR if it's a leaf directory with no children
                if kMode == KustomizationExplicit || len(ml.Children) == 0 </span><span class="cov8" title="1">{
                        for file := range fileGroups </span><span class="cov8" title="1">{
                                _, _ = kf.WriteString(fmt.Sprintf("  - %s\n", file))
                        }</span>
                }
                // In recursive mode, only reference child directories, not files

                // Add child references
                <span class="cov8" title="1">for _, child := range ml.Children </span><span class="cov0" title="0">{
                        if child.ApplicationFileMode == AppFileSingle </span><span class="cov0" title="0">{
                                _, _ = kf.WriteString(fmt.Sprintf("  - %s.yaml\n", child.Name))
                        }</span> else<span class="cov0" title="0"> {
                                // For FluxIntegrated mode, reference Flux Kustomization YAML files instead of directories
                                if ml.FluxPlacement == FluxIntegrated </span><span class="cov0" title="0">{
                                        fluxKustName := fmt.Sprintf("flux-system-kustomization-%s.yaml", child.Name)
                                        _, _ = kf.WriteString(fmt.Sprintf("  - %s\n", fluxKustName))
                                }</span> else<span class="cov0" title="0"> {
                                        _, _ = kf.WriteString(fmt.Sprintf("  - %s\n", child.Name))
                                }</span>
                        }
                }

                <span class="cov8" title="1">if err := kf.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, child := range ml.Children </span><span class="cov0" title="0">{
                if err := WriteManifest(basePath, cfg, child); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package v1alpha1

import (
        "fmt"

        "github.com/go-kure/kure/internal/gvk"
        "github.com/go-kure/kure/pkg/errors"
)

// BundleConfig represents a versioned bundle configuration
// +gvk:group=stack.gokure.dev
// +gvk:version=v1alpha1
// +gvk:kind=Bundle
type BundleConfig struct {
        APIVersion string           `yaml:"apiVersion" json:"apiVersion"`
        Kind       string           `yaml:"kind" json:"kind"`
        Metadata   gvk.BaseMetadata `yaml:"metadata" json:"metadata"`
        Spec       BundleSpec       `yaml:"spec" json:"spec"`
}

// BundleSpec defines the specification for a bundle
type BundleSpec struct {
        // ParentPath is the hierarchical path to the parent bundle (e.g., "cluster/infrastructure")
        // Empty for root bundles. This avoids circular references while maintaining hierarchy.
        ParentPath string `yaml:"parentPath,omitempty" json:"parentPath,omitempty"`

        // DependsOn lists other bundles this bundle depends on
        DependsOn []BundleReference `yaml:"dependsOn,omitempty" json:"dependsOn,omitempty"`

        // Interval controls how often Flux reconciles the bundle
        Interval string `yaml:"interval,omitempty" json:"interval,omitempty"`

        // SourceRef specifies the source for the bundle
        SourceRef *SourceRef `yaml:"sourceRef,omitempty" json:"sourceRef,omitempty"`

        // Applications holds the application configurations that belong to the bundle
        Applications []ApplicationReference `yaml:"applications,omitempty" json:"applications,omitempty"`

        // Description provides a human-readable description of the bundle
        Description string `yaml:"description,omitempty" json:"description,omitempty"`

        // Labels are common labels that should be applied to each resource
        Labels map[string]string `yaml:"labels,omitempty" json:"labels,omitempty"`

        // Annotations are common annotations that should be applied to each resource
        Annotations map[string]string `yaml:"annotations,omitempty" json:"annotations,omitempty"`

        // Prune specifies whether to prune resources when they are removed from the bundle
        Prune bool `yaml:"prune,omitempty" json:"prune,omitempty"`

        // Wait specifies whether to wait for resources to be ready before considering the bundle reconciled
        Wait bool `yaml:"wait,omitempty" json:"wait,omitempty"`

        // Timeout is the maximum time to wait for resources to be ready
        Timeout string `yaml:"timeout,omitempty" json:"timeout,omitempty"`

        // RetryInterval is the interval to retry failed reconciliations
        RetryInterval string `yaml:"retryInterval,omitempty" json:"retryInterval,omitempty"`
}

// SourceRef defines a reference to a Flux source
type SourceRef struct {
        // Kind of the source (e.g., GitRepository, OCIRepository, Bucket)
        Kind string `yaml:"kind" json:"kind"`

        // Name of the source
        Name string `yaml:"name" json:"name"`

        // Namespace of the source
        Namespace string `yaml:"namespace,omitempty" json:"namespace,omitempty"`

        // APIVersion of the source (for future cross-version references)
        APIVersion string `yaml:"apiVersion,omitempty" json:"apiVersion,omitempty"`
}

// ApplicationReference references an Application configuration
type ApplicationReference struct {
        // Name of the application
        Name string `yaml:"name" json:"name"`

        // APIVersion of the referenced application
        APIVersion string `yaml:"apiVersion,omitempty" json:"apiVersion,omitempty"`

        // Kind of the referenced application (for supporting different app types)
        Kind string `yaml:"kind,omitempty" json:"kind,omitempty"`
}

// GetAPIVersion returns the API version of the bundle config
func (b *BundleConfig) GetAPIVersion() string <span class="cov4" title="3">{
        if b.APIVersion == "" </span><span class="cov0" title="0">{
                return "stack.gokure.dev/v1alpha1"
        }</span>
        <span class="cov4" title="3">return b.APIVersion</span>
}

// GetKind returns the kind of the bundle config
func (b *BundleConfig) GetKind() string <span class="cov0" title="0">{
        if b.Kind == "" </span><span class="cov0" title="0">{
                return "Bundle"
        }</span>
        <span class="cov0" title="0">return b.Kind</span>
}

// GetName returns the name of the bundle
func (b *BundleConfig) GetName() string <span class="cov9" title="12">{
        return b.Metadata.Name
}</span>

// SetName sets the name of the bundle
func (b *BundleConfig) SetName(name string) <span class="cov3" title="2">{
        b.Metadata.Name = name
}</span>

// GetNamespace returns the namespace of the bundle
func (b *BundleConfig) GetNamespace() string <span class="cov3" title="2">{
        return b.Metadata.Namespace
}</span>

// SetNamespace sets the namespace of the bundle
func (b *BundleConfig) SetNamespace(namespace string) <span class="cov3" title="2">{
        b.Metadata.Namespace = namespace
}</span>

// GetPath returns the full hierarchical path of this bundle
func (b *BundleConfig) GetPath() string <span class="cov3" title="2">{
        if b.Spec.ParentPath == "" </span><span class="cov1" title="1">{
                return b.Metadata.Name
        }</span>
        <span class="cov1" title="1">return b.Spec.ParentPath + "/" + b.Metadata.Name</span>
}

// Validate performs validation on the bundle configuration
func (b *BundleConfig) Validate() error <span class="cov10" title="13">{
        if b == nil </span><span class="cov1" title="1">{
                return errors.ErrNilBundle
        }</span>

        <span class="cov9" title="12">if b.Metadata.Name == "" </span><span class="cov3" title="2">{
                return errors.NewValidationError("metadata.name", "", "Bundle", nil)
        }</span>

        // Validate interval format if specified
        <span class="cov9" title="10">if b.Spec.Interval != "" </span>{<span class="cov5" title="4">
                // TODO: Add interval format validation (e.g., "5m", "1h")
        }</span>

        // Validate source ref if present
        <span class="cov9" title="10">if b.Spec.SourceRef != nil </span><span class="cov5" title="4">{
                if b.Spec.SourceRef.Kind == "" </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Bundle", b.Metadata.Name, "spec.sourceRef.kind",
                                "sourceRef kind cannot be empty", nil)
                }</span>
                <span class="cov4" title="3">if b.Spec.SourceRef.Name == "" </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Bundle", b.Metadata.Name, "spec.sourceRef.name",
                                "sourceRef name cannot be empty", nil)
                }</span>
        }

        // Check for duplicate applications
        <span class="cov8" title="8">appNames := make(map[string]bool)
        for i, app := range b.Spec.Applications </span><span class="cov6" title="5">{
                if app.Name == "" </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Bundle", b.Metadata.Name, "spec.applications",
                                fmt.Sprintf("application at index %d has empty name", i), nil)
                }</span>
                <span class="cov5" title="4">key := fmt.Sprintf("%s:%s:%s", app.APIVersion, app.Kind, app.Name)
                if appNames[key] </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Bundle", b.Metadata.Name, "spec.applications",
                                fmt.Sprintf("duplicate application reference: %s", app.Name), nil)
                }</span>
                <span class="cov4" title="3">appNames[key] = true</span>
        }

        // Check for circular dependencies
        <span class="cov7" title="6">depNames := make(map[string]bool)
        for _, dep := range b.Spec.DependsOn </span><span class="cov6" title="5">{
                if dep.Name == "" </span><span class="cov0" title="0">{
                        return errors.ResourceValidationError("Bundle", b.Metadata.Name, "spec.dependsOn",
                                "dependency name cannot be empty", nil)
                }</span>
                <span class="cov6" title="5">if dep.Name == b.Metadata.Name </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Bundle", b.Metadata.Name, "spec.dependsOn",
                                "bundle cannot depend on itself", nil)
                }</span>
                <span class="cov5" title="4">if depNames[dep.Name] </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Bundle", b.Metadata.Name, "spec.dependsOn",
                                fmt.Sprintf("duplicate dependency: %s", dep.Name), nil)
                }</span>
                <span class="cov4" title="3">depNames[dep.Name] = true</span>
        }

        <span class="cov5" title="4">return nil</span>
}

// ConvertTo converts this bundle config to another version
func (b *BundleConfig) ConvertTo(version string) (interface{}, error) <span class="cov3" title="2">{
        switch version </span>{
        case "v1alpha1":<span class="cov1" title="1">
                return b, nil</span>
        default:<span class="cov1" title="1">
                return nil, errors.New("unsupported version: " + version)</span>
        }
}

// ConvertFrom converts from another version to this bundle config
func (b *BundleConfig) ConvertFrom(from interface{}) error <span class="cov1" title="1">{
        switch src := from.(type) </span>{
        case *BundleConfig:<span class="cov1" title="1">
                *b = *src
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("unsupported conversion source type")</span>
        }
}

// NewBundleConfig creates a new BundleConfig with default values
func NewBundleConfig(name string) *BundleConfig <span class="cov6" title="5">{
        return &amp;BundleConfig{
                APIVersion: "stack.gokure.dev/v1alpha1",
                Kind:       "Bundle",
                Metadata: gvk.BaseMetadata{
                        Name: name,
                },
                Spec: BundleSpec{
                        Interval: "5m",
                        Prune:    true,
                        Wait:     true,
                        Timeout:  "5m",
                },
        }
}</span>

// AddApplication adds an application reference to the bundle
func (b *BundleConfig) AddApplication(name, apiVersion, kind string) <span class="cov4" title="3">{
        b.Spec.Applications = append(b.Spec.Applications, ApplicationReference{
                Name:       name,
                APIVersion: apiVersion,
                Kind:       kind,
        })
}</span>

// AddDependency adds a dependency to another bundle
func (b *BundleConfig) AddDependency(bundleName string) <span class="cov4" title="3">{
        b.Spec.DependsOn = append(b.Spec.DependsOn, BundleReference{
                Name:       bundleName,
                APIVersion: b.GetAPIVersion(),
        })
}</span>

// SetSourceRef sets the source reference for the bundle
func (b *BundleConfig) SetSourceRef(kind, name, namespace string) <span class="cov3" title="2">{
        b.Spec.SourceRef = &amp;SourceRef{
                Kind:       kind,
                Name:       name,
                Namespace:  namespace,
                APIVersion: "source.toolkit.fluxcd.io/v1",
        }
}</span>
</pre>
		
		<pre class="file" id="file118" style="display: none">package v1alpha1

import (
        "github.com/go-kure/kure/internal/gvk"
        "github.com/go-kure/kure/pkg/errors"
)

// ClusterConfig represents a versioned cluster configuration
// +gvk:group=stack.gokure.dev
// +gvk:version=v1alpha1
// +gvk:kind=Cluster
type ClusterConfig struct {
        APIVersion string           `yaml:"apiVersion" json:"apiVersion"`
        Kind       string           `yaml:"kind" json:"kind"`
        Metadata   gvk.BaseMetadata `yaml:"metadata" json:"metadata"`
        Spec       ClusterSpec      `yaml:"spec" json:"spec"`
}

// ClusterSpec defines the specification for a cluster
type ClusterSpec struct {
        // Node is the root node of the cluster configuration tree
        Node *NodeReference `yaml:"node,omitempty" json:"node,omitempty"`

        // GitOps defines the GitOps tool configuration for the cluster
        GitOps *GitOpsConfig `yaml:"gitops,omitempty" json:"gitops,omitempty"`

        // Description provides a human-readable description of the cluster
        Description string `yaml:"description,omitempty" json:"description,omitempty"`

        // Labels are key-value pairs for cluster metadata
        Labels map[string]string `yaml:"labels,omitempty" json:"labels,omitempty"`
}

// NodeReference references a Node configuration
type NodeReference struct {
        // Name of the node
        Name string `yaml:"name" json:"name"`

        // APIVersion of the referenced node (for future cross-version references)
        APIVersion string `yaml:"apiVersion,omitempty" json:"apiVersion,omitempty"`
}

// GitOpsConfig defines the GitOps tool configuration for the cluster
type GitOpsConfig struct {
        // Type specifies the GitOps tool: "flux" or "argocd"
        Type string `yaml:"type" json:"type"`

        // Bootstrap configuration for the GitOps tool
        Bootstrap *BootstrapConfig `yaml:"bootstrap,omitempty" json:"bootstrap,omitempty"`
}

// BootstrapConfig defines the bootstrap configuration for GitOps tools
type BootstrapConfig struct {
        // Common fields
        Enabled bool `yaml:"enabled" json:"enabled"`

        // Flux-specific
        FluxMode        string   `yaml:"fluxMode,omitempty" json:"fluxMode,omitempty"` // "gitops-toolkit" or "flux-operator"
        FluxVersion     string   `yaml:"fluxVersion,omitempty" json:"fluxVersion,omitempty"`
        Components      []string `yaml:"components,omitempty" json:"components,omitempty"`
        Registry        string   `yaml:"registry,omitempty" json:"registry,omitempty"`
        ImagePullSecret string   `yaml:"imagePullSecret,omitempty" json:"imagePullSecret,omitempty"`

        // Source configuration
        SourceURL string `yaml:"sourceURL,omitempty" json:"sourceURL,omitempty"` // OCI/Git repository URL
        SourceRef string `yaml:"sourceRef,omitempty" json:"sourceRef,omitempty"` // Tag/branch/ref

        // ArgoCD-specific
        ArgoCDVersion   string `yaml:"argoCDVersion,omitempty" json:"argoCDVersion,omitempty"`
        ArgoCDNamespace string `yaml:"argoCDNamespace,omitempty" json:"argoCDNamespace,omitempty"`
}

// GetAPIVersion returns the API version of the cluster config
func (c *ClusterConfig) GetAPIVersion() string <span class="cov2" title="2">{
        if c.APIVersion == "" </span><span class="cov1" title="1">{
                return "stack.gokure.dev/v1alpha1"
        }</span>
        <span class="cov1" title="1">return c.APIVersion</span>
}

// GetKind returns the kind of the cluster config
func (c *ClusterConfig) GetKind() string <span class="cov2" title="2">{
        if c.Kind == "" </span><span class="cov1" title="1">{
                return "Cluster"
        }</span>
        <span class="cov1" title="1">return c.Kind</span>
}

// GetName returns the name of the cluster
func (c *ClusterConfig) GetName() string <span class="cov6" title="6">{
        return c.Metadata.Name
}</span>

// SetName sets the name of the cluster
func (c *ClusterConfig) SetName(name string) <span class="cov2" title="2">{
        c.Metadata.Name = name
}</span>

// GetNamespace returns the namespace of the cluster
func (c *ClusterConfig) GetNamespace() string <span class="cov2" title="2">{
        return c.Metadata.Namespace
}</span>

// SetNamespace sets the namespace of the cluster
func (c *ClusterConfig) SetNamespace(namespace string) <span class="cov2" title="2">{
        c.Metadata.Namespace = namespace
}</span>

// Validate performs validation on the cluster configuration
func (c *ClusterConfig) Validate() error <span class="cov10" title="24">{
        if c == nil </span><span class="cov1" title="1">{
                return errors.New("cluster config is nil")
        }</span>

        <span class="cov9" title="23">if c.Metadata.Name == "" </span><span class="cov4" title="3">{
                return errors.NewValidationError("metadata.name", "", "Cluster", nil)
        }</span>

        <span class="cov9" title="20">if c.Spec.GitOps != nil </span><span class="cov6" title="8">{
                if c.Spec.GitOps.Type != "flux" &amp;&amp; c.Spec.GitOps.Type != "argocd" </span><span class="cov2" title="2">{
                        return errors.ResourceValidationError("Cluster", c.Metadata.Name, "spec.gitops.type",
                                "must be 'flux' or 'argocd', got: "+c.Spec.GitOps.Type, nil)
                }</span>
        }

        <span class="cov9" title="18">return nil</span>
}

// ConvertTo converts this cluster config to another version
func (c *ClusterConfig) ConvertTo(version string) (interface{}, error) <span class="cov2" title="2">{
        switch version </span>{
        case "v1alpha1":<span class="cov1" title="1">
                return c, nil</span>
        default:<span class="cov1" title="1">
                return nil, errors.New("unsupported version: " + version)</span>
        }
}

// ConvertFrom converts from another version to this cluster config
func (c *ClusterConfig) ConvertFrom(from interface{}) error <span class="cov4" title="3">{
        switch src := from.(type) </span>{
        case *ClusterConfig:<span class="cov2" title="2">
                *c = *src
                return nil</span>
        default:<span class="cov1" title="1">
                return errors.New("unsupported conversion source type")</span>
        }
}

// NewClusterConfig creates a new ClusterConfig with default values
func NewClusterConfig(name string) *ClusterConfig <span class="cov9" title="17">{
        return &amp;ClusterConfig{
                APIVersion: "stack.gokure.dev/v1alpha1",
                Kind:       "Cluster",
                Metadata: gvk.BaseMetadata{
                        Name: name,
                },
                Spec: ClusterSpec{},
        }
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">package v1alpha1

import (
        "github.com/go-kure/kure/internal/gvk"
        "github.com/go-kure/kure/pkg/stack"
)

// ConvertClusterToV1Alpha1 converts an unversioned Cluster to a v1alpha1 ClusterConfig
func ConvertClusterToV1Alpha1(c *stack.Cluster) *ClusterConfig <span class="cov5" title="9">{
        if c == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="8">config := &amp;ClusterConfig{
                APIVersion: "stack.gokure.dev/v1alpha1",
                Kind:       "Cluster",
                Metadata: gvk.BaseMetadata{
                        Name: c.Name,
                },
                Spec: ClusterSpec{},
        }

        // Convert Node reference
        if c.Node != nil </span><span class="cov4" title="5">{
                config.Spec.Node = &amp;NodeReference{
                        Name:       c.Node.Name,
                        APIVersion: "stack.gokure.dev/v1alpha1",
                }
        }</span>

        // Convert GitOps config
        <span class="cov4" title="8">if c.GitOps != nil </span><span class="cov3" title="3">{
                config.Spec.GitOps = &amp;GitOpsConfig{
                        Type: c.GitOps.Type,
                }

                if c.GitOps.Bootstrap != nil </span><span class="cov3" title="3">{
                        config.Spec.GitOps.Bootstrap = &amp;BootstrapConfig{
                                Enabled:         c.GitOps.Bootstrap.Enabled,
                                FluxMode:        c.GitOps.Bootstrap.FluxMode,
                                FluxVersion:     c.GitOps.Bootstrap.FluxVersion,
                                Components:      c.GitOps.Bootstrap.Components,
                                Registry:        c.GitOps.Bootstrap.Registry,
                                ImagePullSecret: c.GitOps.Bootstrap.ImagePullSecret,
                                SourceURL:       c.GitOps.Bootstrap.SourceURL,
                                SourceRef:       c.GitOps.Bootstrap.SourceRef,
                                ArgoCDVersion:   c.GitOps.Bootstrap.ArgoCDVersion,
                                ArgoCDNamespace: c.GitOps.Bootstrap.ArgoCDNamespace,
                        }
                }</span>
        }

        <span class="cov4" title="8">return config</span>
}

// ConvertV1Alpha1ToCluster converts a v1alpha1 ClusterConfig to an unversioned Cluster
func ConvertV1Alpha1ToCluster(config *ClusterConfig) *stack.Cluster <span class="cov4" title="5">{
        if config == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="4">c := &amp;stack.Cluster{
                Name: config.Metadata.Name,
        }

        // Note: We don't convert the Node here as it would require full tree traversal
        // This should be handled at a higher level that has access to all nodes

        // Convert GitOps config
        if config.Spec.GitOps != nil </span><span class="cov2" title="2">{
                c.GitOps = &amp;stack.GitOpsConfig{
                        Type: config.Spec.GitOps.Type,
                }

                if config.Spec.GitOps.Bootstrap != nil </span><span class="cov1" title="1">{
                        c.GitOps.Bootstrap = &amp;stack.BootstrapConfig{
                                Enabled:         config.Spec.GitOps.Bootstrap.Enabled,
                                FluxMode:        config.Spec.GitOps.Bootstrap.FluxMode,
                                FluxVersion:     config.Spec.GitOps.Bootstrap.FluxVersion,
                                Components:      config.Spec.GitOps.Bootstrap.Components,
                                Registry:        config.Spec.GitOps.Bootstrap.Registry,
                                ImagePullSecret: config.Spec.GitOps.Bootstrap.ImagePullSecret,
                                SourceURL:       config.Spec.GitOps.Bootstrap.SourceURL,
                                SourceRef:       config.Spec.GitOps.Bootstrap.SourceRef,
                                ArgoCDVersion:   config.Spec.GitOps.Bootstrap.ArgoCDVersion,
                                ArgoCDNamespace: config.Spec.GitOps.Bootstrap.ArgoCDNamespace,
                        }
                }</span>
        }

        <span class="cov3" title="4">return c</span>
}

// ConvertNodeToV1Alpha1 converts an unversioned Node to a v1alpha1 NodeConfig
func ConvertNodeToV1Alpha1(n *stack.Node) *NodeConfig <span class="cov10" title="125">{
        if n == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov9" title="124">config := &amp;NodeConfig{
                APIVersion: "stack.gokure.dev/v1alpha1",
                Kind:       "Node",
                Metadata: gvk.BaseMetadata{
                        Name: n.Name,
                },
                Spec: NodeSpec{
                        ParentPath: n.ParentPath,
                        PackageRef: n.PackageRef,
                },
        }

        // Convert children references
        for _, child := range n.Children </span><span class="cov9" title="121">{
                if child != nil </span><span class="cov9" title="120">{
                        config.Spec.Children = append(config.Spec.Children, NodeReference{
                                Name:       child.Name,
                                APIVersion: "stack.gokure.dev/v1alpha1",
                        })
                }</span>
        }

        // Convert bundle reference
        <span class="cov9" title="124">if n.Bundle != nil </span><span class="cov9" title="116">{
                config.Spec.Bundle = &amp;BundleReference{
                        Name:       n.Bundle.Name,
                        APIVersion: "stack.gokure.dev/v1alpha1",
                }
        }</span>

        <span class="cov9" title="124">return config</span>
}

// ConvertV1Alpha1ToNode converts a v1alpha1 NodeConfig to an unversioned Node
func ConvertV1Alpha1ToNode(config *NodeConfig) *stack.Node <span class="cov3" title="3">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="3">n := &amp;stack.Node{
                Name:       config.Metadata.Name,
                ParentPath: config.Spec.ParentPath,
                PackageRef: config.Spec.PackageRef,
        }

        // Note: We don't convert children and bundle here as they would require
        // access to the full set of nodes and bundles. This should be handled
        // at a higher level that has access to all configurations

        return n</span>
}

// ConvertBundleToV1Alpha1 converts an unversioned Bundle to a v1alpha1 BundleConfig
func ConvertBundleToV1Alpha1(b *stack.Bundle) *BundleConfig <span class="cov9" title="121">{
        if b == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov9" title="120">config := &amp;BundleConfig{
                APIVersion: "stack.gokure.dev/v1alpha1",
                Kind:       "Bundle",
                Metadata: gvk.BaseMetadata{
                        Name: b.Name,
                },
                Spec: BundleSpec{
                        ParentPath: b.ParentPath,
                        Interval:   b.Interval,
                        Labels:     b.Labels,
                },
        }

        // Convert source ref
        if b.SourceRef != nil </span><span class="cov1" title="1">{
                config.Spec.SourceRef = &amp;SourceRef{
                        Kind:      b.SourceRef.Kind,
                        Name:      b.SourceRef.Name,
                        Namespace: b.SourceRef.Namespace,
                }
        }</span>

        // Convert dependencies
        <span class="cov9" title="120">for _, dep := range b.DependsOn </span><span class="cov4" title="8">{
                if dep != nil </span><span class="cov4" title="7">{
                        config.Spec.DependsOn = append(config.Spec.DependsOn, BundleReference{
                                Name:       dep.Name,
                                APIVersion: "stack.gokure.dev/v1alpha1",
                        })
                }</span>
        }

        // Convert applications
        <span class="cov9" title="120">for _, app := range b.Applications </span><span class="cov6" title="21">{
                if app != nil </span><span class="cov6" title="20">{
                        // Use the application's name and default GVK
                        // In the future, we could enhance Application to track its GVK
                        apiVersion := "generators.gokure.dev/v1alpha1"
                        kind := "Application"

                        config.Spec.Applications = append(config.Spec.Applications, ApplicationReference{
                                Name:       app.Name,
                                APIVersion: apiVersion,
                                Kind:       kind,
                        })
                }</span>
        }

        <span class="cov9" title="120">return config</span>
}

// ConvertV1Alpha1ToBundle converts a v1alpha1 BundleConfig to an unversioned Bundle
func ConvertV1Alpha1ToBundle(config *BundleConfig) *stack.Bundle <span class="cov2" title="2">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov2" title="2">b := &amp;stack.Bundle{
                Name:       config.Metadata.Name,
                ParentPath: config.Spec.ParentPath,
                Interval:   config.Spec.Interval,
                Labels:     config.Spec.Labels,
        }

        // Convert source ref
        if config.Spec.SourceRef != nil </span><span class="cov0" title="0">{
                b.SourceRef = &amp;stack.SourceRef{
                        Kind:      config.Spec.SourceRef.Kind,
                        Name:      config.Spec.SourceRef.Name,
                        Namespace: config.Spec.SourceRef.Namespace,
                }
        }</span>

        // Note: We don't convert dependencies and applications here as they would require
        // access to the full set of bundles and applications. This should be handled
        // at a higher level that has access to all configurations

        <span class="cov2" title="2">return b</span>
}

// StackConverter provides methods to convert between versioned and unversioned stack types
type StackConverter struct {
        // nodeMap maps node names to their configs for reconstruction
        nodeMap map[string]*NodeConfig

        // bundleMap maps bundle names to their configs for reconstruction
        bundleMap map[string]*BundleConfig

        // appMap maps application references to their actual applications
        appMap map[string]*stack.Application
}

// NewStackConverter creates a new stack converter
func NewStackConverter() *StackConverter <span class="cov4" title="6">{
        return &amp;StackConverter{
                nodeMap:   make(map[string]*NodeConfig),
                bundleMap: make(map[string]*BundleConfig),
                appMap:    make(map[string]*stack.Application),
        }
}</span>

// ConvertClusterTreeToV1Alpha1 converts a full cluster tree to versioned configs
func (c *StackConverter) ConvertClusterTreeToV1Alpha1(cluster *stack.Cluster) (*ClusterConfig, []*NodeConfig, []*BundleConfig) <span class="cov4" title="5">{
        if cluster == nil </span><span class="cov1" title="1">{
                return nil, nil, nil
        }</span>

        // Convert cluster
        <span class="cov3" title="4">clusterConfig := ConvertClusterToV1Alpha1(cluster)

        // Convert all nodes recursively
        var nodes []*NodeConfig
        var bundles []*BundleConfig

        if cluster.Node != nil </span><span class="cov3" title="4">{
                c.convertNodeTreeToV1Alpha1(cluster.Node, &amp;nodes, &amp;bundles)
        }</span>

        <span class="cov3" title="4">return clusterConfig, nodes, bundles</span>
}

// convertNodeTreeToV1Alpha1 recursively converts nodes and their bundles
func (c *StackConverter) convertNodeTreeToV1Alpha1(node *stack.Node, nodes *[]*NodeConfig, bundles *[]*BundleConfig) <span class="cov9" title="120">{
        if node == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Convert this node
        <span class="cov9" title="120">nodeConfig := ConvertNodeToV1Alpha1(node)
        *nodes = append(*nodes, nodeConfig)
        c.nodeMap[node.Name] = nodeConfig

        // Convert bundle if present
        if node.Bundle != nil </span><span class="cov9" title="115">{
                bundleConfig := ConvertBundleToV1Alpha1(node.Bundle)
                *bundles = append(*bundles, bundleConfig)
                c.bundleMap[node.Bundle.Name] = bundleConfig
        }</span>

        // Recursively convert children
        <span class="cov9" title="120">for _, child := range node.Children </span><span class="cov9" title="116">{
                c.convertNodeTreeToV1Alpha1(child, nodes, bundles)
        }</span>
}

// ConvertV1Alpha1ToClusterTree converts versioned configs back to a cluster tree
func (c *StackConverter) ConvertV1Alpha1ToClusterTree(
        clusterConfig *ClusterConfig,
        nodeConfigs []*NodeConfig,
        bundleConfigs []*BundleConfig,
        applications []*stack.Application,
) *stack.Cluster <span class="cov3" title="3">{
        if clusterConfig == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Build maps for lookup
        <span class="cov2" title="2">nodeMap := make(map[string]*stack.Node)
        bundleMap := make(map[string]*stack.Bundle)

        // Convert all bundles first
        for _, bundleConfig := range bundleConfigs </span><span class="cov2" title="2">{
                bundle := ConvertV1Alpha1ToBundle(bundleConfig)
                bundleMap[bundleConfig.Metadata.Name] = bundle

                // Resolve applications
                for _, appRef := range bundleConfig.Spec.Applications </span><span class="cov3" title="3">{
                        for _, app := range applications </span><span class="cov4" title="6">{
                                if app.Name == appRef.Name </span><span class="cov3" title="3">{
                                        bundle.Applications = append(bundle.Applications, app)
                                        break</span>
                                }
                        }
                }

                // Dependencies will be resolved after all bundles are created
        }

        // Resolve bundle dependencies
        <span class="cov2" title="2">for _, bundleConfig := range bundleConfigs </span><span class="cov2" title="2">{
                bundle := bundleMap[bundleConfig.Metadata.Name]
                for _, depRef := range bundleConfig.Spec.DependsOn </span><span class="cov1" title="1">{
                        if dep, exists := bundleMap[depRef.Name]; exists </span><span class="cov1" title="1">{
                                bundle.DependsOn = append(bundle.DependsOn, dep)
                        }</span>
                }
        }

        // Convert all nodes
        <span class="cov2" title="2">for _, nodeConfig := range nodeConfigs </span><span class="cov3" title="3">{
                node := ConvertV1Alpha1ToNode(nodeConfig)
                nodeMap[nodeConfig.Metadata.Name] = node

                // Resolve bundle reference
                if nodeConfig.Spec.Bundle != nil </span><span class="cov2" title="2">{
                        if bundle, exists := bundleMap[nodeConfig.Spec.Bundle.Name]; exists </span><span class="cov2" title="2">{
                                node.Bundle = bundle
                        }</span>
                }
        }

        // Build node tree structure
        <span class="cov2" title="2">for _, nodeConfig := range nodeConfigs </span><span class="cov3" title="3">{
                node := nodeMap[nodeConfig.Metadata.Name]

                // Add children
                for _, childRef := range nodeConfig.Spec.Children </span><span class="cov2" title="2">{
                        if child, exists := nodeMap[childRef.Name]; exists </span><span class="cov2" title="2">{
                                node.Children = append(node.Children, child)
                                child.SetParent(node)
                        }</span>
                }
        }

        // Convert cluster and attach root node
        <span class="cov2" title="2">cluster := ConvertV1Alpha1ToCluster(clusterConfig)

        // Find and attach root node
        if clusterConfig.Spec.Node != nil </span><span class="cov1" title="1">{
                if rootNode, exists := nodeMap[clusterConfig.Spec.Node.Name]; exists </span><span class="cov1" title="1">{
                        cluster.Node = rootNode
                }</span>
        }

        <span class="cov2" title="2">return cluster</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package v1alpha1

import (
        "github.com/go-kure/kure/internal/gvk"
        "github.com/go-kure/kure/pkg/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// NodeConfig represents a versioned node configuration
// +gvk:group=stack.gokure.dev
// +gvk:version=v1alpha1
// +gvk:kind=Node
type NodeConfig struct {
        APIVersion string           `yaml:"apiVersion" json:"apiVersion"`
        Kind       string           `yaml:"kind" json:"kind"`
        Metadata   gvk.BaseMetadata `yaml:"metadata" json:"metadata"`
        Spec       NodeSpec         `yaml:"spec" json:"spec"`
}

// NodeSpec defines the specification for a node
type NodeSpec struct {
        // ParentPath is the hierarchical path to the parent node (e.g., "cluster/infrastructure")
        // Empty for root nodes. This avoids circular references while maintaining hierarchy.
        ParentPath string `yaml:"parentPath,omitempty" json:"parentPath,omitempty"`

        // Children list child nodes
        Children []NodeReference `yaml:"children,omitempty" json:"children,omitempty"`

        // PackageRef identifies in which package the tree of resources get bundled together
        // If undefined, the PackageRef of the parent is inherited
        PackageRef *schema.GroupVersionKind `yaml:"packageRef,omitempty" json:"packageRef,omitempty"`

        // Bundle holds the applications that get deployed on this level
        Bundle *BundleReference `yaml:"bundle,omitempty" json:"bundle,omitempty"`

        // Description provides a human-readable description of the node
        Description string `yaml:"description,omitempty" json:"description,omitempty"`

        // Labels are key-value pairs for node metadata
        Labels map[string]string `yaml:"labels,omitempty" json:"labels,omitempty"`

        // Annotations are key-value pairs for node annotations
        Annotations map[string]string `yaml:"annotations,omitempty" json:"annotations,omitempty"`
}

// BundleReference references a Bundle configuration
type BundleReference struct {
        // Name of the bundle
        Name string `yaml:"name" json:"name"`

        // APIVersion of the referenced bundle (for future cross-version references)
        APIVersion string `yaml:"apiVersion,omitempty" json:"apiVersion,omitempty"`
}

// GetAPIVersion returns the API version of the node config
func (n *NodeConfig) GetAPIVersion() string <span class="cov5" title="3">{
        if n.APIVersion == "" </span><span class="cov0" title="0">{
                return "stack.gokure.dev/v1alpha1"
        }</span>
        <span class="cov5" title="3">return n.APIVersion</span>
}

// GetKind returns the kind of the node config
func (n *NodeConfig) GetKind() string <span class="cov0" title="0">{
        if n.Kind == "" </span><span class="cov0" title="0">{
                return "Node"
        }</span>
        <span class="cov0" title="0">return n.Kind</span>
}

// GetName returns the name of the node
func (n *NodeConfig) GetName() string <span class="cov10" title="11">{
        return n.Metadata.Name
}</span>

// SetName sets the name of the node
func (n *NodeConfig) SetName(name string) <span class="cov3" title="2">{
        n.Metadata.Name = name
}</span>

// GetNamespace returns the namespace of the node
func (n *NodeConfig) GetNamespace() string <span class="cov3" title="2">{
        return n.Metadata.Namespace
}</span>

// SetNamespace sets the namespace of the node
func (n *NodeConfig) SetNamespace(namespace string) <span class="cov3" title="2">{
        n.Metadata.Namespace = namespace
}</span>

// GetPath returns the full hierarchical path of this node
func (n *NodeConfig) GetPath() string <span class="cov7" title="5">{
        if n.Spec.ParentPath == "" </span><span class="cov3" title="2">{
                return n.Metadata.Name
        }</span>
        <span class="cov5" title="3">return n.Spec.ParentPath + "/" + n.Metadata.Name</span>
}

// Validate performs validation on the node configuration
func (n *NodeConfig) Validate() error <span class="cov9" title="9">{
        if n == nil </span><span class="cov1" title="1">{
                return errors.New("node config is nil")
        }</span>

        <span class="cov8" title="8">if n.Metadata.Name == "" </span><span class="cov3" title="2">{
                return errors.NewValidationError("metadata.name", "", "Node", nil)
        }</span>

        // Validate PackageRef if present
        <span class="cov7" title="6">if n.Spec.PackageRef != nil </span><span class="cov3" title="2">{
                if n.Spec.PackageRef.Kind == "" </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Node", n.Metadata.Name, "spec.packageRef.kind",
                                "packageRef kind cannot be empty", nil)
                }</span>
        }

        // Check for circular references in children
        <span class="cov7" title="5">childNames := make(map[string]bool)
        for _, child := range n.Spec.Children </span><span class="cov7" title="5">{
                if child.Name == "" </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Node", n.Metadata.Name, "spec.children",
                                "child node name cannot be empty", nil)
                }</span>
                <span class="cov6" title="4">if childNames[child.Name] </span><span class="cov1" title="1">{
                        return errors.ResourceValidationError("Node", n.Metadata.Name, "spec.children",
                                "duplicate child node name: "+child.Name, nil)
                }</span>
                <span class="cov5" title="3">childNames[child.Name] = true</span>
        }

        <span class="cov5" title="3">return nil</span>
}

// ConvertTo converts this node config to another version
func (n *NodeConfig) ConvertTo(version string) (interface{}, error) <span class="cov3" title="2">{
        switch version </span>{
        case "v1alpha1":<span class="cov1" title="1">
                return n, nil</span>
        default:<span class="cov1" title="1">
                return nil, errors.New("unsupported version: " + version)</span>
        }
}

// ConvertFrom converts from another version to this node config
func (n *NodeConfig) ConvertFrom(from interface{}) error <span class="cov1" title="1">{
        switch src := from.(type) </span>{
        case *NodeConfig:<span class="cov1" title="1">
                *n = *src
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("unsupported conversion source type")</span>
        }
}

// NewNodeConfig creates a new NodeConfig with default values
func NewNodeConfig(name string) *NodeConfig <span class="cov8" title="8">{
        return &amp;NodeConfig{
                APIVersion: "stack.gokure.dev/v1alpha1",
                Kind:       "Node",
                Metadata: gvk.BaseMetadata{
                        Name: name,
                },
                Spec: NodeSpec{},
        }
}</span>

// AddChild adds a child node reference
func (n *NodeConfig) AddChild(childName string) <span class="cov5" title="3">{
        n.Spec.Children = append(n.Spec.Children, NodeReference{
                Name:       childName,
                APIVersion: n.GetAPIVersion(),
        })
}</span>

// SetBundle sets the bundle reference
func (n *NodeConfig) SetBundle(bundleName string) <span class="cov3" title="2">{
        n.Spec.Bundle = &amp;BundleReference{
                Name:       bundleName,
                APIVersion: "stack.gokure.dev/v1alpha1",
        }
}</span>

// SetPackageRef sets the package reference
func (n *NodeConfig) SetPackageRef(group, version, kind string) <span class="cov1" title="1">{
        n.Spec.PackageRef = &amp;schema.GroupVersionKind{
                Group:   group,
                Version: version,
                Kind:    kind,
        }
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">package v1alpha1

import (
        "fmt"
        "sync"

        "github.com/go-kure/kure/internal/gvk"
)

// StackConfigType represents the type of stack configuration
type StackConfigType string

const (
        // StackConfigTypeCluster represents a Cluster configuration
        StackConfigTypeCluster StackConfigType = "Cluster"

        // StackConfigTypeNode represents a Node configuration
        StackConfigTypeNode StackConfigType = "Node"

        // StackConfigTypeBundle represents a Bundle configuration
        StackConfigTypeBundle StackConfigType = "Bundle"
)

// StackConfig is a common interface for all stack configuration types
type StackConfig interface {
        gvk.VersionedType
        gvk.MetadataType
        Validate() error
}

// StackConfigFactory creates stack configurations from raw data
type StackConfigFactory func() StackConfig

// StackRegistry manages registration and creation of stack configurations
type StackRegistry struct {
        mu        sync.RWMutex
        factories map[gvk.GVK]StackConfigFactory
}

// globalRegistry is the singleton registry instance
var globalRegistry = &amp;StackRegistry{
        factories: make(map[gvk.GVK]StackConfigFactory),
}

// init registers the default v1alpha1 stack types
func init() <span class="cov1" title="1">{
        // Register Cluster
        RegisterStackConfig(gvk.GVK{
                Group:   "stack.gokure.dev",
                Version: "v1alpha1",
                Kind:    "Cluster",
        }, func() StackConfig </span><span class="cov9" title="53">{
                return &amp;ClusterConfig{}
        }</span>)

        // Register Node
        <span class="cov1" title="1">RegisterStackConfig(gvk.GVK{
                Group:   "stack.gokure.dev",
                Version: "v1alpha1",
                Kind:    "Node",
        }, func() StackConfig </span><span class="cov1" title="1">{
                return &amp;NodeConfig{}
        }</span>)

        // Register Bundle
        <span class="cov1" title="1">RegisterStackConfig(gvk.GVK{
                Group:   "stack.gokure.dev",
                Version: "v1alpha1",
                Kind:    "Bundle",
        }, func() StackConfig </span><span class="cov1" title="1">{
                return &amp;BundleConfig{}
        }</span>)
}

// RegisterStackConfig registers a stack configuration factory for a GVK
func RegisterStackConfig(gvk gvk.GVK, factory StackConfigFactory) <span class="cov9" title="54">{
        globalRegistry.mu.Lock()
        defer globalRegistry.mu.Unlock()

        globalRegistry.factories[gvk] = factory
}</span>

// CreateStackConfig creates a new stack configuration for the given GVK
func CreateStackConfig(gvk gvk.GVK) (StackConfig, error) <span class="cov10" title="57">{
        globalRegistry.mu.RLock()
        defer globalRegistry.mu.RUnlock()

        factory, exists := globalRegistry.factories[gvk]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no factory registered for GVK: %s", gvk)
        }</span>

        <span class="cov9" title="56">return factory(), nil</span>
}

// GetRegisteredStackGVKs returns all registered stack configuration GVKs
func GetRegisteredStackGVKs() []gvk.GVK <span class="cov1" title="1">{
        globalRegistry.mu.RLock()
        defer globalRegistry.mu.RUnlock()

        gvks := make([]gvk.GVK, 0, len(globalRegistry.factories))
        for gvk := range globalRegistry.factories </span><span class="cov3" title="3">{
                gvks = append(gvks, gvk)
        }</span>

        <span class="cov1" title="1">return gvks</span>
}

// IsStackConfigRegistered checks if a GVK is registered for stack configurations
func IsStackConfigRegistered(g gvk.GVK) bool <span class="cov4" title="4">{
        globalRegistry.mu.RLock()
        defer globalRegistry.mu.RUnlock()

        _, exists := globalRegistry.factories[g]
        return exists
}</span>

// StackWrapper provides a unified wrapper for stack configurations
type StackWrapper struct {
        gvk    gvk.GVK
        config StackConfig
}

// NewStackWrapper creates a new stack wrapper from a GVK and configuration
func NewStackWrapper(g gvk.GVK, config StackConfig) *StackWrapper <span class="cov4" title="4">{
        return &amp;StackWrapper{
                gvk:    g,
                config: config,
        }
}</span>

// CreateStackWrapper creates a new stack wrapper for the given GVK
func CreateStackWrapper(g gvk.GVK) (*StackWrapper, error) <span class="cov4" title="4">{
        config, err := CreateStackConfig(g)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="4">return &amp;StackWrapper{
                gvk:    g,
                config: config,
        }, nil</span>
}

// GetGVK returns the GVK of the wrapped configuration
func (w *StackWrapper) GetGVK() gvk.GVK <span class="cov1" title="1">{
        return w.gvk
}</span>

// GetConfig returns the wrapped configuration
func (w *StackWrapper) GetConfig() StackConfig <span class="cov1" title="1">{
        return w.config
}</span>

// GetType returns the stack configuration type
func (w *StackWrapper) GetType() StackConfigType <span class="cov2" title="2">{
        switch w.gvk.Kind </span>{
        case "Cluster":<span class="cov1" title="1">
                return StackConfigTypeCluster</span>
        case "Node":<span class="cov0" title="0">
                return StackConfigTypeNode</span>
        case "Bundle":<span class="cov0" title="0">
                return StackConfigTypeBundle</span>
        default:<span class="cov1" title="1">
                return StackConfigType(w.gvk.Kind)</span>
        }
}

// Validate validates the wrapped configuration
func (w *StackWrapper) Validate() error <span class="cov4" title="4">{
        if w.config == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("wrapped configuration is nil")
        }</span>
        <span class="cov3" title="3">return w.config.Validate()</span>
}

// AsCluster returns the configuration as a ClusterConfig if it is one
func (w *StackWrapper) AsCluster() (*ClusterConfig, bool) <span class="cov3" title="3">{
        cluster, ok := w.config.(*ClusterConfig)
        return cluster, ok
}</span>

// AsNode returns the configuration as a NodeConfig if it is one
func (w *StackWrapper) AsNode() (*NodeConfig, bool) <span class="cov2" title="2">{
        node, ok := w.config.(*NodeConfig)
        return node, ok
}</span>

// AsBundle returns the configuration as a BundleConfig if it is one
func (w *StackWrapper) AsBundle() (*BundleConfig, bool) <span class="cov2" title="2">{
        bundle, ok := w.config.(*BundleConfig)
        return bundle, ok
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">package stack

import (
        "fmt"

        "sigs.k8s.io/controller-runtime/pkg/client"
)

// Workflow defines the core interface for GitOps workflow implementations.
// This interface provides a minimal abstraction for converting stack definitions
// into GitOps-specific resources (Flux Kustomizations, ArgoCD Applications, etc.).
type Workflow interface {
        // GenerateFromCluster creates GitOps resources from a cluster definition.
        // This is the primary entry point for resource generation.
        GenerateFromCluster(*Cluster) ([]client.Object, error)

        // CreateLayoutWithResources creates a new manifest layout that includes
        // both the application manifests and the GitOps resources needed to
        // deploy them. This combines manifest generation with GitOps resource
        // generation in a single operation.
        // The rules parameter is expected to be of type layout.LayoutRules
        CreateLayoutWithResources(*Cluster, interface{}) (interface{}, error)

        // GenerateBootstrap creates bootstrap resources for initializing the
        // GitOps system itself. This is used to set up the GitOps controller
        // (Flux, ArgoCD, etc.) in the cluster.
        GenerateBootstrap(*BootstrapConfig, *Node) ([]client.Object, error)
}

// NewWorkflow creates a workflow implementation based on the provider type.
// Supported providers: "flux", "argocd"
func NewWorkflow(provider string) (Workflow, error) <span class="cov10" title="7">{
        switch provider </span>{
        case "flux", "fluxcd":<span class="cov6" title="3">
                // Import cycle prevention: use a factory function
                return newFluxWorkflow(), nil</span>
        case "argo", "argocd":<span class="cov6" title="3">
                // Import cycle prevention: use a factory function
                return newArgoWorkflow(), nil</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported GitOps provider: %s", provider)</span>
        }
}

// These factory functions will be implemented by the respective packages
// to avoid import cycles.
var (
        newFluxWorkflow func() Workflow
        newArgoWorkflow func() Workflow
)

// RegisterFluxWorkflow registers the Flux workflow factory.
// This is called by the fluxcd package during init.
func RegisterFluxWorkflow(factory func() Workflow) <span class="cov1" title="1">{
        newFluxWorkflow = factory
}</span>

// RegisterArgoWorkflow registers the ArgoCD workflow factory.
// This is called by the argocd package during init.
func RegisterArgoWorkflow(factory func() Workflow) <span class="cov1" title="1">{
        newArgoWorkflow = factory
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
